\hypertarget{sys__selftest_8c}{}\section{generated\+\_\+launchpad/source/sys\+\_\+selftest.c File Reference}
\label{sys__selftest_8c}\index{generated\+\_\+launchpad/source/sys\+\_\+selftest.\+c@{generated\+\_\+launchpad/source/sys\+\_\+selftest.\+c}}


Selftest Source File.  


{\ttfamily \#include \char`\"{}sys\+\_\+selftest.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}sys\+\_\+core.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}sys\+\_\+pmu.\+h\char`\"{}}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftest\+Fail\+Notification}} (uint32 flag)
\begin{DoxyCompactList}\small\item\em Self test fail service routine. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a2f7aaa1d96319ecb5d7b6cec31c56670}{ccm\+Self\+Check}} (void)
\begin{DoxyCompactList}\small\item\em C\+CM module self check Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a3184dfe0846903e1111348942160dfe7}{memory\+Init}} (uint32 ram)
\begin{DoxyCompactList}\small\item\em Memory Initialization Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a54f7309e862bab7a63c2c176c4b7cee9}{stc\+Self\+Check}} (void)
\begin{DoxyCompactList}\small\item\em S\+TC module self check Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a27cee1191b0027e90cbb9c66983596b9}{cpu\+Self\+Test}} (uint32 no\+\_\+of\+\_\+intervals, uint32 max\+\_\+timeout, boolean restart\+\_\+test)
\begin{DoxyCompactList}\small\item\em C\+PU self test Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_ac9b7e2d9da2b5166a9ea002d431e54ef}{pbist\+Self\+Check}} (void)
\begin{DoxyCompactList}\small\item\em P\+B\+I\+ST self test Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_ad5fcc064d8d51dda635d83235cf37e3e}{pbist\+Run}} (uint32 raminfoL, uint32 algomask)
\begin{DoxyCompactList}\small\item\em C\+PU self test Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a1ea172c81d7549cd8181de098a91b752}{pbist\+Stop}} (void)
\begin{DoxyCompactList}\small\item\em Routine to stop P\+B\+I\+ST test enabled. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8c_a2675f441b1c7bbadd9877cfd586bf959}{pbist\+Is\+Test\+Completed}} (void)
\begin{DoxyCompactList}\small\item\em Checks to see if the P\+B\+I\+ST test is completed. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8c_a975a794505ddcaf5d1c68e7a229fc8ae}{pbist\+Is\+Test\+Passed}} (void)
\begin{DoxyCompactList}\small\item\em Checks to see if the P\+B\+I\+ST test is completed successfully. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8c_a3edbda42e27655bb5e9a3d067ab09caf}{pbist\+Port\+Test\+Status}} (uint32 port)
\begin{DoxyCompactList}\small\item\em Checks to see if the P\+B\+I\+ST Port test is completed successfully. \end{DoxyCompactList}\item 
uint32 \mbox{\hyperlink{sys__selftest_8c_a646eb27315f3ce47edde97c563389f76}{efc\+Check}} (void)
\begin{DoxyCompactList}\small\item\em E\+F\+U\+SE module self check Driver. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8c_a9973f032c29389602b684d30ea390fad}{efc\+Stuck\+Zero\+Test}} (void)
\begin{DoxyCompactList}\small\item\em Checks to see if the E\+F\+U\+SE Stuck at zero test is completed successfully. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_afd6cec31a44e7c8e325a744e9bcbf601}{efc\+Self\+Test}} (void)
\begin{DoxyCompactList}\small\item\em E\+F\+U\+SE module self check Driver. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8c_ad44409ae54516ba10303dd5c011f4fa6}{checkefc\+Self\+Test}} (void)
\begin{DoxyCompactList}\small\item\em E\+F\+U\+SE module self check Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a3248a50d5c0516f336b46aa0114ba9be}{fmc\+Bus2\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Self Check Flash Bus2 Interface. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a183a0d9f1300394cff2f8fe0aa034d4b}{fmc\+E\+C\+Ccheck}} (void)
\begin{DoxyCompactList}\small\item\em Check Flash E\+CC Single Bit and multi Bit errors detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_ad4cbf907aa7750c1c3601ed191842dd9}{check\+B0\+R\+A\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+A\+M1 E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_ab5e986484f3be2af5cd3a7595ba346c2}{check\+B1\+R\+A\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+A\+M2 E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a02bb81fd1b585ba20d4c6e7ed427a4ac}{check\+Flash\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check Flash E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a58597c65615a9a0f05d48135ad48c0d6}{custom\+\_\+dabort}} (void)
\begin{DoxyCompactList}\small\item\em Custom Data abort routine for the application. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a2c1518db428c8ab63a56048cadfb4e6e}{stc\+Self\+Check\+Fail}} (void)
\begin{DoxyCompactList}\small\item\em S\+TC Self test check fail service routine. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a932e8fff5749ae8038f0fbbe9029ec44}{cpu\+Self\+Test\+Fail}} (void)
\begin{DoxyCompactList}\small\item\em C\+PU Self test check fail service routine. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_af7297818ebd5ffd62488091aa9633bf9}{vim\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check V\+IM R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_add4aed7c0b3711f72c9228a92effa518}{dma\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check D\+MA control packet R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a66f658578435dc4d3984c76a3d2ed959}{het1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+E\+T1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a5f69665c7b7abb003cfb4a314ce1e943}{htu1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+T\+U1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a08473bcd7b0a42d859fe99011c4707b7}{het2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+E\+T2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_aaf183a3ffe2ce7257d5fbceb4cca69f0}{htu2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+T\+U2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a0267c576250cc80c1ffafae379fcd937}{adc1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check A\+D\+C1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_adad16c8dd5c10c57ff43cc705364bbde}{adc2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check A\+D\+C2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a034e78d72a2a9231d27d78256d3d194e}{can1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check C\+A\+N1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a0b4bb222e016b734e702da6a1ec5ab8a}{can2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check C\+A\+N2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_aba201eb114d129fe574af9dd61e6df05}{can3\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check C\+A\+N3 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a050e0c2257b541e651eb35d32f10c98d}{mibspi1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check M\+I\+B\+S\+P\+I1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_ae4c80f3599811e410da64821448b860b}{mibspi3\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check M\+I\+B\+S\+P\+I3 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a8ce4f5d8f1e282ddab7f65f5c5840e0a}{mibspi5\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check M\+I\+B\+S\+P\+I5 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a421594cf13d3b5ca42435c5a5604721c}{check\+R\+A\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+AM E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a012696be6fb67f7debf6f1ff6f9e3331}{check\+Clock\+Monitor}} (void)
\begin{DoxyCompactList}\small\item\em Check clock monitor failure detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a239d7544f8bb38fc73056467dbeb9e7c}{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check Flash E\+E\+P\+R\+OM E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a08d6355b5f4052d4ef5d2d995032ba22}{check\+P\+L\+L1\+Slip}} (void)
\begin{DoxyCompactList}\small\item\em Check P\+L\+L1 Slip detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_af5cf3a39340edcc591f7a1bd6a3ad021}{check\+P\+L\+L2\+Slip}} (void)
\begin{DoxyCompactList}\small\item\em Check P\+L\+L2 Slip detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a85eb55d96d4a491e84a930dbea0e89a5}{check\+R\+A\+M\+Addr\+Parity}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+AM Address parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a7e5bbec947e5db02df2bda4ba2230677}{check\+R\+A\+M\+U\+E\+R\+R\+Test}} (void)
\begin{DoxyCompactList}\small\item\em Run R\+AM test. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{sys__selftest_8c_aa035d17d1ecb2d6bb095a5c0b44a2143}\label{sys__selftest_8c_aa035d17d1ecb2d6bb095a5c0b44a2143}} 
void {\bfseries fmc\+Bus1\+Parity\+Check} (void)
\item 
\mbox{\Hypertarget{sys__selftest_8c_adc8a571e336b788da775b5279597c9f9}\label{sys__selftest_8c_adc8a571e336b788da775b5279597c9f9}} 
void {\bfseries pbist\+Fail} (void)
\item 
void \mbox{\hyperlink{sys__selftest_8c_a1edb8a500b4ad0f3e87b93245856a937}{pbist\+Get\+Config\+Value}} (\mbox{\hyperlink{structpbist__config__reg}{pbist\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_afb360fa06ebe94d06978d25371ed2140}{stc\+Get\+Config\+Value}} (\mbox{\hyperlink{structstc__config__reg}{stc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_ac76ed167d7b4b27eedea0eb37de6acc2}{efc\+Get\+Config\+Value}} (\mbox{\hyperlink{structefc__config__reg}{efc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_ab288da76a8169e1a92586cd06079358f}{ccmr4\+Get\+Config\+Value}} (\mbox{\hyperlink{structccmr4__config__reg}{ccmr4\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a1f3b71a00b6347cb5f7f6eb922c36c9e}{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4}} (void)
\begin{DoxyCompactList}\small\item\em Workaround for the Errata P\+B\+I\+ST\#4. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_af9ecd48548d7a3d98d5dcc44d1e7ca51}{enable\+Parity}} (void)
\begin{DoxyCompactList}\small\item\em Enable peripheral R\+AM parity. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8c_a15b66d583493adf7dc0ce8e3a89f00f5}{disable\+Parity}} (void)
\begin{DoxyCompactList}\small\item\em Disable peripheral R\+AM parity. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Selftest Source File. 

\begin{DoxyDate}{Date}
07-\/\+July-\/2017 
\end{DoxyDate}
\begin{DoxyVersion}{Version}
04.\+07.\+00
\end{DoxyVersion}
This file contains\+:
\begin{DoxyItemize}
\item Selftest A\+PI\textquotesingle{}s 
\end{DoxyItemize}

\subsection{Function Documentation}
\mbox{\Hypertarget{sys__selftest_8c_a0267c576250cc80c1ffafae379fcd937}\label{sys__selftest_8c_a0267c576250cc80c1ffafae379fcd937}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!adc1\+Parity\+Check@{adc1\+Parity\+Check}}
\index{adc1\+Parity\+Check@{adc1\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{adc1\+Parity\+Check()}{adc1ParityCheck()}}
{\footnotesize\ttfamily void adc1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check A\+D\+C1 R\+AM parity error detection and signaling mechanism. 

Routine to check A\+D\+C1 R\+AM parity error detection and signaling mechanism 

Definition at line 1526 of file sys\+\_\+selftest.\+c.



References adc\+P\+A\+R\+R\+A\+M1, adc\+R\+A\+M1, adc\+R\+E\+G1, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1527 \{
1528     \textcolor{keyword}{volatile} uint32 adcramread = 0U;
1529     uint32 adcparcr\_bk = \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR;
1530 
1531 \textcolor{comment}{/* USER CODE BEGIN (61) */}
1532 \textcolor{comment}{/* USER CODE END */}
1533 
1534     \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1535     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x10AU;
1536 
1537     \textcolor{comment}{/* Invert the parity bits inside the ADC1 RAM's first location */}
1538     \mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}} = ~(\mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}});
1539 
1540     \textcolor{comment}{/* clear the TEST bit */}
1541     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x00AU;
1542 
1543     \textcolor{comment}{/* This read is expected to trigger a parity error */}
1544     adcramread = \mbox{\hyperlink{reg__adc_8h_a2ffc4dd9d6f4d851ae80390db9d66c12}{adcRAM1}};
1545 
1546     \textcolor{comment}{/* Check for ESM group1 channel 19 to be flagged */}
1547     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80000U) ==0U)
1548     \{
1549         \textcolor{comment}{/* no ADC1 RAM parity error was flagged to ESM */}
1550         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(ADC1PARITYCHECK\_FAIL1);
1551     \}
1552     \textcolor{keywordflow}{else}
1553     \{
1554         \textcolor{comment}{/* clear ADC1 RAM parity error flag */}
1555         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80000U;
1556 
1557         \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1558         \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x10AU;
1559 
1560         \textcolor{comment}{/* Revert back the parity bits to correct data */}
1561         \mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}} = ~(\mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}});
1562     \}
1563 
1564     \textcolor{comment}{/* Restore parity control register */}
1565     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = adcparcr\_bk;
1566 
1567 \textcolor{comment}{/* USER CODE BEGIN (62) */}
1568 \textcolor{comment}{/* USER CODE END */}
1569 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_adad16c8dd5c10c57ff43cc705364bbde}\label{sys__selftest_8c_adad16c8dd5c10c57ff43cc705364bbde}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!adc2\+Parity\+Check@{adc2\+Parity\+Check}}
\index{adc2\+Parity\+Check@{adc2\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{adc2\+Parity\+Check()}{adc2ParityCheck()}}
{\footnotesize\ttfamily void adc2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check A\+D\+C2 R\+AM parity error detection and signaling mechanism. 

Routine to check A\+D\+C2 R\+AM parity error detection and signaling mechanism 

Definition at line 1580 of file sys\+\_\+selftest.\+c.



References adc\+P\+A\+R\+R\+A\+M2, adc\+R\+A\+M2, adc\+R\+E\+G2, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1581 \{
1582     \textcolor{keyword}{volatile} uint32 adcramread = 0U;
1583     uint32 adcparcr\_bk = \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR;
1584 
1585 \textcolor{comment}{/* USER CODE BEGIN (63) */}
1586 \textcolor{comment}{/* USER CODE END */}
1587 
1588     \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1589     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x10AU;
1590 
1591     \textcolor{comment}{/* Invert the parity bits inside the ADC2 RAM's first location */}
1592     \mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}} = ~(\mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}});
1593 
1594     \textcolor{comment}{/* clear the TEST bit */}
1595     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x00AU;
1596 
1597     \textcolor{comment}{/* This read is expected to trigger a parity error */}
1598     adcramread = \mbox{\hyperlink{reg__adc_8h_afc05d668ab22b6b181f74d09ef709beb}{adcRAM2}};
1599 
1600     \textcolor{comment}{/* Check for ESM group1 channel 1 to be flagged */}
1601     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x2U) == 0U)
1602     \{
1603         \textcolor{comment}{/* no ADC2 RAM parity error was flagged to ESM */}
1604         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(ADC2PARITYCHECK\_FAIL1);
1605     \}
1606     \textcolor{keywordflow}{else}
1607     \{
1608         \textcolor{comment}{/* clear ADC2 RAM parity error flag */}
1609         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x2U;
1610 
1611         \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1612         \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x10AU;
1613 
1614         \textcolor{comment}{/* Revert back the parity bits to correct data */}
1615         \mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}} = ~(\mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}});
1616     \}
1617 
1618     \textcolor{comment}{/* Restore parity control register*/}
1619     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = adcparcr\_bk;
1620 
1621 \textcolor{comment}{/* USER CODE BEGIN (64) */}
1622 \textcolor{comment}{/* USER CODE END */}
1623 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a034e78d72a2a9231d27d78256d3d194e}\label{sys__selftest_8c_a034e78d72a2a9231d27d78256d3d194e}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!can1\+Parity\+Check@{can1\+Parity\+Check}}
\index{can1\+Parity\+Check@{can1\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{can1\+Parity\+Check()}{can1ParityCheck()}}
{\footnotesize\ttfamily void can1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check C\+A\+N1 R\+AM parity error detection and signaling mechanism. 

Routine to check C\+A\+N1 R\+AM parity error detection and signaling mechanism 

Definition at line 1633 of file sys\+\_\+selftest.\+c.



References can\+P\+A\+R\+R\+A\+M1, can\+R\+A\+M1, can\+R\+E\+G1, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1634 \{
1635     \textcolor{keyword}{volatile} uint32 canread = 0U;
1636     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
1637     uint32 canctl\_bk =  \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL;
1638 
1639 \textcolor{comment}{/* USER CODE BEGIN (65) */}
1640 \textcolor{comment}{/* USER CODE END */}
1641 
1642     \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1643     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = 0x00001481U;
1644 
1645     \textcolor{comment}{/* Enable RAM Direct Access mode */}
1646     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->TEST = 0x00000200U;
1647 
1648     \textcolor{comment}{/* flip the parity bit */}
1649     \mbox{\hyperlink{reg__can_8h_ae6b205060d2fe86acdadc40de178493c}{canPARRAM1}} ^= 0x00001000U;
1650 
1651     \textcolor{comment}{/* Enable parity, disable init, still TEST mode */}
1652     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = 0x00002880U;
1653 
1654     \textcolor{comment}{/* Read location with parity error */}
1655     canread = \mbox{\hyperlink{reg__can_8h_abafb9e8112c19ec9e8e3ac56cbeef409}{canRAM1}};
1656 
1657     \textcolor{comment}{/* check if ESM group1 channel 21 is flagged */}
1658     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x00200000U) == 0U)
1659     \{
1660         \textcolor{comment}{/* No DCAN1 RAM parity error was flagged to ESM */}
1661         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CAN1PARITYCHECK\_FAIL1);
1662     \}
1663     \textcolor{keywordflow}{else}
1664     \{
1665         \textcolor{comment}{/* clear ESM group1 channel 21 flag */}
1666         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x00200000U;
1667 
1668         \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1669         \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = 0x00001481U;
1670 
1671         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1672         \mbox{\hyperlink{reg__can_8h_ae6b205060d2fe86acdadc40de178493c}{canPARRAM1}} ^= 0x00001000U;
1673     \}
1674 
1675     \textcolor{comment}{/* Disable RAM Direct Access mode */}
1676     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->TEST = 0x00000000U;
1677 
1678     \textcolor{comment}{/* Restore CTL register */}
1679     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = canctl\_bk;
1680 
1681     \textcolor{comment}{/* Read Error and Status register to clear Parity Error bit */}
1682     canread = \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->ES;
1683 
1684 \textcolor{comment}{/* USER CODE BEGIN (66) */}
1685 \textcolor{comment}{/* USER CODE END */}
1686 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a0b4bb222e016b734e702da6a1ec5ab8a}\label{sys__selftest_8c_a0b4bb222e016b734e702da6a1ec5ab8a}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!can2\+Parity\+Check@{can2\+Parity\+Check}}
\index{can2\+Parity\+Check@{can2\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{can2\+Parity\+Check()}{can2ParityCheck()}}
{\footnotesize\ttfamily void can2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check C\+A\+N2 R\+AM parity error detection and signaling mechanism. 

Routine to check C\+A\+N2 R\+AM parity error detection and signaling mechanism 

Definition at line 1697 of file sys\+\_\+selftest.\+c.



References can\+P\+A\+R\+R\+A\+M2, can\+R\+A\+M2, can\+R\+E\+G2, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1698 \{
1699     \textcolor{keyword}{volatile} uint32 canread = 0U;
1700     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
1701     uint32 canctl\_bk = \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL;
1702 
1703 \textcolor{comment}{/* USER CODE BEGIN (67) */}
1704 \textcolor{comment}{/* USER CODE END */}
1705 
1706     \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1707     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = 0x00001481U;
1708 
1709     \textcolor{comment}{/* Enable RAM Direct Access mode */}
1710     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->TEST = 0x00000200U;
1711 
1712     \textcolor{comment}{/* flip the parity bit */}
1713     \mbox{\hyperlink{reg__can_8h_a371c9079cb797249148aeee08bdcd3f8}{canPARRAM2}} ^= 0x00001000U;
1714 
1715     \textcolor{comment}{/* Enable parity, disable init, still TEST mode */}
1716     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = 0x00002880U;
1717 
1718     \textcolor{comment}{/* Read location with parity error */}
1719     canread = \mbox{\hyperlink{reg__can_8h_a715cfdf91b3cca750214e1c9c9a5b6e2}{canRAM2}};
1720 
1721     \textcolor{comment}{/* check if ESM group1 channel 23 is flagged */}
1722     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x00800000U) == 0U)
1723     \{
1724         \textcolor{comment}{/* No DCAN2 RAM parity error was flagged to ESM */}
1725         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CAN2PARITYCHECK\_FAIL1);
1726     \}
1727     \textcolor{keywordflow}{else}
1728     \{
1729         \textcolor{comment}{/* clear ESM group1 channel 23 flag */}
1730         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x00800000U;
1731 
1732         \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1733         \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = 0x00001481U;
1734 
1735         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1736         \mbox{\hyperlink{reg__can_8h_a371c9079cb797249148aeee08bdcd3f8}{canPARRAM2}} ^= 0x00001000U;
1737     \}
1738 
1739     \textcolor{comment}{/* Disable RAM Direct Access mode */}
1740     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->TEST = 0x00000000U;
1741 
1742     \textcolor{comment}{/* disable TEST mode */}
1743     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = canctl\_bk;
1744 
1745     \textcolor{comment}{/* Read Error and Status register to clear Parity Error bit */}
1746     canread = \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->ES;
1747 
1748 \textcolor{comment}{/* USER CODE BEGIN (68) */}
1749 \textcolor{comment}{/* USER CODE END */}
1750 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_aba201eb114d129fe574af9dd61e6df05}\label{sys__selftest_8c_aba201eb114d129fe574af9dd61e6df05}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!can3\+Parity\+Check@{can3\+Parity\+Check}}
\index{can3\+Parity\+Check@{can3\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{can3\+Parity\+Check()}{can3ParityCheck()}}
{\footnotesize\ttfamily void can3\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check C\+A\+N3 R\+AM parity error detection and signaling mechanism. 

Routine to check C\+A\+N3 R\+AM parity error detection and signaling mechanism 

Definition at line 1761 of file sys\+\_\+selftest.\+c.



References can\+P\+A\+R\+R\+A\+M3, can\+R\+A\+M3, can\+R\+E\+G3, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1762 \{
1763     \textcolor{keyword}{volatile} uint32 canread = 0U;
1764     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
1765     uint32 canctl\_bk = \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL;
1766 
1767 \textcolor{comment}{/* USER CODE BEGIN (69) */}
1768 \textcolor{comment}{/* USER CODE END */}
1769 
1770     \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1771     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = 0x00001481U;
1772 
1773     \textcolor{comment}{/* Enable RAM Direct Access mode */}
1774     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->TEST = 0x00000200U;
1775 
1776     \textcolor{comment}{/* flip the parity bit */}
1777     \mbox{\hyperlink{reg__can_8h_aa74f6edb7ce3f3c37e6a23c965437c43}{canPARRAM3}} ^= 0x00001000U;
1778 
1779     \textcolor{comment}{/* Enable parity, disable init, still TEST mode */}
1780     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = 0x00002880U;
1781 
1782     \textcolor{comment}{/* Read location with parity error */}
1783     canread = \mbox{\hyperlink{reg__can_8h_a16cd5c97c1260a2305d259ed783d1bdc}{canRAM3}};
1784 
1785     \textcolor{comment}{/* check if ESM group1 channel 22 is flagged */}
1786     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x00400000U) == 0U)
1787     \{
1788         \textcolor{comment}{/* No DCAN3 RAM parity error was flagged to ESM */}
1789         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CAN3PARITYCHECK\_FAIL1);
1790     \}
1791     \textcolor{keywordflow}{else}
1792     \{
1793         \textcolor{comment}{/* clear ESM group1 channel 22 flag */}
1794         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x00400000U;
1795 
1796         \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1797         \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = 0x00001481U;
1798 
1799         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1800         \mbox{\hyperlink{reg__can_8h_aa74f6edb7ce3f3c37e6a23c965437c43}{canPARRAM3}} ^= 0x00001000U;
1801     \}
1802 
1803     \textcolor{comment}{/* Disable RAM Direct Access mode */}
1804     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->TEST = 0x00000000U;
1805 
1806     \textcolor{comment}{/* disable TEST mode */}
1807     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = canctl\_bk;
1808 
1809     \textcolor{comment}{/* Read Error and Status register to clear Parity Error bit */}
1810     canread = \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->ES;
1811 
1812 \textcolor{comment}{/* USER CODE BEGIN (70) */}
1813 \textcolor{comment}{/* USER CODE END */}
1814 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ab288da76a8169e1a92586cd06079358f}\label{sys__selftest_8c_ab288da76a8169e1a92586cd06079358f}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!ccmr4\+Get\+Config\+Value@{ccmr4\+Get\+Config\+Value}}
\index{ccmr4\+Get\+Config\+Value@{ccmr4\+Get\+Config\+Value}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{ccmr4\+Get\+Config\+Value()}{ccmr4GetConfigValue()}}
{\footnotesize\ttfamily void ccmr4\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structccmr4__config__reg}{ccmr4\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2759 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2760 \{
2761     \textcolor{keywordflow}{if} (type == InitialValue)
2762     \{
2763         config\_reg->CONFIG\_CCMKEYR = CCMR4\_CCMKEYR\_CONFIGVALUE;
2764     \}
2765     \textcolor{keywordflow}{else}
2766     \{
2767     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2768         config\_reg->CONFIG\_CCMKEYR = CCMKEYR;
2769     \}
2770 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a2f7aaa1d96319ecb5d7b6cec31c56670}\label{sys__selftest_8c_a2f7aaa1d96319ecb5d7b6cec31c56670}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!ccm\+Self\+Check@{ccm\+Self\+Check}}
\index{ccm\+Self\+Check@{ccm\+Self\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{ccm\+Self\+Check()}{ccmSelfCheck()}}
{\footnotesize\ttfamily void ccm\+Self\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



C\+CM module self check Driver. 

This function self checks the C\+CM module. 

Definition at line 77 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
78 \{
79 \textcolor{comment}{/* USER CODE BEGIN (3) */}
80 \textcolor{comment}{/* USER CODE END */}
81 
82     \textcolor{comment}{/* Run a diagnostic check on the CCM-R4F module */}
83     \textcolor{comment}{/* This step ensures that the CCM-R4F can actually indicate an error */}
84 
85     \textcolor{comment}{/* Configure CCM in self-test mode */}
86     CCMKEYR = 0x6U;
87     \textcolor{comment}{/* Wait for CCM self-test to complete */}
88     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
89     \textcolor{keywordflow}{while} ((CCMSR & 0x100U) != 0x100U)
90     \{
91     \}\textcolor{comment}{/* Wait */}
92 
93 \textcolor{comment}{/* USER CODE BEGIN (4) */}
94 \textcolor{comment}{/* USER CODE END */}
95 
96     \textcolor{comment}{/* Check if there was an error during the self-test */}
97     \textcolor{keywordflow}{if} ((CCMSR & 0x1U) == 0x1U)
98     \{
99         \textcolor{comment}{/* STE is set */}
100         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL1);
101     \}
102     \textcolor{keywordflow}{else}
103     \{
104         \textcolor{comment}{/* Check CCM-R4 self-test error flag by itself (without compare error) */}
105         \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80000000U) == 0x80000000U)
106         \{
107             \textcolor{comment}{/* ESM flag is not set */}
108             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL2);
109         \}
110         \textcolor{keywordflow}{else}
111         \{
112             \textcolor{comment}{/* Configure CCM in error-forcing mode */}
113             CCMKEYR = 0x9U;
114 
115             \textcolor{comment}{/* Wait till error-forcing is completed. */}
116             \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
117             \textcolor{keywordflow}{while} (CCMKEYR != 0U)
118             \{
119             \}\textcolor{comment}{/* Wait */}
120 
121             \textcolor{comment}{/* check if compare error flag is set */}
122             \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] & 0x4U) != 0x4U)
123             \{
124                 \textcolor{comment}{/* ESM flag is not set */}
125                 \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL3);
126             \}
127             \textcolor{keywordflow}{else}
128             \{
129                 \textcolor{comment}{/* Check FIQIVEC to ESM High Interrupt flag is set */}
130                 \textcolor{keywordflow}{if}((vimREG->FIQINDEX & 0x000000FFU) != 1U)
131                 \{
132                    \textcolor{comment}{/* ESM High Interrupt flag is not set in VIM*/}
133                    \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL4);
134                 \}
135 
136                 \textcolor{comment}{/* clear ESM group2 channel 2 flag */}
137                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] = 0x4U;
138 
139                 \textcolor{comment}{/* clear ESM group2 shadow status flag */}
140                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SSR2 = 0x4U;
141 
142                 \textcolor{comment}{/* ESM self-test error needs to also be cleared */}
143                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80000000U;
144 
145                 \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
146                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
147 
148                 \textcolor{comment}{/* Configure CCM in selftest error-forcing mode */}
149                 CCMKEYR = 0xFU;
150 
151                 \textcolor{comment}{/* Wait till selftest error-forcing is completed. */}
152                 \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
153                 \textcolor{keywordflow}{while} (CCMKEYR != 0U)
154                 \{
155                 \}\textcolor{comment}{/* Wait */}
156 
157                 \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80000000U) != 0x80000000U)
158                 \{
159                     \textcolor{comment}{/* ESM flag not set */}
160                     \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL2);
161                 \}
162                 \textcolor{keywordflow}{else}
163                 \{
164                     \textcolor{comment}{/* clear ESM flag */}
165                     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80000000U;
166                 \}
167             \}
168         \}
169     \}
170 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ad4cbf907aa7750c1c3601ed191842dd9}\label{sys__selftest_8c_ad4cbf907aa7750c1c3601ed191842dd9}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+B0\+R\+A\+M\+E\+CC@{check\+B0\+R\+A\+M\+E\+CC}}
\index{check\+B0\+R\+A\+M\+E\+CC@{check\+B0\+R\+A\+M\+E\+CC}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+B0\+R\+A\+M\+E\+C\+C()}{checkB0RAMECC()}}
{\footnotesize\ttfamily void check\+B0\+R\+A\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+A\+M1 E\+CC error detection logic. 

This function checks T\+C\+R\+A\+M1 E\+CC error detection logic. 

Definition at line 851 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
852 \{
853     \textcolor{keyword}{volatile} uint64 ramread = 0U;
854     \textcolor{keyword}{volatile} uint32 regread = 0U;
855     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
856     
857     uint64 tcramA1\_bk = tcramA1bit;
858     uint64 tcramA2\_bk = tcramA2bit;
859     \textcolor{keyword}{volatile} uint32 i;
860 \textcolor{comment}{/* USER CODE BEGIN (36) */}
861 \textcolor{comment}{/* USER CODE END */}
862 
863     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
864     tcram1REG->RAMCTRL = 0x0005010AU;
865     tcram2REG->RAMCTRL = 0x0005010AU;
866 
867     \textcolor{comment}{/* the first 1-bit error will cause an error response */}
868     tcram1REG->RAMTHRESHOLD = 0x1U;
869     tcram2REG->RAMTHRESHOLD = 0x1U;
870 
871     \textcolor{comment}{/* allow SERR to be reported to ESM */}
872     tcram1REG->RAMINTCTRL = 0x1U;
873     tcram2REG->RAMINTCTRL = 0x1U;
874 
875     \textcolor{comment}{/* cause a 1-bit ECC error */}
876     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
877     tcramA1bitError ^= 0x1U;
878     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
879 
880     \textcolor{comment}{/* disable writes to ECC RAM */}
881     tcram1REG->RAMCTRL = 0x0005000AU;
882     tcram2REG->RAMCTRL = 0x0005000AU;
883 
884     \textcolor{comment}{/* read from location with 1-bit ECC error */}
885     ramread = tcramA1bit;
886 
887     \textcolor{comment}{/* Check for error status */}
888     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x1U;
889     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x1U;
890     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
891     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
892     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) && (tcram2ErrStat == 0U))
893     \{
894         \textcolor{comment}{/* TCRAM module does not reflect 1-bit error reported by CPU */}
895         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKB0RAMECC\_FAIL1);
896     \}
897     \textcolor{keywordflow}{else}
898     \{
899         \textcolor{comment}{/* clear SERR flag */}
900         tcram1REG->RAMERRSTATUS = 0x1U;
901         tcram2REG->RAMERRSTATUS = 0x1U;
902 
903         \textcolor{comment}{/* clear status flags for ESM group1 channels 26 and 28 */}
904         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x14000000U;
905     \}
906 
907     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
908     tcram1REG->RAMCTRL = 0x0005010AU;
909     tcram2REG->RAMCTRL = 0x0005010AU;
910 
911     \textcolor{comment}{/* cause a 2-bit ECC error */}
912     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
913     tcramA2bitError ^= 0x3U;
914     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
915 
916     \textcolor{comment}{/* read from location with 2-bit ECC error this will cause a data abort to be generated */}
917     ramread = tcramA2bit;
918 
919     \textcolor{comment}{/* delay before restoring the ram value */}
920     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
921     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
922     \textcolor{keywordflow}{for}(i=0U;i<10U;i++)
923     \{
924     \}\textcolor{comment}{/* Wait */}
925 
926     regread = tcram1REG->RAMUERRADDR;
927     regread = tcram2REG->RAMUERRADDR;
928 
929     \textcolor{comment}{/* disable writes to ECC RAM */}
930     tcram1REG->RAMCTRL = 0x0005000AU;
931     tcram2REG->RAMCTRL = 0x0005000AU;
932 
933     \textcolor{comment}{/* Compute correct ECC */}
934     tcramA1bit = tcramA1\_bk;
935     tcramA2bit = tcramA2\_bk;
936 
937 \textcolor{comment}{/* USER CODE BEGIN (37) */}
938 \textcolor{comment}{/* USER CODE END */}
939 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ab5e986484f3be2af5cd3a7595ba346c2}\label{sys__selftest_8c_ab5e986484f3be2af5cd3a7595ba346c2}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+B1\+R\+A\+M\+E\+CC@{check\+B1\+R\+A\+M\+E\+CC}}
\index{check\+B1\+R\+A\+M\+E\+CC@{check\+B1\+R\+A\+M\+E\+CC}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+B1\+R\+A\+M\+E\+C\+C()}{checkB1RAMECC()}}
{\footnotesize\ttfamily void check\+B1\+R\+A\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+A\+M2 E\+CC error detection logic. 

This function checks T\+C\+R\+A\+M2 E\+CC error detection logic. 

Definition at line 949 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
950 \{
951     \textcolor{keyword}{volatile} uint64 ramread = 0U;
952     \textcolor{keyword}{volatile} uint32 regread = 0U;
953     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
954 
955     uint64 tcramB1\_bk = tcramB1bit;
956     uint64 tcramB2\_bk = tcramB2bit;
957     \textcolor{keyword}{volatile} uint32 i;
958 \textcolor{comment}{/* USER CODE BEGIN (38) */}
959 \textcolor{comment}{/* USER CODE END */}
960 
961     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
962     tcram1REG->RAMCTRL = 0x0005010AU;
963     tcram2REG->RAMCTRL = 0x0005010AU;
964 
965     \textcolor{comment}{/* the first 1-bit error will cause an error response */}
966     tcram1REG->RAMTHRESHOLD = 0x1U;
967     tcram2REG->RAMTHRESHOLD = 0x1U;
968 
969     \textcolor{comment}{/* allow SERR to be reported to ESM */}
970     tcram1REG->RAMINTCTRL = 0x1U;
971     tcram2REG->RAMINTCTRL = 0x1U;
972 
973     \textcolor{comment}{/* cause a 1-bit ECC error */}
974     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
975     tcramB1bitError ^= 0x1U;
976     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
977 
978     \textcolor{comment}{/* disable writes to ECC RAM */}
979     tcram1REG->RAMCTRL = 0x0005000AU;
980     tcram2REG->RAMCTRL = 0x0005000AU;
981 
982     \textcolor{comment}{/* read from location with 1-bit ECC error */}
983     ramread = tcramB1bit;
984 
985     \textcolor{comment}{/* Check for error status */}
986     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x1U;
987     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x1U;
988     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
989     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
990     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) && (tcram2ErrStat == 0U))
991     \{
992         \textcolor{comment}{/* TCRAM module does not reflect 1-bit error reported by CPU */}
993         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKB1RAMECC\_FAIL1);
994     \}
995     \textcolor{keywordflow}{else}
996     \{
997         \textcolor{comment}{/* clear SERR flag */}
998         tcram1REG->RAMERRSTATUS = 0x1U;
999         tcram2REG->RAMERRSTATUS = 0x1U;
1000 
1001         \textcolor{comment}{/* clear status flags for ESM group1 channels 26 and 28 */}
1002         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x14000000U;
1003     \}
1004 
1005     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
1006     tcram1REG->RAMCTRL = 0x0005010AU;
1007     tcram2REG->RAMCTRL = 0x0005010AU;
1008 
1009     \textcolor{comment}{/* cause a 2-bit ECC error */}
1010     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
1011     tcramB2bitError ^= 0x3U;
1012     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
1013 
1014     \textcolor{comment}{/* read from location with 2-bit ECC error this will cause a data abort to be generated */}
1015     ramread = tcramB2bit;
1016 
1017     \textcolor{comment}{/* delay before restoring the ram value */}
1018     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
1019     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
1020     \textcolor{keywordflow}{for}(i=0U;i<10U;i++)
1021     \{
1022     \}\textcolor{comment}{/* Wait */}
1023 
1024     regread = tcram1REG->RAMUERRADDR;
1025     regread = tcram2REG->RAMUERRADDR;
1026 
1027     \textcolor{comment}{/* disable writes to ECC RAM */}
1028     tcram1REG->RAMCTRL = 0x0005000AU;
1029     tcram2REG->RAMCTRL = 0x0005000AU;
1030 
1031     \textcolor{comment}{/* Compute correct ECC */}
1032     tcramB1bit = tcramB1\_bk;
1033     tcramB2bit = tcramB2\_bk;
1034 
1035 \textcolor{comment}{/* USER CODE BEGIN (39) */}
1036 \textcolor{comment}{/* USER CODE END */}
1037 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a012696be6fb67f7debf6f1ff6f9e3331}\label{sys__selftest_8c_a012696be6fb67f7debf6f1ff6f9e3331}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+Clock\+Monitor@{check\+Clock\+Monitor}}
\index{check\+Clock\+Monitor@{check\+Clock\+Monitor}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+Clock\+Monitor()}{checkClockMonitor()}}
{\footnotesize\ttfamily void check\+Clock\+Monitor (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check clock monitor failure detection logic. 

This function checks clock monitor failure detection logic. 

Definition at line 2114 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, selftest\+Fail\+Notification(), and system\+R\+E\+G1.


\begin{DoxyCode}
2115 \{
2116     uint32 ghvsrc\_bk;
2117 
2118     \textcolor{comment}{/* Enable clock monitor range detection circuitry */}
2119     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CLKTEST |= 0x03000000U;
2120 
2121     \textcolor{comment}{/* Backup register GHVSRC */}
2122     ghvsrc\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC;
2123 
2124     \textcolor{comment}{/* Switch all clock domains to HF LPO */}
2125     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = 0x05050005U;
2126 
2127     \textcolor{comment}{/* Disable oscillator to cause a oscillator fail */}
2128     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISSET = 0x1U;
2129 
2130     \textcolor{comment}{/* Wait till oscillator fail flag is set */}
2131     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2132     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT & 0x1U) == 0U)
2133     \{
2134     \} \textcolor{comment}{/* Wait */}
2135 
2136     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x800U) != 0x800U)
2137     \{
2138         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKCLOCKMONITOR\_FAIL1);
2139     \}
2140     \textcolor{keywordflow}{else}
2141     \{
2142         \textcolor{comment}{/* Clear ESM flag */}
2143         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x800U;
2144 
2145         \textcolor{comment}{/* Disable clock monitor range detection circuitry */}
2146         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CLKTEST &= ~(0x03000000U);
2147 
2148         \textcolor{comment}{/* Enable oscillator */}
2149         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISCLR = 0x1U;
2150 
2151         \textcolor{comment}{/* Wait until oscillator is enabled */}
2152         \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2153         \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSVSTAT & 0x3U) == 0U)
2154         \{
2155         \} \textcolor{comment}{/* Wait */}
2156 
2157         \textcolor{comment}{/* Clear oscillator fail flag and PLL slip flag if any*/}
2158         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT = 0x301U;
2159 
2160         \textcolor{comment}{/* Switch back all clock domains */}
2161         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = ghvsrc\_bk;
2162     \}
2163 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ad44409ae54516ba10303dd5c011f4fa6}\label{sys__selftest_8c_ad44409ae54516ba10303dd5c011f4fa6}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!checkefc\+Self\+Test@{checkefc\+Self\+Test}}
\index{checkefc\+Self\+Test@{checkefc\+Self\+Test}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{checkefc\+Self\+Test()}{checkefcSelfTest()}}
{\footnotesize\ttfamily boolean checkefc\+Self\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



E\+F\+U\+SE module self check Driver. 

\begin{DoxyReturn}{Returns}
Returns T\+R\+UE if E\+FC Selftest was a P\+A\+SS, else F\+A\+L\+SE
\end{DoxyReturn}
This function returns the status of efc\+Self\+Test. Note\+: This function can be called only after calling efc\+Self\+Test 

Definition at line 721 of file sys\+\_\+selftest.\+c.



References F\+A\+L\+SE.



Referenced by system\+Init().


\begin{DoxyCode}
722 \{
723 \textcolor{comment}{/* USER CODE BEGIN (31) */}
724 \textcolor{comment}{/* USER CODE END */}
725     \textcolor{keywordtype}{boolean} result = \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
726 
727     uint32 EFC\_PINS, EFC\_ERROR;
728     uint32 esmCh40Stat, esmCh41Stat = 0U;
729 
730     \textcolor{comment}{/* wait until EFC self-test is done */}
731     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
732     \textcolor{keywordflow}{while}((efcREG->PINS & EFC\_SELF\_TEST\_DONE) == 0U)
733     \{
734     \}\textcolor{comment}{/* Wait */}
735 
736     \textcolor{comment}{/* check if EFC self-test error occurred */}
737     EFC\_PINS = efcREG->PINS;
738     EFC\_ERROR = efcREG->ERROR;
739     \textcolor{keywordflow}{if}(((EFC\_PINS & EFC\_SELF\_TEST\_ERROR) == 0U) && ((EFC\_ERROR & 0x1FU) == 0U))
740     \{
741         \textcolor{comment}{/* check if EFC self-test error is set */}
742         esmCh40Stat = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x100U;
743         esmCh41Stat = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x200U;
744         \textcolor{keywordflow}{if} ((esmCh40Stat == 0U) && (esmCh41Stat == 0U))
745         \{
746             result = \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}};
747         \}
748     \}
749     \textcolor{keywordflow}{return} result;
750 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a02bb81fd1b585ba20d4c6e7ed427a4ac}\label{sys__selftest_8c_a02bb81fd1b585ba20d4c6e7ed427a4ac}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+Flash\+E\+CC@{check\+Flash\+E\+CC}}
\index{check\+Flash\+E\+CC@{check\+Flash\+E\+CC}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+Flash\+E\+C\+C()}{checkFlashECC()}}
{\footnotesize\ttfamily void check\+Flash\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check Flash E\+CC error detection logic. 

This function checks Flash E\+CC error detection logic. 

Definition at line 1047 of file sys\+\_\+selftest.\+c.



References flash\+W\+R\+EG.


\begin{DoxyCode}
1048 \{
1049     \textcolor{comment}{/* Routine to check operation of ECC logic inside CPU for accesses to program flash */}
1050     \textcolor{keyword}{volatile} uint32 flashread = 0U;
1051 
1052 \textcolor{comment}{/* USER CODE BEGIN (40) */}
1053 \textcolor{comment}{/* USER CODE END */}
1054 
1055     \textcolor{comment}{/* Flash Module ECC Response enabled */}
1056     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACCTRL1 = 0x000A060AU;
1057 
1058     \textcolor{comment}{/* Enable diagnostic mode and select diag mode 7 */}
1059     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00050007U;
1060 
1061     \textcolor{comment}{/* Select ECC diagnostic mode, single-bit to be corrupted */}
1062     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FPAROVR = 0x00005A01U;
1063 
1064     \textcolor{comment}{/* Set the trigger for the diagnostic mode */}
1065     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
1066 
1067     \textcolor{comment}{/* read a flash location from the mirrored memory map */}
1068     flashread = flashBadECC1;
1069 
1070     \textcolor{comment}{/* disable diagnostic mode */}
1071     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x000A0007U;
1072 
1073     \textcolor{comment}{/* this will have caused a single-bit error to be generated and corrected by CPU */}
1074     \textcolor{comment}{/* single-bit error not captured in flash module */}
1075     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */}
1076     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS & 0x2U) == 0U)
1077     \{
1078         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHECC\_FAIL1);
1079     \}
1080     \textcolor{keywordflow}{else}
1081     \{
1082         \textcolor{comment}{/* clear single-bit error flag */}
1083         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS = 0x2U;
1084 
1085         \textcolor{comment}{/* clear ESM flag */}
1086         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40U;
1087 
1088         \textcolor{comment}{/* Enable diagnostic mode and select diag mode 7 */}
1089         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00050007U;
1090 
1091         \textcolor{comment}{/* Select ECC diagnostic mode, two bits of ECC to be corrupted */}
1092         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FPAROVR = 0x00005A03U;
1093 
1094         \textcolor{comment}{/* Set the trigger for the diagnostic mode */}
1095         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
1096 
1097         \textcolor{comment}{/* read from flash location from mirrored memory map this will cause a data abort */}
1098         flashread = flashBadECC2;
1099 
1100         \textcolor{comment}{/* Read FUNCERRADD register */}
1101         flashread = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FUNCERRADD;
1102 
1103         \textcolor{comment}{/* disable diagnostic mode */}
1104         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x000A0007U;
1105     \}
1106 
1107 \textcolor{comment}{/* USER CODE BEGIN (41) */}
1108 \textcolor{comment}{/* USER CODE END */}
1109 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a239d7544f8bb38fc73056467dbeb9e7c}\label{sys__selftest_8c_a239d7544f8bb38fc73056467dbeb9e7c}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC@{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC}}
\index{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC@{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+C\+C()}{checkFlashEEPROMECC()}}
{\footnotesize\ttfamily void check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check Flash E\+E\+P\+R\+OM E\+CC error detection logic. 

This function checks Flash E\+E\+P\+R\+OM E\+CC error detection logic. 

Definition at line 2173 of file sys\+\_\+selftest.\+c.



References flash\+W\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
2174 \{
2175     uint32 ecc;
2176     \textcolor{keyword}{volatile} uint32 regread;
2177 
2178     \textcolor{comment}{/* Set Single Error Correction Threshold as 1 */}
2179     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EECTRL2 |= 1U;
2180 
2181     \textcolor{comment}{/* Enable EEPROM Emulation Error Profiling */}
2182     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EECTRL1 |= 0x00000100U;
2183 
2184     \textcolor{comment}{/* Load FEMU\_XX regs in order to generate ECC */}
2185     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUADDR = 0xF0200000U;
2186     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDMSW = 0U;
2187     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDLSW = 0U;
2188 
2189     \textcolor{comment}{/* ECC for the correct data*/}
2190     ecc = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUECC;
2191 
2192     \textcolor{comment}{/* Load data with 1 bit error */}
2193     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDMSW = 0U;
2194     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDLSW = 1U;
2195 
2196     \textcolor{comment}{/* Enable Diagnostic ECC data correction mode and select FEE SECDED for diagnostic testing */}
2197     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00055001U;
2198 
2199     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUECC = ecc;
2200 
2201     \textcolor{comment}{/* Diagnostic trigger */}
2202     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
2203 
2204     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */}
2205     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS & 0x1U) != 0x1U)
2206     \{
2207         \textcolor{comment}{/* No single bit error was detected */}
2208         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL1);
2209     \}
2210     \textcolor{keywordflow}{else}
2211     \{
2212         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x8U) != 0x8U)
2213         \{
2214             \textcolor{comment}{/* EEPROM single bit error not captured in ESM */}
2215             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL2);
2216         \}
2217         \textcolor{keywordflow}{else}
2218         \{
2219             \textcolor{comment}{/* Clear single bit error flag in flash wrapper */}
2220             \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS = 0xFU;
2221 
2222             \textcolor{comment}{/* Clear ESM flag */}
2223             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x8U;
2224         \}
2225     \}
2226 
2227     \textcolor{comment}{/* Load data with 2 bit error */}
2228     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDMSW = 0U;
2229     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDLSW = 3U;
2230 
2231     \textcolor{comment}{/* Enable Diagnostic ECC data correction mode and select FEE SECDED for diagnostic testing */}
2232     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00055001U;
2233 
2234     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUECC = ecc;
2235 
2236     \textcolor{comment}{/* Diagnostic trigger */}
2237     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
2238 
2239     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */}
2240     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS & 0x100U) != 0x100U)
2241     \{
2242         \textcolor{comment}{/* No double bit error was detected */}
2243         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL3);
2244     \}
2245     \textcolor{keywordflow}{else}
2246     \{
2247         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x10U) != 0x10U)
2248         \{
2249             \textcolor{comment}{/* EEPROM double bit error not captured in ESM */}
2250             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL4);
2251         \}
2252         \textcolor{keywordflow}{else}
2253         \{
2254             \textcolor{comment}{/* Clear uncorrectable error flag in flash wrapper */}
2255             \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS = 0x1100U;
2256 
2257             \textcolor{comment}{/* Read EEUNCERRADD register */}
2258             regread = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EEUNCERRADD;
2259 
2260             \textcolor{comment}{/* Clear ESM flag */}
2261             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x10U;
2262 
2263 
2264         \}
2265     \}
2266 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a08d6355b5f4052d4ef5d2d995032ba22}\label{sys__selftest_8c_a08d6355b5f4052d4ef5d2d995032ba22}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+P\+L\+L1\+Slip@{check\+P\+L\+L1\+Slip}}
\index{check\+P\+L\+L1\+Slip@{check\+P\+L\+L1\+Slip}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+P\+L\+L1\+Slip()}{checkPLL1Slip()}}
{\footnotesize\ttfamily void check\+P\+L\+L1\+Slip (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check P\+L\+L1 Slip detection logic. 

This function checks P\+L\+L1 Slip detection logic. 

Definition at line 2276 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, selftest\+Fail\+Notification(), and system\+R\+E\+G1.


\begin{DoxyCode}
2277 \{
2278     uint32 ghvsrc\_bk, pllctl1\_bk;
2279 
2280     \textcolor{comment}{/* Back up the the registers GHVSRC and PLLCTRL1 */}
2281     ghvsrc\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC;
2282     pllctl1\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1;
2283 
2284     \textcolor{comment}{/* Switch all clock domains to oscillator */}
2285     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = 0x00000000U;
2286 
2287     \textcolor{comment}{/* Disable Reset on PLL Slip and enable Bypass on PLL slip */}
2288     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 &= 0x1FFFFFFFU;
2289 
2290     \textcolor{comment}{/* Force a PLL Slip */}
2291     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 ^= 0x8000U;
2292 
2293     \textcolor{comment}{/* Wait till PLL slip flag is set */}
2294     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2295     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT & 0x300U) == 0U)
2296     \{
2297     \} \textcolor{comment}{/* Wait */}
2298 
2299     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x400U) != 0x400U)
2300     \{
2301         \textcolor{comment}{/* ESM flag not set */}
2302         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKPLL1SLIP\_FAIL1);
2303     \}
2304     \textcolor{keywordflow}{else}
2305     \{
2306         \textcolor{comment}{/* Disable PLL1 */}
2307         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISSET = 0x2U;
2308 
2309         \textcolor{comment}{/* Wait till PLL1 is disabled */}
2310         \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2311         \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x2U) == 0U)
2312         \{
2313         \} \textcolor{comment}{/* Wait */}
2314 
2315         \textcolor{comment}{/* Restore the PLL multiplier value */}
2316         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 ^= 0x8000U;
2317 
2318         \textcolor{comment}{/* Enable PLL1 */}
2319         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISCLR = 0x2U;
2320 
2321         \textcolor{comment}{/* Wait till PLL1 is disabled */}
2322         \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2323         \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x2U) != 0U)
2324         \{
2325         \} \textcolor{comment}{/* Wait */}
2326 
2327         \textcolor{comment}{/* Switch back to the initial clock source */}
2328         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = ghvsrc\_bk;
2329 
2330         \textcolor{comment}{/* Clear PLL slip flag */}
2331         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT = 0x300U;
2332 
2333         \textcolor{comment}{/* Clear ESM flag */}
2334         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x400U;
2335 
2336         \textcolor{comment}{/* Restore the PLLCTL1 register */}
2337         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 = pllctl1\_bk;
2338     \}
2339 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_af5cf3a39340edcc591f7a1bd6a3ad021}\label{sys__selftest_8c_af5cf3a39340edcc591f7a1bd6a3ad021}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+P\+L\+L2\+Slip@{check\+P\+L\+L2\+Slip}}
\index{check\+P\+L\+L2\+Slip@{check\+P\+L\+L2\+Slip}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+P\+L\+L2\+Slip()}{checkPLL2Slip()}}
{\footnotesize\ttfamily void check\+P\+L\+L2\+Slip (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check P\+L\+L2 Slip detection logic. 

This function checks P\+L\+L2 Slip detection logic. 

Definition at line 2349 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, system\+R\+E\+G1, and system\+R\+E\+G2.


\begin{DoxyCode}
2350 \{
2351     uint32 ghvsrc\_bk;
2352 
2353     \textcolor{comment}{/* Back up the the register GHVSRC */}
2354     ghvsrc\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC;
2355 
2356     \textcolor{comment}{/* Switch all clock domains to oscillator */}
2357     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = 0x00000000U;
2358     
2359     \textcolor{comment}{/* Force a PLL2 Slip */}
2360     \mbox{\hyperlink{reg__system_8h_aa7b03254a6e13afea4c05b2fe8b2186b}{systemREG2}}->PLLCTL3 ^= 0x8000U;
2361 
2362     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2363     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x400U) != 0x400U)
2364     \{
2365         \textcolor{comment}{/* Wait till ESM flag is set */}
2366     \}
2367 
2368     \textcolor{comment}{/* Disable PLL2 */}
2369     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISSET = 0x40U;
2370 
2371     \textcolor{comment}{/* Wait till PLL2 is disabled */}
2372     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2373     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x40U) == 0U)
2374     \{
2375     \} \textcolor{comment}{/* Wait */}
2376 
2377     \textcolor{comment}{/* Restore the PLL 2 multiplier value */}
2378     \mbox{\hyperlink{reg__system_8h_aa7b03254a6e13afea4c05b2fe8b2186b}{systemREG2}}->PLLCTL3 ^= 0x8000U;
2379 
2380     \textcolor{comment}{/* Enable PLL2 */}
2381     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISCLR = 0x40U;
2382 
2383     \textcolor{comment}{/* Wait till PLL2 is disabled */}
2384     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2385     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x40U) != 0U)
2386     \{
2387     \} \textcolor{comment}{/* Wait */}
2388 
2389     \textcolor{comment}{/* Switch back to the initial clock source */}
2390     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = ghvsrc\_bk;
2391 
2392     \textcolor{comment}{/* Clear PLL slip flag */}
2393     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT = 0x300U;
2394 
2395     \textcolor{comment}{/* Clear ESM flag */}
2396     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x400U;
2397 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a85eb55d96d4a491e84a930dbea0e89a5}\label{sys__selftest_8c_a85eb55d96d4a491e84a930dbea0e89a5}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+R\+A\+M\+Addr\+Parity@{check\+R\+A\+M\+Addr\+Parity}}
\index{check\+R\+A\+M\+Addr\+Parity@{check\+R\+A\+M\+Addr\+Parity}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+R\+A\+M\+Addr\+Parity()}{checkRAMAddrParity()}}
{\footnotesize\ttfamily void check\+R\+A\+M\+Addr\+Parity (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+AM Address parity error detection and signaling mechanism. 

This function T\+C\+R\+AM Address parity error detection and signaling mechanism. 

Definition at line 2408 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2409 \{
2410     \textcolor{keyword}{register} uint64 ramread;
2411     \textcolor{keyword}{volatile} uint32 regread;
2412     uint32 tcram1ErrStat, tcram2ErrStat;
2413     
2414     \textcolor{comment}{/* Invert Address parity scheme */}
2415     tcram1REG->RAMCTRL = 0x0D05000AU;
2416     tcram2REG->RAMCTRL = 0x0D05000AU;
2417 
2418     \textcolor{comment}{/* Read from both RAM banks */}
2419     ramread = tcramA1bit;
2420     ramread = ramread | tcramB1bit; \textcolor{comment}{/* XOR-ing with ramread to avoid warnings */}
2421 
2422     \textcolor{comment}{/* Switch back to Address parity scheme */}
2423     tcram1REG->RAMCTRL = 0x0005000AU;
2424     tcram2REG->RAMCTRL = 0x0005000AU;
2425 
2426     \textcolor{comment}{/* Check for error status */}
2427     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x100U;
2428     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x100U;
2429     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2430     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2431     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) || (tcram2ErrStat == 0U))
2432     \{
2433         \textcolor{comment}{/* No Address parity error detected */}
2434         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMADDRPARITY\_FAIL1);
2435     \}
2436     \textcolor{keywordflow}{else}
2437     \{
2438         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] & 0x1400U) != 0x1400U)
2439         \{
2440             \textcolor{comment}{/* Address parity error not reported to ESM */}
2441             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMADDRPARITY\_FAIL2);
2442         \}
2443         \textcolor{keywordflow}{else}
2444         \{
2445             \textcolor{comment}{/* Clear Address parity error flag */}
2446             tcram1REG->RAMERRSTATUS = 0x300U;
2447             tcram2REG->RAMERRSTATUS = 0x300U;
2448 
2449             \textcolor{comment}{/* Clear ESM flag */}
2450             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] = 0x1400U;
2451 
2452             \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
2453             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
2454 
2455             regread = tcram1REG->RAMPERADDR;
2456             regread = tcram2REG->RAMPERADDR;
2457         \}
2458     \}
2459 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a421594cf13d3b5ca42435c5a5604721c}\label{sys__selftest_8c_a421594cf13d3b5ca42435c5a5604721c}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+R\+A\+M\+E\+CC@{check\+R\+A\+M\+E\+CC}}
\index{check\+R\+A\+M\+E\+CC@{check\+R\+A\+M\+E\+CC}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+R\+A\+M\+E\+C\+C()}{checkRAMECC()}}
{\footnotesize\ttfamily void check\+R\+A\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+AM E\+CC error detection logic. 

This function checks T\+C\+R\+AM E\+CC error detection logic. 

Definition at line 2017 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2018 \{
2019     \textcolor{keyword}{volatile} uint64 ramread = 0U;
2020     \textcolor{keyword}{volatile} uint32 regread = 0U;
2021     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
2022     
2023     uint64 tcramA1\_bk = tcramA1bit;
2024     uint64 tcramB1\_bk = tcramB1bit;
2025     uint64 tcramA2\_bk = tcramA2bit;
2026     uint64 tcramB2\_bk = tcramB2bit;
2027 
2028     \textcolor{comment}{/* Clear RAMOCUUR before setting RAMTHRESHOLD register */}
2029     tcram1REG->RAMOCCUR = 0U;
2030     tcram2REG->RAMOCCUR = 0U;
2031 
2032     \textcolor{comment}{/* Set Single-bit Error Threshold Count as 1 */}
2033     tcram1REG->RAMTHRESHOLD = 1U;
2034     tcram2REG->RAMTHRESHOLD = 1U;
2035 
2036     \textcolor{comment}{/* Enable single bit error generation */}
2037     tcram1REG->RAMINTCTRL = 1U;
2038     tcram2REG->RAMINTCTRL = 1U;
2039 
2040     \textcolor{comment}{/* Enable writes to ECC RAM, enable ECC error response */}
2041     tcram1REG->RAMCTRL = 0x0005010AU;
2042     tcram2REG->RAMCTRL = 0x0005010AU;
2043 
2044     \textcolor{comment}{/* Force a single bit error in both the banks */}
2045     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
2046     tcramA1bitError ^= 1U;
2047     tcramB1bitError ^= 1U;
2048     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
2049 
2050     \textcolor{comment}{/* Read the corrupted data to generate single bit error */}
2051     ramread = tcramA1bit;
2052     ramread = tcramB1bit;
2053 
2054     \textcolor{comment}{/* Check for error status */}
2055     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x1U;
2056     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x1U;
2057     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2058     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2059     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) || (tcram2ErrStat == 0U))
2060     \{
2061         \textcolor{comment}{/* TCRAM module does not reflect 1-bit error reported by CPU */}
2062         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMECC\_FAIL1);
2063     \}
2064     \textcolor{keywordflow}{else}
2065     \{
2066         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x14000000U) != 0x14000000U)
2067         \{
2068             \textcolor{comment}{/* TCRAM 1-bit error not flagged in ESM */}
2069             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMECC\_FAIL2);
2070         \}
2071         \textcolor{keywordflow}{else}
2072         \{
2073             \textcolor{comment}{/* Clear single bit error flag in TCRAM module */}
2074             tcram1REG->RAMERRSTATUS = 0x1U;
2075             tcram2REG->RAMERRSTATUS = 0x1U;
2076 
2077             \textcolor{comment}{/* Clear ESM status */}
2078             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x14000000U;
2079         \}
2080     \}
2081 
2082     \textcolor{comment}{/* Force a double bit error in both the banks */}
2083     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
2084     tcramA2bitError ^= 3U;
2085     tcramB2bitError ^= 3U;
2086     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
2087 
2088     \textcolor{comment}{/* Read the corrupted data to generate double bit error */}
2089     ramread = tcramA2bit;
2090     ramread = tcramB2bit;
2091 
2092     regread = tcram1REG->RAMUERRADDR;
2093     regread = tcram2REG->RAMUERRADDR;
2094 
2095     \textcolor{comment}{/* disable writes to ECC RAM */}
2096     tcram1REG->RAMCTRL = 0x0005000AU;
2097     tcram2REG->RAMCTRL = 0x0005000AU;
2098 
2099     \textcolor{comment}{/* Compute correct ECC */}
2100     tcramA1bit = tcramA1\_bk;
2101     tcramB1bit = tcramB1\_bk;
2102     tcramA2bit = tcramA2\_bk;
2103     tcramB2bit = tcramB2\_bk;
2104 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a7e5bbec947e5db02df2bda4ba2230677}\label{sys__selftest_8c_a7e5bbec947e5db02df2bda4ba2230677}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!check\+R\+A\+M\+U\+E\+R\+R\+Test@{check\+R\+A\+M\+U\+E\+R\+R\+Test}}
\index{check\+R\+A\+M\+U\+E\+R\+R\+Test@{check\+R\+A\+M\+U\+E\+R\+R\+Test}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{check\+R\+A\+M\+U\+E\+R\+R\+Test()}{checkRAMUERRTest()}}
{\footnotesize\ttfamily void check\+R\+A\+M\+U\+E\+R\+R\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Run R\+AM test. 

This function runs R\+AM test to test the redundant address decode and compare logic. 

Definition at line 2469 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2470 \{
2471     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
2472 
2473     \textcolor{comment}{/* Trigger equality check */}
2474     tcram1REG->RAMTEST = 0x018AU;
2475     tcram2REG->RAMTEST = 0x018AU;
2476 
2477     \textcolor{comment}{/* Wait till test is completed */}
2478     \textcolor{keywordflow}{while}(tcram1REG->RAMTEST != 0x008AU)
2479     \{
2480     \} \textcolor{comment}{/* Wait */}
2481     \textcolor{keywordflow}{while}(tcram2REG->RAMTEST != 0x008AU)
2482     \{
2483     \} \textcolor{comment}{/* Wait */}
2484 
2485     \textcolor{comment}{/* Check for error status */}
2486     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x10U;
2487     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x10U;
2488     \textcolor{keywordflow}{if}((tcram1ErrStat == 0x10U) || (tcram2ErrStat == 0x10U))
2489     \{
2490         \textcolor{comment}{/* test failed */}
2491         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMUERRTEST\_FAIL1);
2492     \}
2493 
2494     \textcolor{comment}{/* Trigger inequality check */}
2495     tcram1REG->RAMTEST = 0x014AU;
2496     tcram2REG->RAMTEST = 0x014AU;
2497 
2498     \textcolor{comment}{/* Wait till test is completed */}
2499     \textcolor{keywordflow}{while}(tcram1REG->RAMTEST != 0x004AU)
2500     \{
2501     \}\textcolor{comment}{/* Wait */}
2502     \textcolor{keywordflow}{while}(tcram2REG->RAMTEST != 0x004AU)
2503     \{
2504     \}\textcolor{comment}{/* Wait */}
2505 
2506     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x10U;
2507     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x10U;
2508     \textcolor{keywordflow}{if}((tcram1ErrStat == 0x10U) || (tcram2ErrStat == 0x10U))
2509     \{
2510         \textcolor{comment}{/* test failed */}
2511         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMUERRTEST\_FAIL2);
2512     \}
2513     \textcolor{keywordflow}{else}
2514     \{
2515         tcram1REG->RAMERRSTATUS = 0x4U;
2516         tcram2REG->RAMERRSTATUS = 0x4U;
2517 
2518         \textcolor{comment}{/* Clear ESM flag */}
2519         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] = 0x140U;
2520         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SSR2 = 0x140U;
2521         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
2522     \}
2523 
2524     \textcolor{comment}{/* Disable RAM test mode */}
2525     tcram1REG->RAMTEST = 0x5U;
2526     tcram2REG->RAMTEST = 0x5U;
2527 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a27cee1191b0027e90cbb9c66983596b9}\label{sys__selftest_8c_a27cee1191b0027e90cbb9c66983596b9}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!cpu\+Self\+Test@{cpu\+Self\+Test}}
\index{cpu\+Self\+Test@{cpu\+Self\+Test}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{cpu\+Self\+Test()}{cpuSelfTest()}}
{\footnotesize\ttfamily void cpu\+Self\+Test (\begin{DoxyParamCaption}\item[{uint32}]{no\+\_\+of\+\_\+intervals,  }\item[{uint32}]{max\+\_\+timeout,  }\item[{boolean}]{restart\+\_\+test }\end{DoxyParamCaption})}



C\+PU self test Driver. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em no\+\_\+of\+\_\+intervals} & -\/ Number of Test Intervals to be \\
\hline
\mbox{\tt in}  & {\em max\+\_\+timeout} & -\/ Maximum Timeout to complete selected test Intervals \\
\hline
\mbox{\tt in}  & {\em restart\+\_\+test} & -\/ Restart the test from Interval 0 or Continue from where it stopped.\\
\hline
\end{DoxyParams}
This function is called to perform C\+PU self test using S\+TC module. 

Definition at line 266 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
267 \{
268     \textcolor{keyword}{volatile} uint32 i = 0U;
269 
270 \textcolor{comment}{/* USER CODE BEGIN (11) */}
271 \textcolor{comment}{/* USER CODE END */}
272 
273     \textcolor{comment}{/* Run specified no of test intervals starting from interval 0 */}
274     \textcolor{comment}{/* Start test from interval 0 or continue the test. */}
275     stcREG->STCGCR0 = no\_of\_intervals << 16U;
276     \textcolor{keywordflow}{if}(restart\_test)
277     \{
278         stcREG->STCGCR0 |= 0x00000001U;
279     \}
280 
281     \textcolor{comment}{/* Configure Maximum time-out period */}
282     stcREG->STCTPR = max\_timeout;
283 
284     \textcolor{comment}{/* wait for 16 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
285     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
286     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
287     \textcolor{keywordflow}{for} (i=0U; i<(16U + (16U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
288 
289     \textcolor{comment}{/* Enable self-test */}
290     stcREG->STCGCR1 = 0xAU;
291 
292 \textcolor{comment}{/* USER CODE BEGIN (12) */}
293 \textcolor{comment}{/* USER CODE END */}
294     \textcolor{comment}{/* Idle the CPU so that the self-test can start */}
295 
296     \mbox{\hyperlink{sys__core_8h_a9ac3ba78e1c8af4d0b6a5381b11858b2}{\_gotoCPUIdle\_}}();
297 
298 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a932e8fff5749ae8038f0fbbe9029ec44}\label{sys__selftest_8c_a932e8fff5749ae8038f0fbbe9029ec44}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!cpu\+Self\+Test\+Fail@{cpu\+Self\+Test\+Fail}}
\index{cpu\+Self\+Test\+Fail@{cpu\+Self\+Test\+Fail}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{cpu\+Self\+Test\+Fail()}{cpuSelfTestFail()}}
{\footnotesize\ttfamily void cpu\+Self\+Test\+Fail (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



C\+PU Self test check fail service routine. 

This function is called if C\+PU Self test check fail. 

Definition at line 1159 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1160 \{
1161 \textcolor{comment}{/* USER CODE BEGIN (46) */}
1162 \textcolor{comment}{/* USER CODE END */}
1163     \textcolor{comment}{/* CPU self-test has failed.}
1164 \textcolor{comment}{     * CPU operation is not reliable.}
1165 \textcolor{comment}{     */}
1166 \textcolor{comment}{/* USER CODE BEGIN (47) */}
1167 \textcolor{comment}{/* USER CODE END */}
1168     \textcolor{comment}{/*SAFETYMCUSW 5 C MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the user
       codes above and below" */}
1169     \textcolor{comment}{/*SAFETYMCUSW 26 S MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1170     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1171     \textcolor{keywordflow}{for}(;;)
1172     \{
1173     \}\textcolor{comment}{/* Wait */}
1174 \textcolor{comment}{/* USER CODE BEGIN (48) */}
1175 \textcolor{comment}{/* USER CODE END */}
1176 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a58597c65615a9a0f05d48135ad48c0d6}\label{sys__selftest_8c_a58597c65615a9a0f05d48135ad48c0d6}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!custom\+\_\+dabort@{custom\+\_\+dabort}}
\index{custom\+\_\+dabort@{custom\+\_\+dabort}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{custom\+\_\+dabort()}{custom\_dabort()}}
{\footnotesize\ttfamily void custom\+\_\+dabort (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Custom Data abort routine for the application. 

Custom Data abort routine for the application. 

Definition at line 1116 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1117 \{
1118     \textcolor{comment}{/* Need custom data abort handler here.}
1119 \textcolor{comment}{     * This data abort is not caused due to diagnostic checks of flash and TCRAM ECC logic.}
1120 \textcolor{comment}{     */}
1121 \textcolor{comment}{/* USER CODE BEGIN (42) */}
1122 \textcolor{comment}{/* USER CODE END */}
1123 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a15b66d583493adf7dc0ce8e3a89f00f5}\label{sys__selftest_8c_a15b66d583493adf7dc0ce8e3a89f00f5}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!disable\+Parity@{disable\+Parity}}
\index{disable\+Parity@{disable\+Parity}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{disable\+Parity()}{disableParity()}}
{\footnotesize\ttfamily void disable\+Parity (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Disable peripheral R\+AM parity. 

This function disables R\+AM parity for all peripherals for which R\+AM parity check is enabled. This function is called after memory\+Init in the startup 

Definition at line 2972 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2973 \{
2974     DMA\_PARCR = 0x5U;                      \textcolor{comment}{/* Disable DMA RAM parity */}
2975     VIM\_PARCTL = 0x5U;                     \textcolor{comment}{/* Disable VIM RAM parity */}
2976     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = ((uint32)0x5U << 10U) | 1U;    \textcolor{comment}{/* Disable CAN1 RAM parity */}
2977     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = ((uint32)0x5U << 10U) | 1U;    \textcolor{comment}{/* Disable CAN2 RAM parity */}
2978     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = ((uint32)0x5U << 10U) | 1U;    \textcolor{comment}{/* Disable CAN3 RAM parity */}
2979     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x5U;                 \textcolor{comment}{/* Disable ADC1 RAM parity */}
2980     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x5U;                 \textcolor{comment}{/* Disable ADC2 RAM parity */}
2981     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x5U;                   \textcolor{comment}{/* Disable HET1 RAM parity */}
2982     htuREG1->PCR = 0x5U;                   \textcolor{comment}{/* Disable HTU1 RAM parity */}
2983     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x5U;                   \textcolor{comment}{/* Disable HET2 RAM parity */}
2984     htuREG2->PCR = 0x5U;                   \textcolor{comment}{/* Disable HTU2 RAM parity */}
2985 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_add4aed7c0b3711f72c9228a92effa518}\label{sys__selftest_8c_add4aed7c0b3711f72c9228a92effa518}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!dma\+Parity\+Check@{dma\+Parity\+Check}}
\index{dma\+Parity\+Check@{dma\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{dma\+Parity\+Check()}{dmaParityCheck()}}
{\footnotesize\ttfamily void dma\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check D\+MA control packet R\+AM parity error detection and signaling mechanism. 

Routine to check D\+MA control packet R\+AM parity error detection and signaling mechanism 

Definition at line 1244 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1245 \{
1246     \textcolor{keyword}{volatile} uint32 dmaread = 0U;
1247     uint32 dmaparcr\_bk = DMA\_PARCR;
1248 
1249 \textcolor{comment}{/* USER CODE BEGIN (51) */}
1250 \textcolor{comment}{/* USER CODE END */}
1251 
1252     \textcolor{comment}{/* Enable parity checking and parity test mode */}
1253     DMA\_PARCR = 0x0000010AU;
1254 
1255     \textcolor{comment}{/* Flip a bit in DMA RAM parity location */}
1256     DMARAMPARLOC ^= 0x1U;
1257 
1258     \textcolor{comment}{/* Disable parity test mode */}
1259     DMA\_PARCR = 0x0000000AU;
1260 
1261     \textcolor{comment}{/* Cause parity error */}
1262     dmaread = DMARAMLOC;
1263 
1264     \textcolor{comment}{/* Check if ESM group1 channel 3 is flagged */}
1265     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x8U) == 0U)
1266     \{
1267         \textcolor{comment}{/* DMA RAM parity error was not flagged to ESM. */}
1268         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(DMAPARITYCHECK\_FAIL1);
1269     \}
1270     \textcolor{keywordflow}{else}
1271     \{
1272         \textcolor{comment}{/* clear DMA parity error flag in DMA */}
1273         DMA\_PARADDR = 0x01000000U;
1274 
1275         \textcolor{comment}{/* clear ESM group1 channel 3 flag */}
1276         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x8U;
1277 
1278         \textcolor{comment}{/* Enable parity checking and parity test mode */}
1279         DMA\_PARCR = 0x0000010AU;
1280 
1281         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1282         DMARAMPARLOC ^= 0x1U;
1283     \}
1284 
1285     \textcolor{comment}{/* Restrore Parity Control register */}
1286     DMA\_PARCR = dmaparcr\_bk;
1287 
1288 \textcolor{comment}{/* USER CODE BEGIN (52) */}
1289 \textcolor{comment}{/* USER CODE END */}
1290 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a646eb27315f3ce47edde97c563389f76}\label{sys__selftest_8c_a646eb27315f3ce47edde97c563389f76}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!efc\+Check@{efc\+Check}}
\index{efc\+Check@{efc\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{efc\+Check()}{efcCheck()}}
{\footnotesize\ttfamily uint32 efc\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



E\+F\+U\+SE module self check Driver. 

\begin{DoxyReturn}{Returns}
Returns 0 if no error was detected during autoload and Stuck At Zero Test passed 1 if no error was detected during autoload but Stuck At Zero Test failed 2 if there was a single-\/bit error detected during autoload 3 if some other error occurred during autoload
\end{DoxyReturn}
This function self checks the E\+F\+U\+SE module. 

Definition at line 582 of file sys\+\_\+selftest.\+c.



Referenced by system\+Init().


\begin{DoxyCode}
583 \{
584     uint32 efcStatus = 0U;
585     uint32 status;
586     
587 \textcolor{comment}{/* USER CODE BEGIN (27) */}
588 \textcolor{comment}{/* USER CODE END */}
589 
590     \textcolor{comment}{/* read the EFC Error Status Register */}
591     efcStatus = efcREG->ERROR;
592 
593 \textcolor{comment}{/* USER CODE BEGIN (28) */}
594 \textcolor{comment}{/* USER CODE END */}
595 
596     \textcolor{keywordflow}{if} (efcStatus == 0x0U)
597     \{
598         \textcolor{comment}{/* run stuck-at-zero test and check if it passed */}
599         \textcolor{keywordflow}{if} (\mbox{\hyperlink{sys__selftest_8c_a9973f032c29389602b684d30ea390fad}{efcStuckZeroTest}}()== \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}})
600         \{
601             \textcolor{comment}{/* start EFC ECC logic self-test */}
602             \mbox{\hyperlink{sys__selftest_8c_afd6cec31a44e7c8e325a744e9bcbf601}{efcSelfTest}}();
603             status = 0U;
604         \}
605         \textcolor{keywordflow}{else}
606         \{
607             \textcolor{comment}{/* EFC output is stuck-at-zero, device operation unreliable */}
608             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(EFCCHECK\_FAIL1);
609             status = 1U;
610         \}
611     \}
612     \textcolor{comment}{/* EFC Error Register is not zero */}
613     \textcolor{keywordflow}{else}
614     \{
615         \textcolor{comment}{/* one-bit error detected during autoload */}
616         \textcolor{keywordflow}{if} (efcStatus == 0x15U)
617         \{
618             \textcolor{comment}{/* start EFC ECC logic self-test */}
619             \mbox{\hyperlink{sys__selftest_8c_afd6cec31a44e7c8e325a744e9bcbf601}{efcSelfTest}}();
620             status = 2U;
621         \}
622         \textcolor{keywordflow}{else}
623         \{
624             \textcolor{comment}{/* Some other EFC error was detected */}
625             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(EFCCHECK\_FAIL1);
626             status = 3U;
627         \}
628     \}
629     \textcolor{keywordflow}{return} status;
630 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ac76ed167d7b4b27eedea0eb37de6acc2}\label{sys__selftest_8c_ac76ed167d7b4b27eedea0eb37de6acc2}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!efc\+Get\+Config\+Value@{efc\+Get\+Config\+Value}}
\index{efc\+Get\+Config\+Value@{efc\+Get\+Config\+Value}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{efc\+Get\+Config\+Value()}{efcGetConfigValue()}}
{\footnotesize\ttfamily void efc\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structefc__config__reg}{efc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2725 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2726 \{
2727     \textcolor{keywordflow}{if} (type == InitialValue)
2728     \{
2729         config\_reg->CONFIG\_BOUNDARY = EFC\_BOUNDARY\_CONFIGVALUE;
2730         config\_reg->CONFIG\_PINS = EFC\_PINS\_CONFIGVALUE;
2731         config\_reg->CONFIG\_SELFTESTCYCLES = EFC\_SELFTESTCYCLES\_CONFIGVALUE;
2732         config\_reg->CONFIG\_SELFTESTSIGN = EFC\_SELFTESTSIGN\_CONFIGVALUE;
2733     \}
2734     \textcolor{keywordflow}{else}
2735     \{
2736     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2737         config\_reg->CONFIG\_BOUNDARY = efcREG->BOUNDARY;
2738         config\_reg->CONFIG\_PINS = efcREG->PINS;
2739         config\_reg->CONFIG\_SELFTESTCYCLES = efcREG->SELF\_TEST\_CYCLES;
2740         config\_reg->CONFIG\_SELFTESTSIGN = efcREG->SELF\_TEST\_SIGN;
2741     \}
2742 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_afd6cec31a44e7c8e325a744e9bcbf601}\label{sys__selftest_8c_afd6cec31a44e7c8e325a744e9bcbf601}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!efc\+Self\+Test@{efc\+Self\+Test}}
\index{efc\+Self\+Test@{efc\+Self\+Test}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{efc\+Self\+Test()}{efcSelfTest()}}
{\footnotesize\ttfamily void efc\+Self\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



E\+F\+U\+SE module self check Driver. 

This function self checks the E\+F\+S\+UE module. 

Definition at line 697 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
698 \{
699 \textcolor{comment}{/* USER CODE BEGIN (30) */}
700 \textcolor{comment}{/* USER CODE END */}
701     \textcolor{comment}{/* configure self-test cycles */}
702     efcREG->SELF\_TEST\_CYCLES = 0x258U;
703 
704     \textcolor{comment}{/* configure self-test signature */}
705     efcREG->SELF\_TEST\_SIGN = 0x5362F97FU;
706 
707     \textcolor{comment}{/* configure boundary register to start ECC self-test */}
708     efcREG->BOUNDARY = 0x0000200FU;
709 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a9973f032c29389602b684d30ea390fad}\label{sys__selftest_8c_a9973f032c29389602b684d30ea390fad}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!efc\+Stuck\+Zero\+Test@{efc\+Stuck\+Zero\+Test}}
\index{efc\+Stuck\+Zero\+Test@{efc\+Stuck\+Zero\+Test}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{efc\+Stuck\+Zero\+Test()}{efcStuckZeroTest()}}
{\footnotesize\ttfamily boolean efc\+Stuck\+Zero\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Checks to see if the E\+F\+U\+SE Stuck at zero test is completed successfully. 

\begin{DoxyReturn}{Returns}
1 if E\+F\+U\+SE Stuck at zero test completed, otherwise 0.
\end{DoxyReturn}
Checks to see if the E\+F\+U\+SE Stuck at zero test is completed successfully. 

Definition at line 641 of file sys\+\_\+selftest.\+c.



References F\+A\+L\+SE.


\begin{DoxyCode}
642 \{
643 \textcolor{comment}{/* USER CODE BEGIN (29) */}
644 \textcolor{comment}{/* USER CODE END */}
645 
646     uint32 ESM\_ESTATUS4, ESM\_ESTATUS1;
647 
648     \textcolor{keywordtype}{boolean} result = \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
649     uint32 error\_checks = EFC\_INSTRUCTION\_INFO\_EN  |
650                                   EFC\_INSTRUCTION\_ERROR\_EN |
651                                   EFC\_AUTOLOAD\_ERROR\_EN      |
652                                   EFC\_SELF\_TEST\_ERROR\_EN   ;
653 
654     \textcolor{comment}{/* configure the output enable for auto load error , instruction info,}
655 \textcolor{comment}{         instruction error, and self test error using boundary register}
656 \textcolor{comment}{         and drive values one across all the errors */}
657     efcREG->BOUNDARY = ((uint32)OUTPUT\_ENABLE | error\_checks);
658 
659     \textcolor{comment}{/* Read from the pin register. This register holds the current values}
660 \textcolor{comment}{         of above errors. This value should be 0x5c00.If not at least one of}
661 \textcolor{comment}{         the above errors is stuck at 0. */}
662     \textcolor{keywordflow}{if} ((efcREG->PINS & 0x5C00U) == 0x5C00U)
663     \{
664         ESM\_ESTATUS4 = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U];
665         ESM\_ESTATUS1 = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U];
666         \textcolor{comment}{/* check if the ESM group1 channel 41 is set and group3 channel 1 is set */}
667         \textcolor{keywordflow}{if} (((ESM\_ESTATUS4 & 0x200U) == 0x200U) && ((ESM\_ESTATUS1 & 0x2U) == 0x2U))
668         \{
669            \textcolor{comment}{/* stuck-at-zero test passed */}
670            result = \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}};
671         \}
672     \}
673 
674     \textcolor{comment}{/* put the pins back low */}
675     efcREG->BOUNDARY = OUTPUT\_ENABLE;
676 
677     \textcolor{comment}{/* clear group1 flag */}
678     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x200U;
679 
680     \textcolor{comment}{/* clear group3 flag */}
681     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U] = 0x2U;
682 
683     \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
684     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
685 
686     \textcolor{keywordflow}{return} result;
687 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_af9ecd48548d7a3d98d5dcc44d1e7ca51}\label{sys__selftest_8c_af9ecd48548d7a3d98d5dcc44d1e7ca51}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!enable\+Parity@{enable\+Parity}}
\index{enable\+Parity@{enable\+Parity}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{enable\+Parity()}{enableParity()}}
{\footnotesize\ttfamily void enable\+Parity (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Enable peripheral R\+AM parity. 

This function enables R\+AM parity for all peripherals for which R\+AM parity check is enabled. This function is called before memory\+Init in the startup 

Definition at line 2949 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2950 \{
2951     DMA\_PARCR = 0xAU;                      \textcolor{comment}{/* Enable DMA RAM parity */}
2952     VIM\_PARCTL = 0xAU;                     \textcolor{comment}{/* Enable VIM RAM parity */}
2953     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = ((uint32)0xAU << 10U) | 1U;    \textcolor{comment}{/* Enable CAN1 RAM parity */}
2954     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = ((uint32)0xAU << 10U) | 1U;    \textcolor{comment}{/* Enable CAN2 RAM parity */}
2955     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = ((uint32)0xAU << 10U) | 1U;    \textcolor{comment}{/* Enable CAN3 RAM parity */}
2956     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0xAU;                 \textcolor{comment}{/* Enable ADC1 RAM parity */}
2957     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0xAU;                 \textcolor{comment}{/* Enable ADC2 RAM parity */}
2958     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0xAU;                   \textcolor{comment}{/* Enable HET1 RAM parity */}
2959     htuREG1->PCR = 0xAU;                   \textcolor{comment}{/* Enable HTU1 RAM parity */}
2960     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0xAU;                   \textcolor{comment}{/* Enable HET2 RAM parity */}
2961     htuREG2->PCR = 0xAU;                   \textcolor{comment}{/* Enable HTU2 RAM parity */}
2962 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a1f3b71a00b6347cb5f7f6eb922c36c9e}\label{sys__selftest_8c_a1f3b71a00b6347cb5f7f6eb922c36c9e}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4@{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4}}
\index{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4@{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4()}{errata\_PBIST\_4()}}
{\footnotesize\ttfamily void errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4 (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Workaround for the Errata P\+B\+I\+ST\#4. 

This function is workaround for Errata P\+B\+I\+ST\#4. This function is designed to initialize the R\+O\+Ms using the P\+B\+I\+ST controller. The C\+PU will configure the P\+B\+I\+ST controller to test the P\+B\+I\+ST R\+OM and S\+TC R\+OM. This function should be called at startup after system init before using the R\+O\+Ms.

\begin{DoxyNote}{Note}
\+: This Function uses register\textquotesingle{}s which are not exposed to users through T\+RM , to run custom algorithm. User can use this function as Black box. 
\end{DoxyNote}


Definition at line 2785 of file sys\+\_\+selftest.\+c.



References \+\_\+pmu\+Enable\+Counters\+Global\+\_\+(), \+\_\+pmu\+Get\+Cycle\+Count\+\_\+(), \+\_\+pmu\+Reset\+Counters\+\_\+(), \+\_\+pmu\+Start\+Counters\+\_\+(), \+\_\+pmu\+Stop\+Counters\+\_\+(), and pmu\+C\+Y\+C\+L\+E\+\_\+\+C\+O\+U\+N\+T\+ER.


\begin{DoxyCode}
2786 \{
2787     \textcolor{keyword}{volatile} uint32 i = 0U;
2788     uint8 ROM\_count;
2789     sint32 PBIST\_wait\_done\_loop;
2790     uint32 pmuCalibration, pmuCount;
2791 
2792     \textcolor{comment}{/* PMU calibration */}
2793     \mbox{\hyperlink{sys__pmu_8h_a6bcb569866117b8d50c05b8d992cb3e0}{\_pmuEnableCountersGlobal\_}}();
2794     \mbox{\hyperlink{sys__pmu_8h_a21f3fc4ef80d58b22d0545a5c08f230e}{\_pmuResetCounters\_}}();
2795     \mbox{\hyperlink{sys__pmu_8h_a05119721bf5533e9271717127c18c22c}{\_pmuStartCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2796     \mbox{\hyperlink{sys__pmu_8h_abab4f00952caa5d6596db0e6de0f445c}{\_pmuStopCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2797     pmuCalibration=\mbox{\hyperlink{sys__pmu_8h_afd1c5a6e4a8806b15d4e8f72bd33fa16}{\_pmuGetCycleCount\_}}();
2798 
2799     \textcolor{comment}{/* ROM\_init Setup using special reserved registers as part of errata fix */}
2800     \textcolor{comment}{/* (Only to be used in this function) */}
2801     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF0400U = 0x0000000AU;
2802     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF040CU = 0x0000EE0AU;
2803 
2804     \textcolor{comment}{/* Loop for Executing PBIST ROM and STC ROM */}
2805     \textcolor{keywordflow}{for} (ROM\_count = 0U; ROM\_count < 2U; ROM\_count++)
2806     \{
2807         PBIST\_wait\_done\_loop = 0;
2808     
2809         \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
2810         pbistREG->PACT = 0x0U;
2811         
2812         \textcolor{comment}{/* PBIST Clocks did not disable */}
2813         \textcolor{keywordflow}{if}(pbistREG->PACT != 0x0U ) 
2814         \{
2815             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL3);
2816         \}
2817         \textcolor{keywordflow}{else}
2818         \{
2819             \textcolor{comment}{/* PBIST ROM clock frequency = HCLK frequency /2 */}
2820             \textcolor{comment}{/* Disable memory self controller */}
2821             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x00000105U;
2822             
2823             \textcolor{comment}{/* Disable Memory Initialization controller */}
2824             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
2825 
2826             \textcolor{comment}{/* Enable memory self controller */}
2827             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x0000010AU;                               
2828 
2829             \textcolor{comment}{/* Clear PBIST Done */}
2830             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT = 0x1U;
2831             
2832             \textcolor{comment}{/* Enable PBIST controller */}
2833             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA = 0x1U;
2834 
2835             \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
2836             \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */} 
2837             \textcolor{comment}{/* wait for 32 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
2838             \textcolor{keywordflow}{for} (i=0U; i<(32U + (32U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
2839 
2840             \textcolor{comment}{/* Enable PBIST clocks and ROM clock */}
2841             pbistREG->PACT = 0x3U;
2842 
2843             \textcolor{comment}{/* CPU control of PBIST */}
2844             pbistREG->DLR = 0x10U;
2845 
2846             \textcolor{comment}{/* Load PBIST ALGO to initialize the ROMs */}
2847             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE400U = 0x00000001U;
2848             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE440U = 0x00000025U;
2849             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE404U = 0x62400001U;
2850             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE444U = 0x00000004U;
2851             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE408U = 0x00068003U;
2852             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE448U = 0x00000000U;
2853             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE40CU = 0x00000004U;
2854             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE44CU = 0x00006860U;
2855             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE410U = 0x00000000U;
2856             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE450U = 0x00000001U;
2857             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE540U = 0x000003E8U;
2858             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE550U = 0x00000001U;
2859             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE530U = 0x00000000U;
2860             
2861             \textcolor{comment}{/* SELECT ROM */}
2862             \textcolor{keywordflow}{if} (ROM\_count == 1U)
2863             \{   
2864                 \textcolor{comment}{/* SELECT PBIST ROM */}          
2865                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE520U = 0x00000002U;
2866                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE524U = 0x00000000U;
2867                 pbistREG->RAMT                  = 0x01002008U;
2868             \} 
2869             \textcolor{keywordflow}{else}
2870             \{               
2871                 \textcolor{comment}{/* SELECT STC ROM */}    
2872                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE520U = 0xFFF0007CU;
2873                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE524U = 0x0A63FFFFU;
2874                 pbistREG->RAMT                  = 0x02002008U;
2875             \}
2876 
2877             \textcolor{comment}{/*  Setup using special reserved registers as part of errata fix */}
2878             \textcolor{comment}{/*      (Only to be used in this function) */}
2879             pbistREG->rsvd1[4U]    = 1U;
2880             pbistREG->rsvd1[0U]    = 3U;
2881 
2882             \textcolor{comment}{/* Start PMU counter */}
2883             \mbox{\hyperlink{sys__pmu_8h_a21f3fc4ef80d58b22d0545a5c08f230e}{\_pmuResetCounters\_}}();
2884             \mbox{\hyperlink{sys__pmu_8h_a05119721bf5533e9271717127c18c22c}{\_pmuStartCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2885 
2886             \textcolor{comment}{/* PBIST\_RUN */}
2887             pbistREG->rsvd1[1U]    = 1U;
2888 
2889             \textcolor{comment}{/* wait until memory self-test done is indicated */}
2890             \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2891             \textcolor{keywordflow}{while} ((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x1U) != 0x1U) 
2892             \{
2893             \}\textcolor{comment}{/* Wait */}
2894 
2895             \textcolor{comment}{/* Stop PMU counter */}
2896             \mbox{\hyperlink{sys__pmu_8h_abab4f00952caa5d6596db0e6de0f445c}{\_pmuStopCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2897             
2898             \textcolor{comment}{/* Get CPU cycle count */}
2899             pmuCount =\mbox{\hyperlink{sys__pmu_8h_afd1c5a6e4a8806b15d4e8f72bd33fa16}{\_pmuGetCycleCount\_}}();
2900             
2901             \textcolor{comment}{/* Calculate PBIST test complete time in ROM Clock */}
2902             \textcolor{comment}{/* 2 - Divide value ( Default is 2 in HALCoGen) */}
2903             \textcolor{comment}{/* 1000 = 0x3E8 - Test Loop count in ROM Algorithm */}
2904             pmuCount = pmuCount - pmuCalibration;
2905             PBIST\_wait\_done\_loop = ((sint32)pmuCount/2) - 1000;
2906 
2907             \textcolor{comment}{/* Check PBIST status results (Address, Status, Count, etc...) */}
2908             \textcolor{keywordflow}{if} ((pbistREG->FSRA0 | pbistREG->FSRA1 | pbistREG->FSRDL0 | pbistREG->rsvd3 |
2909                  pbistREG->FSRDL1 | pbistREG->rsvd4[0U] | pbistREG->rsvd4[1U]) != 0U)
2910             \{
2911                 \textcolor{comment}{/* PBIST Failure for the Algorithm chosen above */}
2912                 \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL1);
2913             \}
2914 
2915             \textcolor{comment}{/* Check that the algorithm executed in the expected amount of time. */}
2916             \textcolor{comment}{/* This time is dependent on the ROMCLKDIV selected */}
2917             \textcolor{keywordflow}{if} ((PBIST\_wait\_done\_loop <= 20) || (PBIST\_wait\_done\_loop >= 200) )
2918             \{
2919                 \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL2);
2920             \}
2921 
2922             \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
2923             pbistREG->PACT = 0x0U;
2924 
2925             \textcolor{comment}{/* Disable PBIST */}
2926             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR &= 0xFFFFFFF0U;
2927             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR |= 0x5U;
2928         \}
2929     \} \textcolor{comment}{/* ROM Loop */}
2930 
2931     \textcolor{comment}{/* ROM restore default setup */}
2932     \textcolor{comment}{/* (must be completed before continuing) */}
2933     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF040CU = 0x0000AA0AU;
2934     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF040CU = 0x0000AA05U;
2935     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF0400U = 0x00000005U;
2936 
2937     \mbox{\hyperlink{sys__pmu_8h_a1bdff81dac3f3361f65b97a4197793a2}{\_pmuDisableCountersGlobal\_}}();
2938 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a3248a50d5c0516f336b46aa0114ba9be}\label{sys__selftest_8c_a3248a50d5c0516f336b46aa0114ba9be}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!fmc\+Bus2\+Check@{fmc\+Bus2\+Check}}
\index{fmc\+Bus2\+Check@{fmc\+Bus2\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{fmc\+Bus2\+Check()}{fmcBus2Check()}}
{\footnotesize\ttfamily void fmc\+Bus2\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Self Check Flash Bus2 Interface. 

This function self checks Flash Bus2 Interface 

Definition at line 760 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, flash\+W\+R\+EG, and fmc\+E\+C\+Ccheck().


\begin{DoxyCode}
761 \{
762 \textcolor{comment}{/* USER CODE BEGIN (32) */}
763 \textcolor{comment}{/* USER CODE END */}
764     \textcolor{comment}{/* enable ECC logic inside FMC */}
765     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACCTRL1 = 0x000A060AU;
766 
767     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x40U) == 0x40U)
768     \{
769         \textcolor{comment}{/* a 1-bit error was detected during flash OTP read by flash module}
770 \textcolor{comment}{           run a self-check on ECC logic inside FMC */}
771 
772         \textcolor{comment}{/* clear ESM group1 channel 6 flag */}
773         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40U;
774 
775         \mbox{\hyperlink{sys__selftest_8c_a183a0d9f1300394cff2f8fe0aa034d4b}{fmcECCcheck}}();
776     \}
777 
778     \textcolor{comment}{/* no 2-bit or 1-bit error detected during power-up */}
779     \textcolor{keywordflow}{else}
780     \{
781         \mbox{\hyperlink{sys__selftest_8c_a183a0d9f1300394cff2f8fe0aa034d4b}{fmcECCcheck}}();
782     \}
783 \textcolor{comment}{/* USER CODE BEGIN (33) */}
784 \textcolor{comment}{/* USER CODE END */}
785 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a183a0d9f1300394cff2f8fe0aa034d4b}\label{sys__selftest_8c_a183a0d9f1300394cff2f8fe0aa034d4b}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!fmc\+E\+C\+Ccheck@{fmc\+E\+C\+Ccheck}}
\index{fmc\+E\+C\+Ccheck@{fmc\+E\+C\+Ccheck}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{fmc\+E\+C\+Ccheck()}{fmcECCcheck()}}
{\footnotesize\ttfamily void fmc\+E\+C\+Ccheck (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check Flash E\+CC Single Bit and multi Bit errors detection logic. 

This function Checks Flash E\+CC Single Bit and multi Bit errors detection logic. 

Definition at line 795 of file sys\+\_\+selftest.\+c.



Referenced by fmc\+Bus2\+Check().


\begin{DoxyCode}
796 \{
797     \textcolor{keyword}{volatile} uint32 otpread;
798     \textcolor{keyword}{volatile} uint32 temp;
799 
800 \textcolor{comment}{/* USER CODE BEGIN (34) */}
801 \textcolor{comment}{/* USER CODE END */}
802 
803     \textcolor{comment}{/* read location with deliberate 1-bit error */}
804     otpread = flash1bitError;
805     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x40U) == 0x40U)
806     \{
807         \textcolor{comment}{/* 1-bit failure was indicated and corrected */}
808         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS = 0x00010006U;
809 
810         \textcolor{comment}{/* clear ESM group1 channel 6 flag */}
811         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40U;
812 
813         \textcolor{comment}{/* read location with deliberate 2-bit error */}
814         otpread = flash2bitError;
815         \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U] & 0x80U) == 0x80U)
816         \{
817             \textcolor{comment}{/* 2-bit failure was detected correctly */}
818             temp = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FUNCERRADD;
819             \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS = 0x00020100U;
820 
821             \textcolor{comment}{/* clear ESM group3 channel 7 */}
822             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U] = 0x80U;
823 
824             \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
825             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
826 
827         \}
828         \textcolor{keywordflow}{else}
829         \{
830             \textcolor{comment}{/* ECC logic inside FMC cannot detect 2-bit error */}
831             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(FMCECCCHECK\_FAIL1);
832         \}
833     \}
834     \textcolor{keywordflow}{else}
835     \{
836         \textcolor{comment}{/* ECC logic inside FMC cannot detect 1-bit error */}
837         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(FMCECCCHECK\_FAIL1);
838     \}
839 \textcolor{comment}{/* USER CODE BEGIN (35) */}
840 \textcolor{comment}{/* USER CODE END */}
841 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a66f658578435dc4d3984c76a3d2ed959}\label{sys__selftest_8c_a66f658578435dc4d3984c76a3d2ed959}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!het1\+Parity\+Check@{het1\+Parity\+Check}}
\index{het1\+Parity\+Check@{het1\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{het1\+Parity\+Check()}{het1ParityCheck()}}
{\footnotesize\ttfamily void het1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+E\+T1 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+E\+T1 R\+AM parity error detection and signaling mechanism 

Definition at line 1301 of file sys\+\_\+selftest.\+c.



References het\+R\+E\+G1.


\begin{DoxyCode}
1302 \{
1303     \textcolor{keyword}{volatile} uint32 nhetread = 0U;
1304     uint32 hetpcr\_bk = \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR;
1305 
1306 \textcolor{comment}{/* USER CODE BEGIN (53) */}
1307 \textcolor{comment}{/* USER CODE END */}
1308 
1309     \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1310     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x0000010AU;
1311 
1312     \textcolor{comment}{/* flip parity bit */}
1313     NHET1RAMPARLOC ^= 0x1U;
1314 
1315     \textcolor{comment}{/* Disable TEST mode */}
1316     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x0000000AU;
1317 
1318     \textcolor{comment}{/* read to cause parity error */}
1319     nhetread = NHET1RAMLOC;
1320 
1321     \textcolor{comment}{/* check if ESM group1 channel 7 is flagged */}
1322     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80U) ==0U)
1323     \{
1324         \textcolor{comment}{/* NHET1 RAM parity error was not flagged to ESM. */}
1325         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HET1PARITYCHECK\_FAIL1);
1326     \}
1327     \textcolor{keywordflow}{else}
1328     \{
1329         \textcolor{comment}{/* clear ESM group1 channel 7 flag */}
1330         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80U;
1331 
1332         \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1333         \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x0000010AU;
1334 
1335         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1336         NHET1RAMPARLOC ^= 0x1U;
1337     \}
1338 
1339     \textcolor{comment}{/* Restore Parity comtrol register */}
1340     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = hetpcr\_bk;
1341 
1342 \textcolor{comment}{/* USER CODE BEGIN (54) */}
1343 \textcolor{comment}{/* USER CODE END */}
1344 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a08473bcd7b0a42d859fe99011c4707b7}\label{sys__selftest_8c_a08473bcd7b0a42d859fe99011c4707b7}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!het2\+Parity\+Check@{het2\+Parity\+Check}}
\index{het2\+Parity\+Check@{het2\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{het2\+Parity\+Check()}{het2ParityCheck()}}
{\footnotesize\ttfamily void het2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+E\+T2 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+E\+T2 R\+AM parity error detection and signaling mechanism 

Definition at line 1411 of file sys\+\_\+selftest.\+c.



References het\+R\+E\+G2.


\begin{DoxyCode}
1412 \{
1413     \textcolor{keyword}{volatile} uint32 nhetread = 0U;
1414     uint32 hetpcr\_bk = \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR;
1415     uint32 esmCh7Stat, esmCh34Stat = 0U;
1416     
1417 \textcolor{comment}{/* USER CODE BEGIN (57) */}
1418 \textcolor{comment}{/* USER CODE END */}
1419 
1420     \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1421     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x0000010AU;
1422 
1423     \textcolor{comment}{/* flip parity bit */}
1424     NHET2RAMPARLOC ^= 0x1U;
1425 
1426     \textcolor{comment}{/* Disable TEST mode */}
1427     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x0000000AU;
1428 
1429     \textcolor{comment}{/* read to cause parity error */}
1430     nhetread = NHET2RAMLOC;
1431 
1432     \textcolor{comment}{/* check if ESM group1 channel 7 or 34 (If not reserved) is flagged */}
1433     esmCh7Stat  = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80U;
1434     esmCh34Stat = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x4U;
1435     \textcolor{keywordflow}{if} ((esmCh7Stat == 0U) && (esmCh34Stat ==0U))
1436     \{
1437         \textcolor{comment}{/* NHET2 RAM parity error was not flagged to ESM. */}
1438         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HET2PARITYCHECK\_FAIL1);
1439     \}
1440     \textcolor{keywordflow}{else}
1441     \{
1442         \textcolor{comment}{/* clear ESM group1 channel 7 flag */}
1443         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80U;
1444 
1445         \textcolor{comment}{/* clear ESM group1 channel 34 flag */}
1446         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x4U;
1447 
1448         \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1449         \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x0000010AU;
1450 
1451         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1452         NHET2RAMPARLOC ^= 0x1U;
1453     \}
1454 
1455     \textcolor{comment}{/* Restore parity control register */}
1456     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = hetpcr\_bk;
1457 
1458 \textcolor{comment}{/* USER CODE BEGIN (58) */}
1459 \textcolor{comment}{/* USER CODE END */}
1460 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a5f69665c7b7abb003cfb4a314ce1e943}\label{sys__selftest_8c_a5f69665c7b7abb003cfb4a314ce1e943}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!htu1\+Parity\+Check@{htu1\+Parity\+Check}}
\index{htu1\+Parity\+Check@{htu1\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{htu1\+Parity\+Check()}{htu1ParityCheck()}}
{\footnotesize\ttfamily void htu1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+T\+U1 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+T\+U1 R\+AM parity error detection and signaling mechanism 

Definition at line 1355 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1356 \{
1357     \textcolor{keyword}{volatile} uint32 hturead = 0U;
1358     uint32 htupcr\_bk = htuREG1->PCR;
1359 
1360 \textcolor{comment}{/* USER CODE BEGIN (55) */}
1361 \textcolor{comment}{/* USER CODE END */}
1362 
1363     \textcolor{comment}{/* Enable parity and TEST mode */}
1364     htuREG1->PCR = 0x0000010AU;
1365 
1366     \textcolor{comment}{/* flip parity bit */}
1367     HTU1PARLOC ^= 0x1U;
1368 
1369     \textcolor{comment}{/* Disable parity RAM test mode */}
1370     htuREG1->PCR = 0x0000000AU;
1371 
1372     \textcolor{comment}{/* read to cause parity error */}
1373     hturead = HTU1RAMLOC;
1374 
1375     \textcolor{comment}{/* check if ESM group1 channel 8 is flagged */}
1376     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x100U) == 0U)
1377     \{
1378         \textcolor{comment}{/* HTU1 RAM parity error was not flagged to ESM. */}
1379         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HTU1PARITYCHECK\_FAIL1);
1380     \}
1381     \textcolor{keywordflow}{else}
1382     \{
1383         \textcolor{comment}{/* Clear HTU parity error flag */}
1384         htuREG1->PAR = 0x00010000U;
1385         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x100U;
1386 
1387         \textcolor{comment}{/* Enable parity and TEST mode */}
1388         htuREG1->PCR = 0x0000010AU;
1389 
1390         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1391         HTU1PARLOC ^= 0x1U;
1392     \}
1393 
1394     \textcolor{comment}{/* Restore Parity control register */}
1395     htuREG1->PCR = htupcr\_bk;
1396 
1397 \textcolor{comment}{/* USER CODE BEGIN (56) */}
1398 \textcolor{comment}{/* USER CODE END */}
1399 
1400 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_aaf183a3ffe2ce7257d5fbceb4cca69f0}\label{sys__selftest_8c_aaf183a3ffe2ce7257d5fbceb4cca69f0}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!htu2\+Parity\+Check@{htu2\+Parity\+Check}}
\index{htu2\+Parity\+Check@{htu2\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{htu2\+Parity\+Check()}{htu2ParityCheck()}}
{\footnotesize\ttfamily void htu2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+T\+U2 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+T\+U2 R\+AM parity error detection and signaling mechanism 

Definition at line 1471 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1472 \{
1473     \textcolor{keyword}{volatile} uint32 hturead = 0U;
1474     uint32 htupcr\_bk = htuREG2->PCR;
1475 
1476 \textcolor{comment}{/* USER CODE BEGIN (59) */}
1477 \textcolor{comment}{/* USER CODE END */}
1478 
1479     \textcolor{comment}{/* Enable parity and TEST mode */}
1480     htuREG2->PCR = 0x0000010AU;
1481 
1482     \textcolor{comment}{/* flip parity bit */}
1483     HTU2PARLOC ^= 0x1U;
1484 
1485     \textcolor{comment}{/* Disable parity RAM test mode */}
1486     htuREG2->PCR = 0x0000000AU;
1487 
1488     \textcolor{comment}{/* read to cause parity error */}
1489     hturead = HTU2RAMLOC;
1490 
1491     \textcolor{comment}{/* check if ESM group1 channel 8 is flagged */}
1492     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x100U) == 0U)
1493     \{
1494         \textcolor{comment}{/* HTU2 RAM parity error was not flagged to ESM. */}
1495         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HTU2PARITYCHECK\_FAIL1);
1496     \}
1497     \textcolor{keywordflow}{else}
1498     \{
1499         \textcolor{comment}{/* Clear HTU parity error flag */}
1500         htuREG2->PAR = 0x00010000U;
1501         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x100U;
1502 
1503         \textcolor{comment}{/* Enable parity and TEST mode */}
1504         htuREG2->PCR = 0x0000010AU;
1505 
1506         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1507         HTU2PARLOC ^= 0x1U;
1508     \}
1509 
1510     \textcolor{comment}{/* Restore parity control register*/}
1511     htuREG2->PCR = htupcr\_bk;
1512 
1513 \textcolor{comment}{/* USER CODE BEGIN (60) */}
1514 \textcolor{comment}{/* USER CODE END */}
1515 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a3184dfe0846903e1111348942160dfe7}\label{sys__selftest_8c_a3184dfe0846903e1111348942160dfe7}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!memory\+Init@{memory\+Init}}
\index{memory\+Init@{memory\+Init}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{memory\+Init()}{memoryInit()}}
{\footnotesize\ttfamily void memory\+Init (\begin{DoxyParamCaption}\item[{uint32}]{ram }\end{DoxyParamCaption})}



Memory Initialization Driver. 

This function is called to perform Memory initialization of selected R\+AM\textquotesingle{}s. 

Definition at line 184 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G1.


\begin{DoxyCode}
185 \{
186 \textcolor{comment}{/* USER CODE BEGIN (6) */}
187 \textcolor{comment}{/* USER CODE END */}
188 
189     \textcolor{comment}{/* Enable Memory Hardware Initialization */}
190     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0xAU;
191 
192     \textcolor{comment}{/* Enable Memory Hardware Initialization for selected RAM's */}
193     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA  = ram;
194 
195     \textcolor{comment}{/* Wait until Memory Hardware Initialization complete */}
196     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
197     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x00000100U) != 0x00000100U)
198     \{
199     \}\textcolor{comment}{/* Wait */}
200 
201     \textcolor{comment}{/* Disable Memory Hardware Initialization */}
202     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
203 
204 \textcolor{comment}{/* USER CODE BEGIN (7) */}
205 \textcolor{comment}{/* USER CODE END */}
206 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a050e0c2257b541e651eb35d32f10c98d}\label{sys__selftest_8c_a050e0c2257b541e651eb35d32f10c98d}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!mibspi1\+Parity\+Check@{mibspi1\+Parity\+Check}}
\index{mibspi1\+Parity\+Check@{mibspi1\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{mibspi1\+Parity\+Check()}{mibspi1ParityCheck()}}
{\footnotesize\ttfamily void mibspi1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check M\+I\+B\+S\+P\+I1 R\+AM parity error detection and signaling mechanism. 

Routine to check M\+I\+B\+S\+P\+I1 R\+AM parity error detection and signaling mechanism 

Definition at line 1825 of file sys\+\_\+selftest.\+c.



References mibspi\+P\+A\+R\+R\+A\+M1, and mibspi\+R\+E\+G1.


\begin{DoxyCode}
1826 \{
1827     \textcolor{keyword}{volatile} uint32 spiread = 0U;
1828     uint32 mibspie\_bk = \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->MIBSPIE;
1829     uint32 mibspictl\_bk = \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL;
1830 
1831 \textcolor{comment}{/* USER CODE BEGIN (71) */}
1832 \textcolor{comment}{/* USER CODE END */}
1833 
1834     \textcolor{comment}{/* enable multi-buffered mode */}
1835     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->MIBSPIE = 0x1U;
1836 
1837     \textcolor{comment}{/* enable parity error detection */}
1838     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL = (\mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL & 0xFFFFFFF0U) | (0xAU);
1839 
1840     \textcolor{comment}{/* enable parity test mode */}
1841     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL |= 0x00000100U;
1842 
1843     \textcolor{comment}{/* flip bit 0 of the parity location */}
1844     \mbox{\hyperlink{reg__mibspi_8h_a3e70cf83cef67d59bf3c7236dd1e0a19}{mibspiPARRAM1}} ^= 0x1U;
1845 
1846     \textcolor{comment}{/* disable parity test mode */}
1847     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL &= 0xFFFFFEFFU;
1848 
1849     \textcolor{comment}{/* read from MibSPI1 RAM to cause parity error */}
1850     spiread = MIBSPI1RAMLOC;
1851 
1852     \textcolor{comment}{/* check if ESM group1 channel 17 is flagged */}
1853     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x20000U) == 0U)
1854     \{
1855         \textcolor{comment}{/* No MibSPI1 RAM parity error was flagged to ESM. */}
1856         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(MIBSPI1PARITYCHECK\_FAIL1);
1857     \}
1858     \textcolor{keywordflow}{else}
1859     \{
1860         \textcolor{comment}{/* clear parity error flags */}
1861         \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRSTAT = 0x3U;
1862 
1863         \textcolor{comment}{/* clear ESM group1 channel 17 flag */}
1864         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x20000U;
1865 
1866         \textcolor{comment}{/* enable parity test mode */}
1867         \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL |= 0x00000100U;
1868 
1869         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1870         \mbox{\hyperlink{reg__mibspi_8h_a3e70cf83cef67d59bf3c7236dd1e0a19}{mibspiPARRAM1}} ^= 0x1U;
1871     \}
1872 
1873     \textcolor{comment}{/* Restore MIBSPI control registers */}
1874     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL = mibspictl\_bk;
1875     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->MIBSPIE = mibspie\_bk;
1876 
1877 \textcolor{comment}{/* USER CODE BEGIN (72) */}
1878 \textcolor{comment}{/* USER CODE END */}
1879 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ae4c80f3599811e410da64821448b860b}\label{sys__selftest_8c_ae4c80f3599811e410da64821448b860b}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!mibspi3\+Parity\+Check@{mibspi3\+Parity\+Check}}
\index{mibspi3\+Parity\+Check@{mibspi3\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{mibspi3\+Parity\+Check()}{mibspi3ParityCheck()}}
{\footnotesize\ttfamily void mibspi3\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check M\+I\+B\+S\+P\+I3 R\+AM parity error detection and signaling mechanism. 

Routine to check M\+I\+B\+S\+P\+I3 R\+AM parity error detection and signaling mechanism 

Definition at line 1889 of file sys\+\_\+selftest.\+c.



References mibspi\+P\+A\+R\+R\+A\+M3, and mibspi\+R\+E\+G3.


\begin{DoxyCode}
1890 \{
1891     \textcolor{keyword}{volatile} uint32 spiread = 0U;
1892     uint32 mibspie\_bk = \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->MIBSPIE;
1893     uint32 mibspictl\_bk = \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL;
1894 
1895 \textcolor{comment}{/* USER CODE BEGIN (73) */}
1896 \textcolor{comment}{/* USER CODE END */}
1897 
1898     \textcolor{comment}{/* enable multi-buffered mode */}
1899     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->MIBSPIE = 0x1U;
1900 
1901     \textcolor{comment}{/* enable parity test mode */}
1902     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL |= 0x00000100U;
1903 
1904     \textcolor{comment}{/* flip bit 0 of the parity location */}
1905     \mbox{\hyperlink{reg__mibspi_8h_af440f4d730ee907f7998683662d38a99}{mibspiPARRAM3}} ^= 0x1U;
1906 
1907     \textcolor{comment}{/* enable parity error detection */}
1908     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL = (\mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL & 0xFFFFFFF0U) | (0xAU);
1909 
1910     \textcolor{comment}{/* disable parity test mode */}
1911     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL &= 0xFFFFFEFFU;
1912 
1913     \textcolor{comment}{/* read from MibSPI3 RAM to cause parity error */}
1914     spiread = MIBSPI3RAMLOC;
1915 
1916     \textcolor{comment}{/* check if ESM group1 channel 18 is flagged */}
1917     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x40000U) == 0U)
1918     \{
1919         \textcolor{comment}{/* No MibSPI3 RAM parity error was flagged to ESM. */}
1920         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(MIBSPI3PARITYCHECK\_FAIL1);
1921     \}
1922     \textcolor{keywordflow}{else}
1923     \{
1924         \textcolor{comment}{/* clear parity error flags */}
1925         \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRSTAT = 0x3U;
1926 
1927         \textcolor{comment}{/* clear ESM group1 channel 18 flag */}
1928         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40000U;
1929 
1930         \textcolor{comment}{/* enable parity test mode */}
1931         \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL |= 0x00000100U;
1932 
1933         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1934         \mbox{\hyperlink{reg__mibspi_8h_af440f4d730ee907f7998683662d38a99}{mibspiPARRAM3}} ^= 0x1U;
1935     \}
1936 
1937     \textcolor{comment}{/* Restore MIBSPI control registers */}
1938     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL = mibspictl\_bk;
1939     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->MIBSPIE = mibspie\_bk;
1940 
1941 \textcolor{comment}{/* USER CODE BEGIN (74) */}
1942 \textcolor{comment}{/* USER CODE END */}
1943 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a8ce4f5d8f1e282ddab7f65f5c5840e0a}\label{sys__selftest_8c_a8ce4f5d8f1e282ddab7f65f5c5840e0a}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!mibspi5\+Parity\+Check@{mibspi5\+Parity\+Check}}
\index{mibspi5\+Parity\+Check@{mibspi5\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{mibspi5\+Parity\+Check()}{mibspi5ParityCheck()}}
{\footnotesize\ttfamily void mibspi5\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check M\+I\+B\+S\+P\+I5 R\+AM parity error detection and signaling mechanism. 

Routine to check M\+I\+B\+S\+P\+I5 R\+AM parity error detection and signaling mechanism 

Definition at line 1953 of file sys\+\_\+selftest.\+c.



References mibspi\+P\+A\+R\+R\+A\+M5, and mibspi\+R\+E\+G5.


\begin{DoxyCode}
1954 \{
1955     \textcolor{keyword}{volatile} uint32 spiread = 0U;
1956     uint32 mibspie\_bk = \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->MIBSPIE;
1957     uint32 mibspictl\_bk = \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL;
1958 
1959 \textcolor{comment}{/* USER CODE BEGIN (75) */}
1960 \textcolor{comment}{/* USER CODE END */}
1961 
1962     \textcolor{comment}{/* enable multi-buffered mode */}
1963     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->MIBSPIE = 0x1U;
1964 
1965     \textcolor{comment}{/* enable parity test mode */}
1966     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL |= 0x00000100U;
1967 
1968     \textcolor{comment}{/* flip bit 0 of the parity location */}
1969     \mbox{\hyperlink{reg__mibspi_8h_a1443f050f83a68a49c7eed4c0084a511}{mibspiPARRAM5}} ^= 0x1U;
1970 
1971     \textcolor{comment}{/* enable parity error detection */}
1972     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL = (\mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL & 0xFFFFFFF0U) | (0xAU);
1973 
1974     \textcolor{comment}{/* disable parity test mode */}
1975     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL &= 0xFFFFFEFFU;
1976 
1977     \textcolor{comment}{/* read from MibSPI5 RAM to cause parity error */}
1978     spiread = MIBSPI5RAMLOC;
1979 
1980     \textcolor{comment}{/* check if ESM group1 channel 24 is flagged */}
1981     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x01000000U) == 0U)
1982     \{
1983         \textcolor{comment}{/* No MibSPI5 RAM parity error was flagged to ESM. */}
1984         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(MIBSPI5PARITYCHECK\_FAIL1);
1985     \}
1986     \textcolor{keywordflow}{else}
1987     \{
1988         \textcolor{comment}{/* clear parity error flags */}
1989         \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRSTAT = 0x3U;
1990 
1991         \textcolor{comment}{/* clear ESM group1 channel 24 flag */}
1992         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x01000000U;
1993 
1994         \textcolor{comment}{/* enable parity test mode */}
1995         \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL |= 0x00000100U;
1996 
1997         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1998         \mbox{\hyperlink{reg__mibspi_8h_a1443f050f83a68a49c7eed4c0084a511}{mibspiPARRAM5}} ^= 0x1U;
1999     \}
2000 
2001     \textcolor{comment}{/* Restore MIBSPI control registers */}
2002     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL = mibspictl\_bk;
2003     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->MIBSPIE = mibspie\_bk;
2004 
2005 \textcolor{comment}{/* USER CODE BEGIN (76) */}
2006 \textcolor{comment}{/* USER CODE END */}
2007 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a1edb8a500b4ad0f3e87b93245856a937}\label{sys__selftest_8c_a1edb8a500b4ad0f3e87b93245856a937}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!pbist\+Get\+Config\+Value@{pbist\+Get\+Config\+Value}}
\index{pbist\+Get\+Config\+Value@{pbist\+Get\+Config\+Value}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{pbist\+Get\+Config\+Value()}{pbistGetConfigValue()}}
{\footnotesize\ttfamily void pbist\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpbist__config__reg}{pbist\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2646 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2647 \{
2648     \textcolor{keywordflow}{if} (type == InitialValue)
2649     \{
2650         config\_reg->CONFIG\_RAMT = PBIST\_RAMT\_CONFIGVALUE;
2651         config\_reg->CONFIG\_DLR = PBIST\_DLR\_CONFIGVALUE;
2652         config\_reg->CONFIG\_PACT = PBIST\_PACT\_CONFIGVALUE;
2653         config\_reg->CONFIG\_PBISTID = PBIST\_PBISTID\_CONFIGVALUE;
2654         config\_reg->CONFIG\_OVER = PBIST\_OVER\_CONFIGVALUE;
2655         config\_reg->CONFIG\_FSRDL1 = PBIST\_FSRDL1\_CONFIGVALUE;
2656         config\_reg->CONFIG\_ROM = PBIST\_ROM\_CONFIGVALUE;
2657         config\_reg->CONFIG\_ALGO = PBIST\_ALGO\_CONFIGVALUE;
2658         config\_reg->CONFIG\_RINFOL = PBIST\_RINFOL\_CONFIGVALUE;
2659         config\_reg->CONFIG\_RINFOU = PBIST\_RINFOU\_CONFIGVALUE;
2660     \}
2661     \textcolor{keywordflow}{else}
2662     \{
2663     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2664         config\_reg->CONFIG\_RAMT = pbistREG->RAMT;
2665         config\_reg->CONFIG\_DLR = pbistREG->DLR;
2666         config\_reg->CONFIG\_PACT = pbistREG->PACT;
2667         config\_reg->CONFIG\_PBISTID = pbistREG->PBISTID;
2668         config\_reg->CONFIG\_OVER = pbistREG->OVER;
2669         config\_reg->CONFIG\_FSRDL1 = pbistREG->FSRDL1;
2670         config\_reg->CONFIG\_ROM = pbistREG->ROM;
2671         config\_reg->CONFIG\_ALGO = pbistREG->ALGO;
2672         config\_reg->CONFIG\_RINFOL = pbistREG->RINFOL;
2673         config\_reg->CONFIG\_RINFOU = pbistREG->RINFOU;
2674     \}
2675 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a2675f441b1c7bbadd9877cfd586bf959}\label{sys__selftest_8c_a2675f441b1c7bbadd9877cfd586bf959}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!pbist\+Is\+Test\+Completed@{pbist\+Is\+Test\+Completed}}
\index{pbist\+Is\+Test\+Completed@{pbist\+Is\+Test\+Completed}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{pbist\+Is\+Test\+Completed()}{pbistIsTestCompleted()}}
{\footnotesize\ttfamily boolean pbist\+Is\+Test\+Completed (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Checks to see if the P\+B\+I\+ST test is completed. 

\begin{DoxyReturn}{Returns}
1 if P\+B\+I\+ST test completed, otherwise 0.
\end{DoxyReturn}
Checks to see if the P\+B\+I\+ST test is completed. 

Definition at line 503 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G1.


\begin{DoxyCode}
504 \{
505 \textcolor{comment}{/* USER CODE BEGIN (22) */}
506 \textcolor{comment}{/* USER CODE END */}
507 
508     \textcolor{keywordflow}{return} ((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x1U) != 0U);
509 \textcolor{comment}{/* USER CODE BEGIN (23) */}
510 \textcolor{comment}{/* USER CODE END */}
511 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a975a794505ddcaf5d1c68e7a229fc8ae}\label{sys__selftest_8c_a975a794505ddcaf5d1c68e7a229fc8ae}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!pbist\+Is\+Test\+Passed@{pbist\+Is\+Test\+Passed}}
\index{pbist\+Is\+Test\+Passed@{pbist\+Is\+Test\+Passed}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{pbist\+Is\+Test\+Passed()}{pbistIsTestPassed()}}
{\footnotesize\ttfamily boolean pbist\+Is\+Test\+Passed (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Checks to see if the P\+B\+I\+ST test is completed successfully. 

\begin{DoxyReturn}{Returns}
1 if P\+B\+I\+ST test passed, otherwise 0.
\end{DoxyReturn}
Checks to see if the P\+B\+I\+ST test is completed successfully. 

Definition at line 522 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
523 \{
524 \textcolor{comment}{/* USER CODE BEGIN (24) */}
525 \textcolor{comment}{/* USER CODE END */}
526     \textcolor{keywordtype}{boolean} status;
527 
528     \textcolor{keywordflow}{if} (pbistREG->FSRF0 == 0U)
529     \{
530         status = \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}};
531     \}
532     \textcolor{keywordflow}{else}
533     \{
534         status = \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
535     \}
536 \textcolor{comment}{/* USER CODE BEGIN (25) */}
537 \textcolor{comment}{/* USER CODE END */}
538     \textcolor{keywordflow}{return} status;
539 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a3edbda42e27655bb5e9a3d067ab09caf}\label{sys__selftest_8c_a3edbda42e27655bb5e9a3d067ab09caf}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!pbist\+Port\+Test\+Status@{pbist\+Port\+Test\+Status}}
\index{pbist\+Port\+Test\+Status@{pbist\+Port\+Test\+Status}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{pbist\+Port\+Test\+Status()}{pbistPortTestStatus()}}
{\footnotesize\ttfamily boolean pbist\+Port\+Test\+Status (\begin{DoxyParamCaption}\item[{uint32}]{port }\end{DoxyParamCaption})}



Checks to see if the P\+B\+I\+ST Port test is completed successfully. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em port} & -\/ Select the port to get the status. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if P\+B\+I\+ST Port test completed successfully, otherwise 0.
\end{DoxyReturn}
Checks to see if the selected P\+B\+I\+ST Port test is completed successfully. 

Definition at line 551 of file sys\+\_\+selftest.\+c.



References P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0.


\begin{DoxyCode}
552 \{
553     \textcolor{keywordtype}{boolean} status;
554 \textcolor{comment}{/* USER CODE BEGIN (26) */}
555 \textcolor{comment}{/* USER CODE END */}
556 
557     \textcolor{keywordflow}{if}(port == (uint32)\mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3a2f1ea5882d645e86e9a7e8f809c5f5ea}{PBIST\_PORT0}})
558     \{
559       status =  (pbistREG->FSRF0 == 0U);
560     \}
561     \textcolor{keywordflow}{else}
562     \{
563       \textcolor{comment}{/* Invalid Input */}
564       status =  \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
565     \}
566 
567     \textcolor{keywordflow}{return}  status;
568 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ad5fcc064d8d51dda635d83235cf37e3e}\label{sys__selftest_8c_ad5fcc064d8d51dda635d83235cf37e3e}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!pbist\+Run@{pbist\+Run}}
\index{pbist\+Run@{pbist\+Run}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{pbist\+Run()}{pbistRun()}}
{\footnotesize\ttfamily void pbist\+Run (\begin{DoxyParamCaption}\item[{uint32}]{raminfoL,  }\item[{uint32}]{algomask }\end{DoxyParamCaption})}



C\+PU self test Driver. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em raminfoL} & -\/ Select the list of R\+AM to be tested. \\
\hline
\mbox{\tt in}  & {\em algomask} & -\/ Select the list of Algorithm to be run.\\
\hline
\end{DoxyParams}
This function performs Memory Built-\/in Self test using P\+B\+I\+ST module. 

Definition at line 421 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G1.


\begin{DoxyCode}
422 \{
423     \textcolor{keyword}{volatile} uint32 i = 0U;
424 
425 \textcolor{comment}{/* USER CODE BEGIN (17) */}
426 \textcolor{comment}{/* USER CODE END */}
427 
428     \textcolor{comment}{/* PBIST ROM clock frequency = HCLK frequency /2 */}
429     \textcolor{comment}{/* Disable memory self controller */}
430     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x00000105U;
431 
432     \textcolor{comment}{/* Disable Memory Initialization controller */}
433     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
434 
435     \textcolor{comment}{/* Enable PBIST controller */}
436     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA = 0x1U;
437 
438     \textcolor{comment}{/* Enable memory self controller */}
439     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x0000010AU;
440 
441     \textcolor{comment}{/* wait for 32 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
442     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
443     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
444     \textcolor{keywordflow}{for} (i=0U; i<(32U + (32U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
445 
446 \textcolor{comment}{/* USER CODE BEGIN (18) */}
447 \textcolor{comment}{/* USER CODE END */}
448 
449     \textcolor{comment}{/* Enable PBIST clocks and ROM clock */}
450     pbistREG->PACT = 0x3U;
451 
452     \textcolor{comment}{/* Select all algorithms to be tested */}
453     pbistREG->ALGO = algomask;
454 
455     \textcolor{comment}{/* Select RAM groups */}
456     pbistREG->RINFOL = raminfoL;
457 
458     \textcolor{comment}{/* Select all RAM groups */}
459     pbistREG->RINFOU = 0x00000000U;
460 
461     \textcolor{comment}{/* ROM contents will not override RINFOx settings */}
462     pbistREG->OVER = 0x0U;
463 
464     \textcolor{comment}{/* Algorithm code is loaded from ROM */}
465     pbistREG->ROM = 0x3U;
466 
467     \textcolor{comment}{/* Start PBIST */}
468     pbistREG->DLR = 0x14U;
469 
470 \textcolor{comment}{/* USER CODE BEGIN (19) */}
471 \textcolor{comment}{/* USER CODE END */}
472 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ac9b7e2d9da2b5166a9ea002d431e54ef}\label{sys__selftest_8c_ac9b7e2d9da2b5166a9ea002d431e54ef}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!pbist\+Self\+Check@{pbist\+Self\+Check}}
\index{pbist\+Self\+Check@{pbist\+Self\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{pbist\+Self\+Check()}{pbistSelfCheck()}}
{\footnotesize\ttfamily void pbist\+Self\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



P\+B\+I\+ST self test Driver. 

This function is called to perform P\+B\+I\+ST self test.

\begin{DoxyNote}{Note}
This Function uses register\textquotesingle{}s which are not exposed to users through T\+RM , to run custom algorithm to make P\+B\+I\+ST Fail. Users can use this function as Black box. 
\end{DoxyNote}


Definition at line 312 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
313 \{
314     \textcolor{keyword}{volatile} uint32 i = 0U;
315     uint32 PBIST\_wait\_done\_loop = 0U;
316 \textcolor{comment}{/* USER CODE BEGIN (13) */}
317 \textcolor{comment}{/* USER CODE END */}
318     \textcolor{comment}{/* Run a diagnostic check on the memory self-test controller */}
319     \textcolor{comment}{/* First set up the PBIST ROM clock as this clock frequency is limited to 90MHz */}
320 
321     \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
322     pbistREG->PACT = 0x0U;
323     
324     \textcolor{comment}{/* PBIST ROM clock frequency = HCLK frequency /2 */}
325     \textcolor{comment}{/* Disable memory self controller */}
326     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x00000105U;                
327     
328     \textcolor{comment}{/* Disable Memory Initialization controller */}
329     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
330 
331     \textcolor{comment}{/* Enable memory self controller */}
332     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x0000010AU;                               
333 
334     \textcolor{comment}{/* Clear PBIST Done */}
335     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT = 0x1U;
336     
337     \textcolor{comment}{/* Enable PBIST controller */}
338     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA = 0x1U;
339 
340     \textcolor{comment}{/* wait for 32 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
341     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
342     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
343     \textcolor{keywordflow}{for} (i=0U; i<(32U + (32U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
344 
345 \textcolor{comment}{/* USER CODE BEGIN (14) */}
346 \textcolor{comment}{/* USER CODE END */}
347 
348     \textcolor{comment}{/* Enable PBIST clocks and ROM clock */}
349     pbistREG->PACT = 0x3U;
350 
351     \textcolor{comment}{/* CPU control of PBIST */}
352     pbistREG->DLR = 0x10U;
353 
354     \textcolor{comment}{/* Custom always fail algo, this will not use the ROM and just set a fail */}
355     pbistREG->RAMT         = 0x00002000U;
356     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE400U = 0x4C000001U;
357     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE440U = 0x00000075U;
358     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE404U = 0x4C000002U;
359     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE444U = 0x00000075U;
360     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE408U = 0x4C000003U;
361     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE448U = 0x00000075U;
362     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE40CU = 0x4C000004U;
363     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE44CU = 0x00000075U;
364     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE410U = 0x4C000005U;
365     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE450U = 0x00000075U;
366     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE414U = 0x4C000006U;
367     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE454U = 0x00000075U;
368     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE418U = 0x00000000U;
369     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE458U = 0x00000001U;
370 
371     \textcolor{comment}{/* PBIST\_RUN */}
372     pbistREG->rsvd1[1U]    = 1U;
373 
374     \textcolor{comment}{/* wait until memory self-test done is indicated */}
375     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
376     \textcolor{keywordflow}{while} ((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x1U) != 0x1U) 
377     \{
378         PBIST\_wait\_done\_loop++;
379     \}\textcolor{comment}{/* Wait */}
380 
381     \textcolor{comment}{/* Check for the failure */}
382     \textcolor{keywordflow}{if} ((pbistREG->FSRF0 & 0x1U) != 0x1U)
383     \{
384         \textcolor{comment}{/* No failure was indicated even if the always fail algorithm was run*/}
385         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL1);
386 
387 \textcolor{comment}{/* USER CODE BEGIN (15) */}
388 \textcolor{comment}{/* USER CODE END */}
389     \}
390     \textcolor{keywordflow}{else}
391     \{
392         \textcolor{comment}{/* Check that the algorithm executed in the expected amount of time. */}
393         \textcolor{comment}{/* This time is dependent on the ROMCLKDIV selected above            */}
394         \textcolor{keywordflow}{if} (PBIST\_wait\_done\_loop >= 2U)
395         \{
396             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL2);
397         \}
398         
399         \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
400         pbistREG->PACT = 0x0U;
401 
402         \textcolor{comment}{/* Disable PBIST */}
403         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR &= 0xFFFFFFF0U;
404         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR |= 0x5U;
405 
406 \textcolor{comment}{/* USER CODE BEGIN (16) */}
407 \textcolor{comment}{/* USER CODE END */}
408     \}
409 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a1ea172c81d7549cd8181de098a91b752}\label{sys__selftest_8c_a1ea172c81d7549cd8181de098a91b752}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!pbist\+Stop@{pbist\+Stop}}
\index{pbist\+Stop@{pbist\+Stop}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{pbist\+Stop()}{pbistStop()}}
{\footnotesize\ttfamily void pbist\+Stop (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to stop P\+B\+I\+ST test enabled. 

This function is called to stop P\+B\+I\+ST after test is performed. 

Definition at line 482 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
483 \{
484 \textcolor{comment}{/* USER CODE BEGIN (20) */}
485 \textcolor{comment}{/* USER CODE END */}
486     \textcolor{comment}{/* disable pbist clocks and ROM clock */}
487     pbistREG->PACT = 0x0U;
488     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR &= 0xFFFFFFF0U;
489     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR |= 0x5U;
490 \textcolor{comment}{/* USER CODE BEGIN (21) */}
491 \textcolor{comment}{/* USER CODE END */}
492 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}\label{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!selftest\+Fail\+Notification@{selftest\+Fail\+Notification}}
\index{selftest\+Fail\+Notification@{selftest\+Fail\+Notification}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{selftest\+Fail\+Notification()}{selftestFailNotification()}}
{\footnotesize\ttfamily void selftest\+Fail\+Notification (\begin{DoxyParamCaption}\item[{uint32}]{flag }\end{DoxyParamCaption})}



Self test fail service routine. 

This function is called if there is a self test fail with appropriate flag 

Definition at line 58 of file sys\+\_\+selftest.\+c.



Referenced by adc1\+Parity\+Check(), adc2\+Parity\+Check(), can1\+Parity\+Check(), can2\+Parity\+Check(), can3\+Parity\+Check(), check\+Clock\+Monitor(), check\+Flash\+E\+E\+P\+R\+O\+M\+E\+C\+C(), check\+P\+L\+L1\+Slip(), and system\+Init().


\begin{DoxyCode}
59 \{
60 
61 \textcolor{comment}{/* USER CODE BEGIN (1) */}
62 \textcolor{comment}{/* USER CODE END */}
63 
64 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_afb360fa06ebe94d06978d25371ed2140}\label{sys__selftest_8c_afb360fa06ebe94d06978d25371ed2140}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!stc\+Get\+Config\+Value@{stc\+Get\+Config\+Value}}
\index{stc\+Get\+Config\+Value@{stc\+Get\+Config\+Value}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{stc\+Get\+Config\+Value()}{stcGetConfigValue()}}
{\footnotesize\ttfamily void stc\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structstc__config__reg}{stc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2691 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2692 \{
2693     \textcolor{keywordflow}{if} (type == InitialValue)
2694     \{
2695         config\_reg->CONFIG\_STCGCR0 = STC\_STCGCR0\_CONFIGVALUE;
2696         config\_reg->CONFIG\_STCGCR1 = STC\_STCGCR1\_CONFIGVALUE;
2697         config\_reg->CONFIG\_STCTPR = STC\_STCTPR\_CONFIGVALUE;
2698         config\_reg->CONFIG\_STCSCSCR = STC\_STCSCSCR\_CONFIGVALUE;
2699     \}
2700     \textcolor{keywordflow}{else}
2701     \{
2702     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2703         config\_reg->CONFIG\_STCGCR0 = stcREG->STCGCR0;
2704         config\_reg->CONFIG\_STCGCR1 = stcREG->STCGCR1;
2705         config\_reg->CONFIG\_STCTPR = stcREG->STCTPR;
2706         config\_reg->CONFIG\_STCSCSCR = stcREG->STCSCSCR;
2707     \}
2708 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a54f7309e862bab7a63c2c176c4b7cee9}\label{sys__selftest_8c_a54f7309e862bab7a63c2c176c4b7cee9}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!stc\+Self\+Check@{stc\+Self\+Check}}
\index{stc\+Self\+Check@{stc\+Self\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{stc\+Self\+Check()}{stcSelfCheck()}}
{\footnotesize\ttfamily void stc\+Self\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



S\+TC module self check Driver. 

This function is called to perform S\+TC module self check. 

Definition at line 216 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G2.


\begin{DoxyCode}
217 \{
218 \textcolor{comment}{/* USER CODE BEGIN (8) */}
219 \textcolor{comment}{/* USER CODE END */}
220     \textcolor{keyword}{volatile} uint32 i = 0U;
221 
222     \textcolor{comment}{/* Run a diagnostic check on the CPU self-test controller */}
223     \textcolor{comment}{/* First set up the STC clock divider as STC is only supported up to 90MHz */}
224 
225     \textcolor{comment}{/* STC clock is now normal mode CPU clock frequency/2 = 180MHz/2 */}
226     \mbox{\hyperlink{reg__system_8h_aa7b03254a6e13afea4c05b2fe8b2186b}{systemREG2}}->STCCLKDIV = 0x01000000U;
227 
228     \textcolor{comment}{/* Select one test interval, restart self-test next time, 0x00010001 */}
229     stcREG->STCGCR0 = 0x00010001U;
230 
231     \textcolor{comment}{/* Enable comparator self-check and stuck-at-0 fault insertion in CPU, 0x1A */}
232     stcREG->STCSCSCR = 0x1AU;
233 
234     \textcolor{comment}{/* Maximum time-out period */}
235     stcREG->STCTPR = 0xFFFFFFFFU;
236 
237     \textcolor{comment}{/* wait for 16 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
238     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
239     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
240     \textcolor{keywordflow}{for} (i=0U; i<(16U + (16U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
241 
242     \textcolor{comment}{/* Enable self-test */}
243     stcREG->STCGCR1 = 0xAU;
244 
245 \textcolor{comment}{/* USER CODE BEGIN (9) */}
246 \textcolor{comment}{/* USER CODE END */}
247 
248     \textcolor{comment}{/* Idle the CPU so that the self-test can start */}
249     \mbox{\hyperlink{sys__core_8h_a9ac3ba78e1c8af4d0b6a5381b11858b2}{\_gotoCPUIdle\_}}();
250 
251 \textcolor{comment}{/* USER CODE BEGIN (10) */}
252 \textcolor{comment}{/* USER CODE END */}
253 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_a2c1518db428c8ab63a56048cadfb4e6e}\label{sys__selftest_8c_a2c1518db428c8ab63a56048cadfb4e6e}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!stc\+Self\+Check\+Fail@{stc\+Self\+Check\+Fail}}
\index{stc\+Self\+Check\+Fail@{stc\+Self\+Check\+Fail}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{stc\+Self\+Check\+Fail()}{stcSelfCheckFail()}}
{\footnotesize\ttfamily void stc\+Self\+Check\+Fail (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



S\+TC Self test check fail service routine. 

This function is called if S\+TC Self test check fail. 

Definition at line 1130 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1131 \{
1132 \textcolor{comment}{/* USER CODE BEGIN (43) */}
1133 \textcolor{comment}{/* USER CODE END */}
1134     \textcolor{comment}{/* CPU self-test controller's own self-test failed.}
1135 \textcolor{comment}{     * It is not possible to verify that STC is capable of indicating a CPU self-test error.}
1136 \textcolor{comment}{     * It is not recommended to continue operation.}
1137 \textcolor{comment}{     */}
1138 
1139     \textcolor{comment}{/* User can add small piece of code to take system to Safe state using user code section.}
1140 \textcolor{comment}{     * Note: Just removing the for(;;) will take the system to unknown state under ST failure,}
1141 \textcolor{comment}{     * since it is not handled by HALCoGen driver */}
1142 \textcolor{comment}{/* USER CODE BEGIN (44) */}
1143 \textcolor{comment}{/* USER CODE END */}
1144     \textcolor{comment}{/*SAFETYMCUSW 5 C MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the user
       codes above and below" */}
1145     \textcolor{comment}{/*SAFETYMCUSW 26 S MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1146     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1147     \textcolor{keywordflow}{for}(;;)
1148     \{
1149     \}\textcolor{comment}{/* Wait */}
1150 \textcolor{comment}{/* USER CODE BEGIN (45) */}
1151 \textcolor{comment}{/* USER CODE END */}
1152 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8c_af7297818ebd5ffd62488091aa9633bf9}\label{sys__selftest_8c_af7297818ebd5ffd62488091aa9633bf9}} 
\index{sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}!vim\+Parity\+Check@{vim\+Parity\+Check}}
\index{vim\+Parity\+Check@{vim\+Parity\+Check}!sys\+\_\+selftest.\+c@{sys\+\_\+selftest.\+c}}
\subsubsection{\texorpdfstring{vim\+Parity\+Check()}{vimParityCheck()}}
{\footnotesize\ttfamily void vim\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check V\+IM R\+AM parity error detection and signaling mechanism. 

Routine to check V\+IM R\+AM parity error detection and signaling mechanism 

Definition at line 1187 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1188 \{
1189     \textcolor{keyword}{volatile} uint32 vimramread = 0U;
1190     uint32 vimparctl\_bk = VIM\_PARCTL;
1191 
1192 \textcolor{comment}{/* USER CODE BEGIN (49) */}
1193 \textcolor{comment}{/* USER CODE END */}
1194 
1195     \textcolor{comment}{/* Enable parity checking and parity test mode */}
1196     VIM\_PARCTL = 0x0000010AU;
1197 
1198     \textcolor{comment}{/* flip a bit in the VIM RAM parity location */}
1199     VIMRAMPARLOC ^= 0x1U;
1200 
1201     \textcolor{comment}{/* disable parity test mode */}
1202     VIM\_PARCTL = 0x0000000AU;
1203 
1204     \textcolor{comment}{/* cause parity error */}
1205     vimramread = VIMRAMLOC;
1206 
1207     \textcolor{comment}{/* check if ESM group1 channel 15 is flagged */}
1208     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x8000U) ==0U)
1209     \{
1210         \textcolor{comment}{/* VIM RAM parity error was not flagged to ESM. */}
1211         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(VIMPARITYCHECK\_FAIL1);
1212     \}
1213     \textcolor{keywordflow}{else}
1214     \{
1215         \textcolor{comment}{/* clear VIM RAM parity error flag in VIM */}
1216         VIM\_PARFLG = 0x1U;
1217 
1218         \textcolor{comment}{/* clear ESM group1 channel 15 flag */}
1219         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x8000U;
1220 
1221         \textcolor{comment}{/* Enable parity checking and parity test mode */}
1222         VIM\_PARCTL = 0x0000010AU;
1223 
1224         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1225         VIMRAMPARLOC ^= 0x1U;
1226     \}
1227 
1228     \textcolor{comment}{/* Restore Parity Control register */}
1229     VIM\_PARCTL = vimparctl\_bk;
1230 
1231 \textcolor{comment}{/* USER CODE BEGIN (50) */}
1232 \textcolor{comment}{/* USER CODE END */}
1233 \}
\end{DoxyCode}
