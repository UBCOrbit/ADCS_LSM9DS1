\hypertarget{sys__selftest_8h}{}\section{generated\+\_\+launchpad/include/sys\+\_\+selftest.h File Reference}
\label{sys__selftest_8h}\index{generated\+\_\+launchpad/include/sys\+\_\+selftest.\+h@{generated\+\_\+launchpad/include/sys\+\_\+selftest.\+h}}


System Memory Header File.  


{\ttfamily \#include \char`\"{}reg\+\_\+pbist.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}reg\+\_\+stc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}reg\+\_\+efc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}sys\+\_\+core.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}system.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}sys\+\_\+vim.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}adc.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}can.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}mibspi.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}het.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}htu.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}esm.\+h\char`\"{}}\newline
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structpbist__config__reg}{pbist\+\_\+config\+\_\+reg}}
\item 
struct \mbox{\hyperlink{structstc__config__reg}{stc\+\_\+config\+\_\+reg}}
\item 
struct \mbox{\hyperlink{structefc__config__reg}{efc\+\_\+config\+\_\+reg}}
\item 
struct \mbox{\hyperlink{structccmr4__config__reg}{ccmr4\+\_\+config\+\_\+reg}}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{sys__selftest_8h_aca63e6c2a1e88cd66ed1874570d3dc88}\label{sys__selftest_8h_aca63e6c2a1e88cd66ed1874570d3dc88}} 
\#define {\bfseries flash1bit\+Error}~($\ast$(volatile uint32 $\ast$)(0x\+F00803\+F0\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a94b582d0aae923f9095eececd94fefcc}\label{sys__selftest_8h_a94b582d0aae923f9095eececd94fefcc}} 
\#define {\bfseries flash2bit\+Error}~($\ast$(volatile uint32 $\ast$)(0x\+F00803\+F8\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a63619293391b7d9a87ad0a457ecb4c37}\label{sys__selftest_8h_a63619293391b7d9a87ad0a457ecb4c37}} 
\#define {\bfseries tcram\+A1bit\+Error}~($\ast$(volatile uint32 $\ast$)(0x08400000\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4419a755c0c6d378d38e4170dd3d9883}\label{sys__selftest_8h_a4419a755c0c6d378d38e4170dd3d9883}} 
\#define {\bfseries tcram\+A2bit\+Error}~($\ast$(volatile uint32 $\ast$)(0x08400010\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a8a5abf507de25aad0565e7f8f67521fe}\label{sys__selftest_8h_a8a5abf507de25aad0565e7f8f67521fe}} 
\#define {\bfseries tcram\+B1bit\+Error}~($\ast$(volatile uint32 $\ast$)(0x08400008\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_ad4fa2d7af7df2e74b82bc4e23c05b2c3}\label{sys__selftest_8h_ad4fa2d7af7df2e74b82bc4e23c05b2c3}} 
\#define {\bfseries tcram\+B2bit\+Error}~($\ast$(volatile uint32 $\ast$)(0x08400018\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_abac2827564ffe6b9720925fa157299bf}\label{sys__selftest_8h_abac2827564ffe6b9720925fa157299bf}} 
\#define {\bfseries tcram\+A1bit}~($\ast$(volatile uint64 $\ast$)(0x08000000\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a714acf7ec1c1aba28a3240e9a1bde19d}\label{sys__selftest_8h_a714acf7ec1c1aba28a3240e9a1bde19d}} 
\#define {\bfseries tcram\+A2bit}~($\ast$(volatile uint64 $\ast$)(0x08000010\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_aa5367b47fa6314d55a55ce16b0b4e51e}\label{sys__selftest_8h_aa5367b47fa6314d55a55ce16b0b4e51e}} 
\#define {\bfseries tcram\+B1bit}~($\ast$(volatile uint64 $\ast$)(0x08000008\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a3f6b60d17766150e9be450a830c45610}\label{sys__selftest_8h_a3f6b60d17766150e9be450a830c45610}} 
\#define {\bfseries tcram\+B2bit}~($\ast$(volatile uint64 $\ast$)(0x08000018\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a6914d871cf76625149ae1c80096c2211}\label{sys__selftest_8h_a6914d871cf76625149ae1c80096c2211}} 
\#define {\bfseries flash\+Bad\+E\+C\+C1}~($\ast$(volatile uint32 $\ast$)(0x20000000\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a1e0d1b4917e383dd863c4afb8dad1647}\label{sys__selftest_8h_a1e0d1b4917e383dd863c4afb8dad1647}} 
\#define {\bfseries flash\+Bad\+E\+C\+C2}~($\ast$(volatile uint32 $\ast$)(0x20000010\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae4adc5e9ab5822993da28bd0a3b99da2}\label{sys__selftest_8h_ae4adc5e9ab5822993da28bd0a3b99da2}} 
\#define {\bfseries C\+C\+M\+SR}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F\+F\+F\+F600\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a3719b8720a1636d0372f1a4280212e6d}\label{sys__selftest_8h_a3719b8720a1636d0372f1a4280212e6d}} 
\#define {\bfseries C\+C\+M\+K\+E\+YR}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F\+F\+F\+F604\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a041c60abaa6ed424ace6fd38f7e6c5e1}\label{sys__selftest_8h_a041c60abaa6ed424ace6fd38f7e6c5e1}} 
\#define {\bfseries D\+M\+A\+\_\+\+P\+A\+R\+CR}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F\+F\+F\+F1\+A8\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a2ef9e0e6b749e5246b45e99a5d1e6403}\label{sys__selftest_8h_a2ef9e0e6b749e5246b45e99a5d1e6403}} 
\#define {\bfseries D\+M\+A\+\_\+\+P\+A\+R\+A\+D\+DR}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F\+F\+F\+F1\+A\+C\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_af25ff089df077d5e88744732adda6b30}\label{sys__selftest_8h_af25ff089df077d5e88744732adda6b30}} 
\#define {\bfseries D\+M\+A\+R\+A\+M\+L\+OC}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F\+F80000\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a32301e7ce6ab2bf8083b2c497d3437a0}\label{sys__selftest_8h_a32301e7ce6ab2bf8083b2c497d3437a0}} 
\#define {\bfseries D\+M\+A\+R\+A\+M\+P\+A\+R\+L\+OC}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F\+F80\+A00\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a42a2974031aaef2a8b147d586e1cf831}\label{sys__selftest_8h_a42a2974031aaef2a8b147d586e1cf831}} 
\#define {\bfseries M\+I\+B\+S\+P\+I1\+R\+A\+M\+L\+OC}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F0\+E0000\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_ac66a5704cca40f3ab66f0aa28fb2b5bc}\label{sys__selftest_8h_ac66a5704cca40f3ab66f0aa28fb2b5bc}} 
\#define {\bfseries M\+I\+B\+S\+P\+I3\+R\+A\+M\+L\+OC}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F0\+C0000\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_aa238f791250277e0067113e1544090be}\label{sys__selftest_8h_aa238f791250277e0067113e1544090be}} 
\#define {\bfseries M\+I\+B\+S\+P\+I5\+R\+A\+M\+L\+OC}~($\ast$(volatile uint32 $\ast$)(0x\+F\+F0\+A0000\+U))
\item 
\mbox{\Hypertarget{sys__selftest_8h_a56d72c7aeb783deb573cf6368129aec3}\label{sys__selftest_8h_a56d72c7aeb783deb573cf6368129aec3}} 
\#define {\bfseries \+\_\+\+\_\+\+P\+B\+I\+S\+T\+\_\+\+H\+\_\+\+\_\+}
\item 
\mbox{\Hypertarget{sys__selftest_8h_af96929e92806acd410da3eb0f0fba53c}\label{sys__selftest_8h_af96929e92806acd410da3eb0f0fba53c}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+R\+O\+M\+\_\+\+P\+B\+I\+S\+T\+\_\+\+R\+A\+M\+\_\+\+G\+R\+O\+UP}~1U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a5589d05b68ae637d4a60323a3d871e80}\label{sys__selftest_8h_a5589d05b68ae637d4a60323a3d871e80}} 
\#define {\bfseries S\+T\+C\+\_\+\+R\+O\+M\+\_\+\+P\+B\+I\+S\+T\+\_\+\+R\+A\+M\+\_\+\+G\+R\+O\+UP}~2U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a016bb102f09739bcc9f7523b2eede9c6}\label{sys__selftest_8h_a016bb102f09739bcc9f7523b2eede9c6}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+R\+A\+M\+T\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a620f6570db02a6cb9a50022799de4482}\label{sys__selftest_8h_a620f6570db02a6cb9a50022799de4482}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+D\+L\+R\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae8e2258ebfc6d6f4bbc243d3792f5225}\label{sys__selftest_8h_ae8e2258ebfc6d6f4bbc243d3792f5225}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+P\+A\+C\+T\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a1407e3b64164d0917e1c1926b8b60d69}\label{sys__selftest_8h_a1407e3b64164d0917e1c1926b8b60d69}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+P\+B\+I\+S\+T\+I\+D\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a67a2c6a2f8eb2de383255fe5de7cbfdc}\label{sys__selftest_8h_a67a2c6a2f8eb2de383255fe5de7cbfdc}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+O\+V\+E\+R\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae2bb7bef0267b1ece0df630beee533b1}\label{sys__selftest_8h_ae2bb7bef0267b1ece0df630beee533b1}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+F\+S\+R\+D\+L1\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a0c59f18403964aa42261b2f862518df5}\label{sys__selftest_8h_a0c59f18403964aa42261b2f862518df5}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+R\+O\+M\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a865b27fac663103182676cdcf0aeb017}\label{sys__selftest_8h_a865b27fac663103182676cdcf0aeb017}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+A\+L\+G\+O\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a64b5568ebfee5a8d7443a8414ab66e79}\label{sys__selftest_8h_a64b5568ebfee5a8d7443a8414ab66e79}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+R\+I\+N\+F\+O\+L\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a5419227328645ee895ee5d3ab0403494}\label{sys__selftest_8h_a5419227328645ee895ee5d3ab0403494}} 
\#define {\bfseries P\+B\+I\+S\+T\+\_\+\+R\+I\+N\+F\+O\+U\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ac6dbfe137c24938cee4785c2779ccedb}\label{sys__selftest_8h_ac6dbfe137c24938cee4785c2779ccedb}} 
\#define {\bfseries \+\_\+\+\_\+\+S\+T\+C\+\_\+\+H\+\_\+\+\_\+}
\item 
\mbox{\Hypertarget{sys__selftest_8h_a77a1a54daa67c0657bfa9b6100670b76}\label{sys__selftest_8h_a77a1a54daa67c0657bfa9b6100670b76}} 
\#define {\bfseries S\+T\+C\+\_\+\+I\+N\+T\+E\+R\+V\+AL}~24U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a03004e33fb008c2eed2f0739bb4a39f7}\label{sys__selftest_8h_a03004e33fb008c2eed2f0739bb4a39f7}} 
\#define {\bfseries S\+T\+C\+\_\+\+M\+A\+X\+\_\+\+T\+I\+M\+E\+O\+UT}~0x\+F\+F\+F\+F\+F\+F\+F\+FU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a22bea734601c10966500516b086befe9}\label{sys__selftest_8h_a22bea734601c10966500516b086befe9}} 
\#define {\bfseries S\+T\+C\+\_\+\+S\+T\+C\+G\+C\+R0\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x\+F\+F\+F\+F0000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a0933bbfe847f972c03187cad4d793029}\label{sys__selftest_8h_a0933bbfe847f972c03187cad4d793029}} 
\#define {\bfseries S\+T\+C\+\_\+\+S\+T\+C\+G\+C\+R1\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x5U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a913cae6640515d4117ecfd500ef7f3e9}\label{sys__selftest_8h_a913cae6640515d4117ecfd500ef7f3e9}} 
\#define {\bfseries S\+T\+C\+\_\+\+S\+T\+C\+T\+P\+R\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x\+F\+F\+F\+F\+F\+F\+F\+FU
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae0311020e428cc924fc1502999b0a0e5}\label{sys__selftest_8h_ae0311020e428cc924fc1502999b0a0e5}} 
\#define {\bfseries S\+T\+C\+\_\+\+S\+T\+C\+S\+C\+S\+C\+R\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x5U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4f010fd98c8c4b44b9fc63c6604253ee}\label{sys__selftest_8h_a4f010fd98c8c4b44b9fc63c6604253ee}} 
\#define {\bfseries \+\_\+\+\_\+\+E\+F\+C\+\_\+\+H\+\_\+\+\_\+}
\item 
\mbox{\Hypertarget{sys__selftest_8h_a6ad4c7f924e24241629dc10ed6b433f9}\label{sys__selftest_8h_a6ad4c7f924e24241629dc10ed6b433f9}} 
\#define {\bfseries I\+N\+P\+U\+T\+\_\+\+E\+N\+A\+B\+LE}~0x0000000\+FU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a40984b9ac260aa5f3467e55a91cfff30}\label{sys__selftest_8h_a40984b9ac260aa5f3467e55a91cfff30}} 
\#define {\bfseries I\+N\+P\+U\+T\+\_\+\+D\+I\+S\+A\+B\+LE}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a70963ccca5ce8f7dca6a88b752c9a538}\label{sys__selftest_8h_a70963ccca5ce8f7dca6a88b752c9a538}} 
\#define {\bfseries S\+Y\+S\+\_\+\+W\+S\+\_\+\+R\+E\+A\+D\+\_\+\+S\+T\+A\+T\+ES}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a7baeb8bdab8847f3907a81219ff9df61}\label{sys__selftest_8h_a7baeb8bdab8847f3907a81219ff9df61}} 
\#define {\bfseries S\+Y\+S\+\_\+\+R\+E\+P\+A\+I\+R\+\_\+\+E\+N\+\_\+0}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a199d403c843879c806d1b470e9708341}\label{sys__selftest_8h_a199d403c843879c806d1b470e9708341}} 
\#define {\bfseries S\+Y\+S\+\_\+\+R\+E\+P\+A\+I\+R\+\_\+\+E\+N\+\_\+3}~0x00000100U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ab73629f432272dc96d03a3ca4ce14092}\label{sys__selftest_8h_ab73629f432272dc96d03a3ca4ce14092}} 
\#define {\bfseries S\+Y\+S\+\_\+\+R\+E\+P\+A\+I\+R\+\_\+\+E\+N\+\_\+5}~0x00000200U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a023b6896e0c2430b0162782e92bf0cf2}\label{sys__selftest_8h_a023b6896e0c2430b0162782e92bf0cf2}} 
\#define {\bfseries S\+Y\+S\+\_\+\+D\+E\+I\+D\+\_\+\+A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+EN}~0x00000400U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a5e86a322a5653fa3b3fe3153fd4d89ab}\label{sys__selftest_8h_a5e86a322a5653fa3b3fe3153fd4d89ab}} 
\#define {\bfseries E\+F\+C\+\_\+\+F\+D\+I\+\_\+\+EN}~0x00000800U
\item 
\mbox{\Hypertarget{sys__selftest_8h_acbff457aff1e7185198add1da6e1a59c}\label{sys__selftest_8h_acbff457aff1e7185198add1da6e1a59c}} 
\#define {\bfseries E\+F\+C\+\_\+\+F\+D\+I\+\_\+\+D\+IS}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae8947cdee7e1ece2f0ddf0b4312fa2cc}\label{sys__selftest_8h_ae8947cdee7e1ece2f0ddf0b4312fa2cc}} 
\#define {\bfseries S\+Y\+S\+\_\+\+E\+C\+C\+\_\+\+O\+V\+E\+R\+R\+I\+D\+E\+\_\+\+EN}~0x00001000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a761c6c3c551e08703f4046319c092553}\label{sys__selftest_8h_a761c6c3c551e08703f4046319c092553}} 
\#define {\bfseries S\+Y\+S\+\_\+\+E\+C\+C\+\_\+\+O\+V\+E\+R\+R\+I\+D\+E\+\_\+\+D\+IS}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_aee98d02032ea1d9c25462881906d488f}\label{sys__selftest_8h_aee98d02032ea1d9c25462881906d488f}} 
\#define {\bfseries S\+Y\+S\+\_\+\+E\+C\+C\+\_\+\+S\+E\+L\+F\+\_\+\+T\+E\+S\+T\+\_\+\+EN}~0x00002000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a84dd968e5c5646e17a635eedfd3d4af6}\label{sys__selftest_8h_a84dd968e5c5646e17a635eedfd3d4af6}} 
\#define {\bfseries S\+Y\+S\+\_\+\+E\+C\+C\+\_\+\+S\+E\+L\+F\+\_\+\+T\+E\+S\+T\+\_\+\+D\+IS}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_af3986297b99a9f545ec6c28f8b8edbf4}\label{sys__selftest_8h_af3986297b99a9f545ec6c28f8b8edbf4}} 
\#define {\bfseries O\+U\+T\+P\+U\+T\+\_\+\+E\+N\+A\+B\+LE}~0x0003\+C000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_acc9eb2479607a79b7af314b985f8d3f0}\label{sys__selftest_8h_acc9eb2479607a79b7af314b985f8d3f0}} 
\#define {\bfseries O\+U\+T\+P\+U\+T\+\_\+\+D\+I\+S\+A\+B\+LE}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a394b60c80e9f57bd372648cca3077d9b}\label{sys__selftest_8h_a394b60c80e9f57bd372648cca3077d9b}} 
\#define {\bfseries E\+F\+C\+\_\+\+A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+E\+R\+R\+O\+R\+\_\+\+EN}~0x00040000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a528d36a8cba2cb7437f24a06766b1300}\label{sys__selftest_8h_a528d36a8cba2cb7437f24a06766b1300}} 
\#define {\bfseries E\+F\+C\+\_\+\+I\+N\+S\+T\+R\+U\+C\+T\+I\+O\+N\+\_\+\+E\+R\+R\+O\+R\+\_\+\+EN}~0x00080000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a2c45ef8a51ac122bce6633946a838e34}\label{sys__selftest_8h_a2c45ef8a51ac122bce6633946a838e34}} 
\#define {\bfseries E\+F\+C\+\_\+\+I\+N\+S\+T\+R\+U\+C\+T\+I\+O\+N\+\_\+\+I\+N\+F\+O\+\_\+\+EN}~0x00100000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_addc8c1839388d94cfc070bfcc006ba0d}\label{sys__selftest_8h_addc8c1839388d94cfc070bfcc006ba0d}} 
\#define {\bfseries E\+F\+C\+\_\+\+S\+E\+L\+F\+\_\+\+T\+E\+S\+T\+\_\+\+E\+R\+R\+O\+R\+\_\+\+EN}~0x00200000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a0f0c81a7a3b2ff0d60f0ee590b51ae6f}\label{sys__selftest_8h_a0f0c81a7a3b2ff0d60f0ee590b51ae6f}} 
\#define {\bfseries E\+F\+C\+\_\+\+A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+E\+R\+R\+O\+R\+\_\+\+D\+IS}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae7f57325fb8c6ceb487b2a044364d78b}\label{sys__selftest_8h_ae7f57325fb8c6ceb487b2a044364d78b}} 
\#define {\bfseries E\+F\+C\+\_\+\+I\+N\+S\+T\+R\+U\+C\+T\+I\+O\+N\+\_\+\+E\+R\+R\+O\+R\+\_\+\+D\+IS}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a9f4eae529953b90ec7d4afe13616606a}\label{sys__selftest_8h_a9f4eae529953b90ec7d4afe13616606a}} 
\#define {\bfseries E\+F\+C\+\_\+\+I\+N\+S\+T\+R\+U\+C\+T\+I\+O\+N\+\_\+\+I\+N\+F\+O\+\_\+\+D\+IS}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ada6191d891f9f51176801e0776ee7a6a}\label{sys__selftest_8h_ada6191d891f9f51176801e0776ee7a6a}} 
\#define {\bfseries E\+F\+C\+\_\+\+S\+E\+L\+F\+\_\+\+T\+E\+S\+T\+\_\+\+E\+R\+R\+O\+R\+\_\+\+D\+IS}~0x00000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_af62fab23e0e159851d615cf94022d58a}\label{sys__selftest_8h_af62fab23e0e159851d615cf94022d58a}} 
\#define {\bfseries D\+I\+S\+A\+B\+L\+E\+\_\+\+R\+E\+A\+D\+\_\+\+R\+O\+W0}~0x00800000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_abb048a5f37b2970c94621cb4000f198a}\label{sys__selftest_8h_abb048a5f37b2970c94621cb4000f198a}} 
\#define {\bfseries S\+Y\+S\+\_\+\+R\+E\+P\+A\+I\+R\+\_\+0}~0x00000010U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a628da0579dc45b5aff788e8791191bf1}\label{sys__selftest_8h_a628da0579dc45b5aff788e8791191bf1}} 
\#define {\bfseries S\+Y\+S\+\_\+\+R\+E\+P\+A\+I\+R\+\_\+3}~0x00000010U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ab865911e5be4a16e27f447c52335aadb}\label{sys__selftest_8h_ab865911e5be4a16e27f447c52335aadb}} 
\#define {\bfseries S\+Y\+S\+\_\+\+R\+E\+P\+A\+I\+R\+\_\+5}~0x00000020U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ad11f1018dc2cf771d3d059b17439d90b}\label{sys__selftest_8h_ad11f1018dc2cf771d3d059b17439d90b}} 
\#define {\bfseries S\+Y\+S\+\_\+\+D\+E\+I\+D\+\_\+\+A\+U\+T\+O\+L\+O\+AD}~0x00000040U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a7fdf03c49fd6292a43209e8f1400eb90}\label{sys__selftest_8h_a7fdf03c49fd6292a43209e8f1400eb90}} 
\#define {\bfseries S\+Y\+S\+\_\+\+F\+C\+L\+RZ}~0x00000080U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a98046388c8e057daa293f54df7210b5e}\label{sys__selftest_8h_a98046388c8e057daa293f54df7210b5e}} 
\#define {\bfseries E\+F\+C\+\_\+\+R\+E\+A\+DY}~0x00000100U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae15537ce27ea12fe06103795acf3c68d}\label{sys__selftest_8h_ae15537ce27ea12fe06103795acf3c68d}} 
\#define {\bfseries S\+Y\+S\+\_\+\+E\+C\+C\+\_\+\+O\+V\+E\+R\+R\+I\+DE}~0x00000200U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ac167daccd10770e318f9e40076611551}\label{sys__selftest_8h_ac167daccd10770e318f9e40076611551}} 
\#define {\bfseries E\+F\+C\+\_\+\+A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+E\+R\+R\+OR}~0x00000400U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a482dc6fc304c6207126886d1e82d9195}\label{sys__selftest_8h_a482dc6fc304c6207126886d1e82d9195}} 
\#define {\bfseries E\+F\+C\+\_\+\+I\+N\+S\+T\+R\+U\+C\+T\+I\+O\+N\+\_\+\+E\+R\+R\+OR}~0x00000800U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae6cbfcf78efd7be2bef30d62906dade2}\label{sys__selftest_8h_ae6cbfcf78efd7be2bef30d62906dade2}} 
\#define {\bfseries E\+F\+C\+\_\+\+I\+N\+S\+T\+R\+U\+C\+T\+I\+O\+N\+\_\+\+I\+N\+FO}~0x00001000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_aee231669b49aaec4e6ff7513d5ec196e}\label{sys__selftest_8h_aee231669b49aaec4e6ff7513d5ec196e}} 
\#define {\bfseries S\+Y\+S\+\_\+\+E\+C\+C\+\_\+\+S\+E\+L\+F\+\_\+\+T\+E\+ST}~0x00002000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a342fe812e02f07a1776dd7e18b6d2e75}\label{sys__selftest_8h_a342fe812e02f07a1776dd7e18b6d2e75}} 
\#define {\bfseries E\+F\+C\+\_\+\+S\+E\+L\+F\+\_\+\+T\+E\+S\+T\+\_\+\+E\+R\+R\+OR}~0x00004000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a5b907280d18c6b78b94af98053943371}\label{sys__selftest_8h_a5b907280d18c6b78b94af98053943371}} 
\#define {\bfseries E\+F\+C\+\_\+\+S\+E\+L\+F\+\_\+\+T\+E\+S\+T\+\_\+\+D\+O\+NE}~0x00008000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a799517031a8334a42807b119bb456c53}\label{sys__selftest_8h_a799517031a8334a42807b119bb456c53}} 
\#define {\bfseries T\+I\+M\+E\+\_\+\+O\+UT}~0x01
\item 
\mbox{\Hypertarget{sys__selftest_8h_a33345c73e3ecd0308d7dfd4d9d6e5068}\label{sys__selftest_8h_a33345c73e3ecd0308d7dfd4d9d6e5068}} 
\#define {\bfseries A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+N\+O\+\_\+\+F\+U\+S\+E\+R\+O\+M\+\_\+\+D\+A\+TA}~0x02U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ab55be881def698e013350d3fdf8158b8}\label{sys__selftest_8h_ab55be881def698e013350d3fdf8158b8}} 
\#define {\bfseries A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+S\+I\+G\+N\+\_\+\+F\+A\+IL}~0x03U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a534ffd478954216e76a4230153feeb40}\label{sys__selftest_8h_a534ffd478954216e76a4230153feeb40}} 
\#define {\bfseries A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+P\+R\+O\+G\+\_\+\+I\+N\+T\+E\+R\+R\+U\+PT}~0x04U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a1ace6eabf3670e9134a7622538d1032d}\label{sys__selftest_8h_a1ace6eabf3670e9134a7622538d1032d}} 
\#define {\bfseries A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+T\+W\+O\+\_\+\+B\+I\+T\+\_\+\+E\+RR}~0x05U
\item 
\mbox{\Hypertarget{sys__selftest_8h_af6776eee94565509c9fc3f154b07e18a}\label{sys__selftest_8h_af6776eee94565509c9fc3f154b07e18a}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+W\+R\+\_\+\+P\+\_\+\+S\+ET}~0x06U
\item 
\mbox{\Hypertarget{sys__selftest_8h_afad097629429c48d85ebb6b2d20e19ce}\label{sys__selftest_8h_afad097629429c48d85ebb6b2d20e19ce}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+M\+N\+Y\+\_\+\+D\+A\+T\+A\+\_\+\+I\+T\+E\+R\+TN}~0x07U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a3c107cfa39405533495da56a8dc43487}\label{sys__selftest_8h_a3c107cfa39405533495da56a8dc43487}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+M\+N\+Y\+\_\+\+C\+N\+T\+R\+\_\+\+I\+T\+E\+R\+TN}~0x08U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a64126aedd15b0eb23868590eb948f8a6}\label{sys__selftest_8h_a64126aedd15b0eb23868590eb948f8a6}} 
\#define {\bfseries U\+N\+\_\+\+P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+B\+I\+T\+\_\+\+S\+ET}~0x09U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a5f6d9bad83b9e7faecefc0b8ae60abf6}\label{sys__selftest_8h_a5f6d9bad83b9e7faecefc0b8ae60abf6}} 
\#define {\bfseries R\+E\+D\+U\+N\+D\+A\+N\+T\+\_\+\+R\+E\+P\+A\+I\+R\+\_\+\+R\+OW}~0x0\+AU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a8e804301a495082cdd76a8905709a8da}\label{sys__selftest_8h_a8e804301a495082cdd76a8905709a8da}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+M\+N\+Y\+\_\+\+C\+R\+A\+\_\+\+I\+T\+E\+R\+TN}~0x0\+BU
\item 
\mbox{\Hypertarget{sys__selftest_8h_aa9262e67956257e83cb9c0fe890942c5}\label{sys__selftest_8h_aa9262e67956257e83cb9c0fe890942c5}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+S\+A\+M\+E\+\_\+\+D\+A\+TA}~0x0\+CU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a140b24daaa84cf8383025968c613dbf4}\label{sys__selftest_8h_a140b24daaa84cf8383025968c613dbf4}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+C\+M\+P\+\_\+\+S\+K\+IP}~0x0\+DU
\item 
\mbox{\Hypertarget{sys__selftest_8h_af3a076677668a763e357c24c62e69efb}\label{sys__selftest_8h_af3a076677668a763e357c24c62e69efb}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+A\+B\+O\+RT}~0x0\+EU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a8402fbb5ed7be5e13fb449af283bf4ae}\label{sys__selftest_8h_a8402fbb5ed7be5e13fb449af283bf4ae}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+I\+N\+C\+O\+R\+R\+E\+C\+T\+\_\+\+K\+EY}~0x0\+FU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a6905b6f6b54fa03628867cf89acefaf7}\label{sys__selftest_8h_a6905b6f6b54fa03628867cf89acefaf7}} 
\#define {\bfseries F\+U\+S\+E\+R\+O\+M\+\_\+\+L\+A\+S\+T\+R\+O\+W\+\_\+\+S\+T\+U\+CK}~0x10U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a232bb3ab81ba618561dbd6cfb2406795}\label{sys__selftest_8h_a232bb3ab81ba618561dbd6cfb2406795}} 
\#define {\bfseries A\+U\+T\+O\+L\+O\+A\+D\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+I\+T\+\_\+\+E\+RR}~0x15U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a45fbe4bce3f0de28d65b17a6ce0204fc}\label{sys__selftest_8h_a45fbe4bce3f0de28d65b17a6ce0204fc}} 
\#define {\bfseries D\+U\+M\+P\+W\+O\+R\+D\+\_\+\+T\+W\+O\+\_\+\+B\+I\+T\+\_\+\+E\+RR}~0x16U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a75a35d84247bc076e988d08b47837ca8}\label{sys__selftest_8h_a75a35d84247bc076e988d08b47837ca8}} 
\#define {\bfseries D\+U\+M\+P\+W\+O\+R\+D\+\_\+\+O\+N\+E\+\_\+\+B\+I\+T\+\_\+\+E\+RR}~0x17U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a1eb43f8f0ef0e6dff8579e43942f68f5}\label{sys__selftest_8h_a1eb43f8f0ef0e6dff8579e43942f68f5}} 
\#define {\bfseries S\+E\+L\+F\+\_\+\+T\+E\+S\+T\+\_\+\+E\+R\+R\+OR}~0x18U
\item 
\mbox{\Hypertarget{sys__selftest_8h_aee29a44e45a315579ec9b6d24bbf30e3}\label{sys__selftest_8h_aee29a44e45a315579ec9b6d24bbf30e3}} 
\#define {\bfseries I\+N\+S\+T\+R\+U\+C\+T\+I\+O\+N\+\_\+\+D\+O\+NE}~0x20U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a2264464750f063ca528884bd1dfabe0f}\label{sys__selftest_8h_a2264464750f063ca528884bd1dfabe0f}} 
\#define {\bfseries T\+E\+S\+T\+\_\+\+U\+N\+P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+R\+OM}~0x01000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a360eb47ba2240230ab1decfb31641be6}\label{sys__selftest_8h_a360eb47ba2240230ab1decfb31641be6}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+C\+RA}~0x02000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4ea174de0517304b91eb4c1e219a66b9}\label{sys__selftest_8h_a4ea174de0517304b91eb4c1e219a66b9}} 
\#define {\bfseries D\+U\+M\+P\+\_\+\+W\+O\+RD}~0x04000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a89e2d51e6caa9469aadea6e266a3b27f}\label{sys__selftest_8h_a89e2d51e6caa9469aadea6e266a3b27f}} 
\#define {\bfseries L\+O\+A\+D\+\_\+\+F\+U\+S\+E\+\_\+\+S\+C\+A\+N\+\_\+\+C\+H\+A\+IN}~0x05000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a96503442607870a6024e99421ccdafaf}\label{sys__selftest_8h_a96503442607870a6024e99421ccdafaf}} 
\#define {\bfseries P\+R\+O\+G\+R\+A\+M\+E\+\_\+\+D\+A\+TA}~0x07000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a9a91fc9c2f61dd864c7a0a3efc69e225}\label{sys__selftest_8h_a9a91fc9c2f61dd864c7a0a3efc69e225}} 
\#define {\bfseries R\+U\+N\+\_\+\+A\+U\+T\+O\+L\+O\+A\+D\+\_\+8}~0x08000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ac14c61a814ae08078433ea5cfdb18af4}\label{sys__selftest_8h_ac14c61a814ae08078433ea5cfdb18af4}} 
\#define {\bfseries R\+U\+N\+\_\+\+A\+U\+T\+O\+L\+O\+A\+D\+\_\+A}~0x0\+A000000U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a288eecf0ec085c36f466df4551b7164a}\label{sys__selftest_8h_a288eecf0ec085c36f466df4551b7164a}} 
\#define {\bfseries E\+F\+C\+\_\+\+B\+O\+U\+N\+D\+A\+R\+Y\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x0000200\+FU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a8e524bdf80ba4e547dd866cc2fe03105}\label{sys__selftest_8h_a8e524bdf80ba4e547dd866cc2fe03105}} 
\#define {\bfseries E\+F\+C\+\_\+\+P\+I\+N\+S\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x000082\+E0U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a7ba8312d57a3f0aec5c1ed160f1c694a}\label{sys__selftest_8h_a7ba8312d57a3f0aec5c1ed160f1c694a}} 
\#define {\bfseries E\+F\+C\+\_\+\+S\+E\+L\+F\+T\+E\+S\+T\+C\+Y\+C\+L\+E\+S\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x00000258U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a57f9eb7207341c8048067500147a4b5a}\label{sys__selftest_8h_a57f9eb7207341c8048067500147a4b5a}} 
\#define {\bfseries E\+F\+C\+\_\+\+S\+E\+L\+F\+T\+E\+S\+T\+S\+I\+G\+N\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0x5362\+F97\+FU
\item 
\mbox{\Hypertarget{sys__selftest_8h_a6a4b462491b2c7905b5cba570ecd4ca2}\label{sys__selftest_8h_a6a4b462491b2c7905b5cba570ecd4ca2}} 
\#define {\bfseries C\+C\+M\+S\+E\+L\+F\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~1U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a38de74d4b442f036fb14557d3674351f}\label{sys__selftest_8h_a38de74d4b442f036fb14557d3674351f}} 
\#define {\bfseries C\+C\+M\+S\+E\+L\+F\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L2}~2U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a24224cf0e2e92f068a44fb1d37b73cad}\label{sys__selftest_8h_a24224cf0e2e92f068a44fb1d37b73cad}} 
\#define {\bfseries C\+C\+M\+S\+E\+L\+F\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L3}~3U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a01fc2a9e922fa7819cae218945564050}\label{sys__selftest_8h_a01fc2a9e922fa7819cae218945564050}} 
\#define {\bfseries C\+C\+M\+S\+E\+L\+F\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L4}~4U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a2c715255a484a26947c50634201ddb59}\label{sys__selftest_8h_a2c715255a484a26947c50634201ddb59}} 
\#define {\bfseries P\+B\+I\+S\+T\+S\+E\+L\+F\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~5U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ad4cd5422a62d7c975be886444583d320}\label{sys__selftest_8h_ad4cd5422a62d7c975be886444583d320}} 
\#define {\bfseries E\+F\+C\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~6U
\item 
\mbox{\Hypertarget{sys__selftest_8h_aab106d935aef8d0fb46b717126a9d501}\label{sys__selftest_8h_aab106d935aef8d0fb46b717126a9d501}} 
\#define {\bfseries E\+F\+C\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L2}~7U
\item 
\mbox{\Hypertarget{sys__selftest_8h_aba81c7e85cf7bc8a2b34cbf0f826264a}\label{sys__selftest_8h_aba81c7e85cf7bc8a2b34cbf0f826264a}} 
\#define {\bfseries F\+M\+C\+E\+C\+C\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~8U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a6108549362abadab5cc3de30c4407797}\label{sys__selftest_8h_a6108549362abadab5cc3de30c4407797}} 
\#define {\bfseries C\+H\+E\+C\+K\+B0\+R\+A\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L1}~9U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a651d3db51690b813ac5c6b46a8a7fefd}\label{sys__selftest_8h_a651d3db51690b813ac5c6b46a8a7fefd}} 
\#define {\bfseries C\+H\+E\+C\+K\+B1\+R\+A\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L1}~10U
\item 
\mbox{\Hypertarget{sys__selftest_8h_af9c5aa7ced6f67ab9436a1c545fa2891}\label{sys__selftest_8h_af9c5aa7ced6f67ab9436a1c545fa2891}} 
\#define {\bfseries C\+H\+E\+C\+K\+F\+L\+A\+S\+H\+E\+C\+C\+\_\+\+F\+A\+I\+L1}~11U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a8d9357f464c503e3c03c63675e25e3af}\label{sys__selftest_8h_a8d9357f464c503e3c03c63675e25e3af}} 
\#define {\bfseries V\+I\+M\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~12U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a329fb87cc87abaad50e23037883b0bad}\label{sys__selftest_8h_a329fb87cc87abaad50e23037883b0bad}} 
\#define {\bfseries D\+M\+A\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~13U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a6b491ff4392725401c2b0f0fcdbbeb71}\label{sys__selftest_8h_a6b491ff4392725401c2b0f0fcdbbeb71}} 
\#define {\bfseries H\+E\+T1\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~14U
\item 
\mbox{\Hypertarget{sys__selftest_8h_adef0d372d5efab7a7050c298926ca599}\label{sys__selftest_8h_adef0d372d5efab7a7050c298926ca599}} 
\#define {\bfseries H\+T\+U1\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~15U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a71b59f48c8b4cd31855bc8be26799fd5}\label{sys__selftest_8h_a71b59f48c8b4cd31855bc8be26799fd5}} 
\#define {\bfseries H\+E\+T2\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~16U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a3670fe5135c8d58ca7a14494f8bacd1d}\label{sys__selftest_8h_a3670fe5135c8d58ca7a14494f8bacd1d}} 
\#define {\bfseries H\+T\+U2\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~17U
\item 
\mbox{\Hypertarget{sys__selftest_8h_aa23673ac7744faf671fa938a4b4aa269}\label{sys__selftest_8h_aa23673ac7744faf671fa938a4b4aa269}} 
\#define {\bfseries A\+D\+C1\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~18U
\item 
\mbox{\Hypertarget{sys__selftest_8h_afaf541dd29cf34228788612913ef30a9}\label{sys__selftest_8h_afaf541dd29cf34228788612913ef30a9}} 
\#define {\bfseries A\+D\+C2\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~19U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a037dbcfb034678b2dee3b9b9eeca0cb2}\label{sys__selftest_8h_a037dbcfb034678b2dee3b9b9eeca0cb2}} 
\#define {\bfseries C\+A\+N1\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~20U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a6f82c4db94689255f861b821a4f1252c}\label{sys__selftest_8h_a6f82c4db94689255f861b821a4f1252c}} 
\#define {\bfseries C\+A\+N2\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~21U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a65e0f1865820cce3f8116aff76010b4a}\label{sys__selftest_8h_a65e0f1865820cce3f8116aff76010b4a}} 
\#define {\bfseries C\+A\+N3\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~22U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4b267a9a1005ec0f21fece5db4c4a868}\label{sys__selftest_8h_a4b267a9a1005ec0f21fece5db4c4a868}} 
\#define {\bfseries M\+I\+B\+S\+P\+I1\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~23U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ab7d3f63b7e6d8c2a9936c7d8edd6a10e}\label{sys__selftest_8h_ab7d3f63b7e6d8c2a9936c7d8edd6a10e}} 
\#define {\bfseries M\+I\+B\+S\+P\+I3\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~24U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae508f304998876bd980e454daddbbfeb}\label{sys__selftest_8h_ae508f304998876bd980e454daddbbfeb}} 
\#define {\bfseries M\+I\+B\+S\+P\+I5\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~25U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae9894f581ca5c3693744a405d1bd9139}\label{sys__selftest_8h_ae9894f581ca5c3693744a405d1bd9139}} 
\#define {\bfseries C\+H\+E\+C\+K\+R\+A\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L1}~26U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a31c67cbe6dae94e62e3e7d9c60e81ecd}\label{sys__selftest_8h_a31c67cbe6dae94e62e3e7d9c60e81ecd}} 
\#define {\bfseries C\+H\+E\+C\+K\+R\+A\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L2}~27U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ac78720f87a8cc27894655da45c5dce72}\label{sys__selftest_8h_ac78720f87a8cc27894655da45c5dce72}} 
\#define {\bfseries C\+H\+E\+C\+K\+C\+L\+O\+C\+K\+M\+O\+N\+I\+T\+O\+R\+\_\+\+F\+A\+I\+L1}~28U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4f1d71b18109c9e69133e31bf6b1f816}\label{sys__selftest_8h_a4f1d71b18109c9e69133e31bf6b1f816}} 
\#define {\bfseries C\+H\+E\+C\+K\+F\+L\+A\+S\+H\+E\+E\+P\+R\+O\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L1}~29U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a2fec5649dfd374b3e1445a3e9f2f6e11}\label{sys__selftest_8h_a2fec5649dfd374b3e1445a3e9f2f6e11}} 
\#define {\bfseries C\+H\+E\+C\+K\+F\+L\+A\+S\+H\+E\+E\+P\+R\+O\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L2}~31U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a98b1e3e27d73d1e82e3b0e3e70f6b30a}\label{sys__selftest_8h_a98b1e3e27d73d1e82e3b0e3e70f6b30a}} 
\#define {\bfseries C\+H\+E\+C\+K\+F\+L\+A\+S\+H\+E\+E\+P\+R\+O\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L3}~32U
\item 
\mbox{\Hypertarget{sys__selftest_8h_abb27d83424219db43bb0510f0700fa09}\label{sys__selftest_8h_abb27d83424219db43bb0510f0700fa09}} 
\#define {\bfseries C\+H\+E\+C\+K\+F\+L\+A\+S\+H\+E\+E\+P\+R\+O\+M\+E\+C\+C\+\_\+\+F\+A\+I\+L4}~33U
\item 
\mbox{\Hypertarget{sys__selftest_8h_aff5c5a26aae744c0f4f08b377fc1a600}\label{sys__selftest_8h_aff5c5a26aae744c0f4f08b377fc1a600}} 
\#define {\bfseries C\+H\+E\+C\+K\+P\+L\+L1\+S\+L\+I\+P\+\_\+\+F\+A\+I\+L1}~34U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4e3184d98e0ce9f972ca6d99b4a33b89}\label{sys__selftest_8h_a4e3184d98e0ce9f972ca6d99b4a33b89}} 
\#define {\bfseries C\+H\+E\+C\+K\+R\+A\+M\+A\+D\+D\+R\+P\+A\+R\+I\+T\+Y\+\_\+\+F\+A\+I\+L1}~35U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ad8b7df35ad159115c9c5d9f31180d23e}\label{sys__selftest_8h_ad8b7df35ad159115c9c5d9f31180d23e}} 
\#define {\bfseries C\+H\+E\+C\+K\+R\+A\+M\+A\+D\+D\+R\+P\+A\+R\+I\+T\+Y\+\_\+\+F\+A\+I\+L2}~36U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4e6a4641e6e1910d58b6aa5f15ebd30a}\label{sys__selftest_8h_a4e6a4641e6e1910d58b6aa5f15ebd30a}} 
\#define {\bfseries C\+H\+E\+C\+K\+R\+A\+M\+U\+E\+R\+R\+T\+E\+S\+T\+\_\+\+F\+A\+I\+L1}~37U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a2058f60f557d121472d78be2a1e0be56}\label{sys__selftest_8h_a2058f60f557d121472d78be2a1e0be56}} 
\#define {\bfseries C\+H\+E\+C\+K\+R\+A\+M\+U\+E\+R\+R\+T\+E\+S\+T\+\_\+\+F\+A\+I\+L2}~38U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a1cd0263f8d9e1086d16872a1d161911d}\label{sys__selftest_8h_a1cd0263f8d9e1086d16872a1d161911d}} 
\#define {\bfseries F\+M\+C\+B\+U\+S1\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L1}~39U
\item 
\mbox{\Hypertarget{sys__selftest_8h_acd60ff5ea372fd4b33bc0d0f10a0f0a3}\label{sys__selftest_8h_acd60ff5ea372fd4b33bc0d0f10a0f0a3}} 
\#define {\bfseries F\+M\+C\+B\+U\+S1\+P\+A\+R\+I\+T\+Y\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L2}~40U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ae0ea1504dee7ed93929e037b28014215}\label{sys__selftest_8h_ae0ea1504dee7ed93929e037b28014215}} 
\#define {\bfseries P\+B\+I\+S\+T\+S\+E\+L\+F\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L2}~41U
\item 
\mbox{\Hypertarget{sys__selftest_8h_ad5c9efe1c93f8f873290e8eb50d58d46}\label{sys__selftest_8h_ad5c9efe1c93f8f873290e8eb50d58d46}} 
\#define {\bfseries P\+B\+I\+S\+T\+S\+E\+L\+F\+C\+H\+E\+C\+K\+\_\+\+F\+A\+I\+L3}~42U
\item 
\mbox{\Hypertarget{sys__selftest_8h_a4da28ec324d888cbab0ee3630cd8fd14}\label{sys__selftest_8h_a4da28ec324d888cbab0ee3630cd8fd14}} 
\#define {\bfseries C\+C\+M\+R4\+\_\+\+C\+C\+M\+K\+E\+Y\+R\+\_\+\+C\+O\+N\+F\+I\+G\+V\+A\+L\+UE}~0U
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{sys__selftest_8h_a548b0dd68c450559a31ac21d51191cfc}\label{sys__selftest_8h_a548b0dd68c450559a31ac21d51191cfc}} 
typedef struct \mbox{\hyperlink{structpbist__config__reg}{pbist\+\_\+config\+\_\+reg}} {\bfseries pbist\+\_\+config\+\_\+reg\+\_\+t}
\item 
\mbox{\Hypertarget{sys__selftest_8h_a5610fbb58a6f5e2e7dc9dabf11a69c82}\label{sys__selftest_8h_a5610fbb58a6f5e2e7dc9dabf11a69c82}} 
typedef struct \mbox{\hyperlink{structstc__config__reg}{stc\+\_\+config\+\_\+reg}} {\bfseries stc\+\_\+config\+\_\+reg\+\_\+t}
\item 
\mbox{\Hypertarget{sys__selftest_8h_a0337e3b52f237f6b89048c9fe8c4a210}\label{sys__selftest_8h_a0337e3b52f237f6b89048c9fe8c4a210}} 
typedef struct \mbox{\hyperlink{structefc__config__reg}{efc\+\_\+config\+\_\+reg}} {\bfseries efc\+\_\+config\+\_\+reg\+\_\+t}
\item 
\mbox{\Hypertarget{sys__selftest_8h_af698ac3e21b676af198d4a5c00ed1626}\label{sys__selftest_8h_af698ac3e21b676af198d4a5c00ed1626}} 
typedef struct \mbox{\hyperlink{structccmr4__config__reg}{ccmr4\+\_\+config\+\_\+reg}} {\bfseries ccmr4\+\_\+config\+\_\+reg\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3}{pbist\+Port}} \{ \mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3a2f1ea5882d645e86e9a7e8f809c5f5ea}{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0}} = 0U, 
\mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3ac933996e0cb7472c44de4b2f2f18e340}{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T1}} = 1U
 \}
\begin{DoxyCompactList}\small\item\em Alias names for pbist Port number. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0}{pbist\+Algo}} \{ \newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0af4dbf763a322a39325c6fe8ef24512f3}{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Slow}} = 0x00000001U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3cb6e6cbfa091ed9eb5158e68a2bb573}{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Fast}} = 0x00000002U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a145f5abb0d1630f7dc3919cab37af13b}{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+DP}} = 0x00000004U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5c6bcc919d0ee3f730d98812346148d8}{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+SP}} = 0x00000008U, 
\newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a31c36c35bbfe957b4f6225cf67dd1f58}{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+DP}} = 0x00000010U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8702034b17d9db4bb18e08316fcc4b73}{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+SP}} = 0x00000020U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad17fc4abcff110ca8d3e8fd7ce1c252b}{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+DP}} = 0x00000040U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a73e5dcee238f5f5d45e510363979bd8f}{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+SP}} = 0x00000080U, 
\newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad80f8831809b125fcf872eb2d8fa2516}{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+DP}} = 0x00000100U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3b93011b85a66e4b539f3546d9d511a4}{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+SP}} = 0x00000200U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c1c27da2103ab9b7a079539c19d51b4}{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+DP}} = 0x00000400U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad9f3d4a20607f6b6b9745a1b8461d5fd}{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+SP}} = 0x00000800U, 
\newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d81c60e8e03c58e685ce600819be3b9}{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+DP}} = 0x00001000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a89088597e412ed375f0fb37dfd075e0c}{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+SP}} = 0x00002000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2cbd15e057f6952a6ae3e17e419aec79}{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice1\+\_\+\+DP}} = 0x00004000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d2b586d443245d0b3f19719c8fa595e}{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice2\+\_\+\+DP}} = 0x00008000U, 
\newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a54e7e5c71a565a37d275301cbb90492e}{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+DP}} = 0x00010000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c8460e84b96f150fe537258ab5bcb8b}{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+SP}} = 0x00020000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5649232fff072a106f9caadada52bde3}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+DP}} = 0x00040000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a312bcd90a80f7e21dbcfd86f36580d6a}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+SP}} = 0x00080000U, 
\newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a528b4a83d409a6c38890d84c80b33110}{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+DP}} = 0x00100000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a6fb080b84d2de9f1b51ca4a135f5cef5}{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+SP}} = 0x00200000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8ae8831ab9d156185cfe6add75747f11}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+DP}} = 0x00400000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0aaa10af6b1ef6a452d4c5697c90d768bc}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+SP}} = 0x00800000U, 
\newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2ef8bd1190cd0470504d1fa7a08baba9}{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+DP}} = 0x01000000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a971c53636d2d1a3d7c6548c0c821debd}{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+SP}} = 0x02000000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5aadd9835f14c322dd264f4c7366353f}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+DP}} = 0x04000000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0abce63d0b00686b76dbf44d2a622df0fe}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+SP}} = 0x08000000U, 
\newline
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad5a55084ac740ad2c5e433167b4b858f}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+DP}} = 0x10000000U, 
\mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ae8b5ceba9ae5a71e3b6cf4a9b345d252}{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+SP}} = 0x20000000U
 \}
\begin{DoxyCompactList}\small\item\em Alias names for pbist Algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{sys__selftest_8h_a01f1d76b843e64acb8bb464d79b9cd45}{memory\+Port0\+Test\+Fail\+Notification}} (uint32 group\+Select, uint32 data\+Select, uint32 address, uint32 data)
\begin{DoxyCompactList}\small\item\em Memory Port 0 test fail notification. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a27770bcd3ed64bdd085157a5c99a3502}{memory\+Port1\+Test\+Fail\+Notification}} (uint32 group\+Select, uint32 data\+Select, uint32 address, uint32 data)
\begin{DoxyCompactList}\small\item\em Memory Port 1 test fail notification. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a1edb8a500b4ad0f3e87b93245856a937}{pbist\+Get\+Config\+Value}} (\mbox{\hyperlink{structpbist__config__reg}{pbist\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_afb360fa06ebe94d06978d25371ed2140}{stc\+Get\+Config\+Value}} (\mbox{\hyperlink{structstc__config__reg}{stc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_ac76ed167d7b4b27eedea0eb37de6acc2}{efc\+Get\+Config\+Value}} (\mbox{\hyperlink{structefc__config__reg}{efc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a2f7aaa1d96319ecb5d7b6cec31c56670}{ccm\+Self\+Check}} (void)
\begin{DoxyCompactList}\small\item\em C\+CM module self check Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a54f7309e862bab7a63c2c176c4b7cee9}{stc\+Self\+Check}} (void)
\begin{DoxyCompactList}\small\item\em S\+TC module self check Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a2c1518db428c8ab63a56048cadfb4e6e}{stc\+Self\+Check\+Fail}} (void)
\begin{DoxyCompactList}\small\item\em S\+TC Self test check fail service routine. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a27cee1191b0027e90cbb9c66983596b9}{cpu\+Self\+Test}} (uint32 no\+\_\+of\+\_\+intervals, uint32 max\+\_\+timeout, boolean restart\+\_\+test)
\begin{DoxyCompactList}\small\item\em C\+PU self test Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a932e8fff5749ae8038f0fbbe9029ec44}{cpu\+Self\+Test\+Fail}} (void)
\begin{DoxyCompactList}\small\item\em C\+PU Self test check fail service routine. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a3184dfe0846903e1111348942160dfe7}{memory\+Init}} (uint32 ram)
\begin{DoxyCompactList}\small\item\em Memory Initialization Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_ac9b7e2d9da2b5166a9ea002d431e54ef}{pbist\+Self\+Check}} (void)
\begin{DoxyCompactList}\small\item\em P\+B\+I\+ST self test Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_ad5fcc064d8d51dda635d83235cf37e3e}{pbist\+Run}} (uint32 raminfoL, uint32 algomask)
\begin{DoxyCompactList}\small\item\em C\+PU self test Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a1ea172c81d7549cd8181de098a91b752}{pbist\+Stop}} (void)
\begin{DoxyCompactList}\small\item\em Routine to stop P\+B\+I\+ST test enabled. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8h_a2675f441b1c7bbadd9877cfd586bf959}{pbist\+Is\+Test\+Completed}} (void)
\begin{DoxyCompactList}\small\item\em Checks to see if the P\+B\+I\+ST test is completed. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8h_a975a794505ddcaf5d1c68e7a229fc8ae}{pbist\+Is\+Test\+Passed}} (void)
\begin{DoxyCompactList}\small\item\em Checks to see if the P\+B\+I\+ST test is completed successfully. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8h_a3edbda42e27655bb5e9a3d067ab09caf}{pbist\+Port\+Test\+Status}} (uint32 port)
\begin{DoxyCompactList}\small\item\em Checks to see if the P\+B\+I\+ST Port test is completed successfully. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{sys__selftest_8h_adc8a571e336b788da775b5279597c9f9}\label{sys__selftest_8h_adc8a571e336b788da775b5279597c9f9}} 
void {\bfseries pbist\+Fail} (void)
\item 
uint32 \mbox{\hyperlink{sys__selftest_8h_a646eb27315f3ce47edde97c563389f76}{efc\+Check}} (void)
\begin{DoxyCompactList}\small\item\em E\+F\+U\+SE module self check Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_afd6cec31a44e7c8e325a744e9bcbf601}{efc\+Self\+Test}} (void)
\begin{DoxyCompactList}\small\item\em E\+F\+U\+SE module self check Driver. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8h_a9973f032c29389602b684d30ea390fad}{efc\+Stuck\+Zero\+Test}} (void)
\begin{DoxyCompactList}\small\item\em Checks to see if the E\+F\+U\+SE Stuck at zero test is completed successfully. \end{DoxyCompactList}\item 
boolean \mbox{\hyperlink{sys__selftest_8h_ad44409ae54516ba10303dd5c011f4fa6}{checkefc\+Self\+Test}} (void)
\begin{DoxyCompactList}\small\item\em E\+F\+U\+SE module self check Driver. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a3248a50d5c0516f336b46aa0114ba9be}{fmc\+Bus2\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Self Check Flash Bus2 Interface. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a183a0d9f1300394cff2f8fe0aa034d4b}{fmc\+E\+C\+Ccheck}} (void)
\begin{DoxyCompactList}\small\item\em Check Flash E\+CC Single Bit and multi Bit errors detection logic. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{sys__selftest_8h_aa035d17d1ecb2d6bb095a5c0b44a2143}\label{sys__selftest_8h_aa035d17d1ecb2d6bb095a5c0b44a2143}} 
void {\bfseries fmc\+Bus1\+Parity\+Check} (void)
\item 
void \mbox{\hyperlink{sys__selftest_8h_ad4cbf907aa7750c1c3601ed191842dd9}{check\+B0\+R\+A\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+A\+M1 E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_ab5e986484f3be2af5cd3a7595ba346c2}{check\+B1\+R\+A\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+A\+M2 E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a02bb81fd1b585ba20d4c6e7ed427a4ac}{check\+Flash\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check Flash E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_af7297818ebd5ffd62488091aa9633bf9}{vim\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check V\+IM R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_add4aed7c0b3711f72c9228a92effa518}{dma\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check D\+MA control packet R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a0267c576250cc80c1ffafae379fcd937}{adc1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check A\+D\+C1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_adad16c8dd5c10c57ff43cc705364bbde}{adc2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check A\+D\+C2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a66f658578435dc4d3984c76a3d2ed959}{het1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+E\+T1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a5f69665c7b7abb003cfb4a314ce1e943}{htu1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+T\+U1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a08473bcd7b0a42d859fe99011c4707b7}{het2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+E\+T2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_aaf183a3ffe2ce7257d5fbceb4cca69f0}{htu2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check H\+T\+U2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a034e78d72a2a9231d27d78256d3d194e}{can1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check C\+A\+N1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a0b4bb222e016b734e702da6a1ec5ab8a}{can2\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check C\+A\+N2 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_aba201eb114d129fe574af9dd61e6df05}{can3\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check C\+A\+N3 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a050e0c2257b541e651eb35d32f10c98d}{mibspi1\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check M\+I\+B\+S\+P\+I1 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_ae4c80f3599811e410da64821448b860b}{mibspi3\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check M\+I\+B\+S\+P\+I3 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a8ce4f5d8f1e282ddab7f65f5c5840e0a}{mibspi5\+Parity\+Check}} (void)
\begin{DoxyCompactList}\small\item\em Routine to check M\+I\+B\+S\+P\+I5 R\+AM parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a421594cf13d3b5ca42435c5a5604721c}{check\+R\+A\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+AM E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a012696be6fb67f7debf6f1ff6f9e3331}{check\+Clock\+Monitor}} (void)
\begin{DoxyCompactList}\small\item\em Check clock monitor failure detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a239d7544f8bb38fc73056467dbeb9e7c}{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC}} (void)
\begin{DoxyCompactList}\small\item\em Check Flash E\+E\+P\+R\+OM E\+CC error detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a08d6355b5f4052d4ef5d2d995032ba22}{check\+P\+L\+L1\+Slip}} (void)
\begin{DoxyCompactList}\small\item\em Check P\+L\+L1 Slip detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_af5cf3a39340edcc591f7a1bd6a3ad021}{check\+P\+L\+L2\+Slip}} (void)
\begin{DoxyCompactList}\small\item\em Check P\+L\+L2 Slip detection logic. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a85eb55d96d4a491e84a930dbea0e89a5}{check\+R\+A\+M\+Addr\+Parity}} (void)
\begin{DoxyCompactList}\small\item\em Check T\+C\+R\+AM Address parity error detection and signaling mechanism. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a7e5bbec947e5db02df2bda4ba2230677}{check\+R\+A\+M\+U\+E\+R\+R\+Test}} (void)
\begin{DoxyCompactList}\small\item\em Run R\+AM test. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_af9ecd48548d7a3d98d5dcc44d1e7ca51}{enable\+Parity}} (void)
\begin{DoxyCompactList}\small\item\em Enable peripheral R\+AM parity. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a15b66d583493adf7dc0ce8e3a89f00f5}{disable\+Parity}} (void)
\begin{DoxyCompactList}\small\item\em Disable peripheral R\+AM parity. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a58597c65615a9a0f05d48135ad48c0d6}{custom\+\_\+dabort}} (void)
\begin{DoxyCompactList}\small\item\em Custom Data abort routine for the application. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_ae96e990763ae7d45bd55ea5a27299a47}{selftest\+Fail\+Notification}} (uint32 flag)
\begin{DoxyCompactList}\small\item\em Self test fail service routine. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_a1f3b71a00b6347cb5f7f6eb922c36c9e}{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4}} (void)
\begin{DoxyCompactList}\small\item\em Workaround for the Errata P\+B\+I\+ST\#4. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{sys__selftest_8h_ab288da76a8169e1a92586cd06079358f}{ccmr4\+Get\+Config\+Value}} (\mbox{\hyperlink{structccmr4__config__reg}{ccmr4\+\_\+config\+\_\+reg\+\_\+t}} $\ast$config\+\_\+reg, \mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}} type)
\begin{DoxyCompactList}\small\item\em Get the initial or current values of the configuration registers. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
System Memory Header File. 

\begin{DoxyDate}{Date}
07-\/\+July-\/2017 
\end{DoxyDate}
\begin{DoxyVersion}{Version}
04.\+07.\+00
\end{DoxyVersion}
This file contains\+:
\begin{DoxyItemize}
\item Efuse Self Test Functions
\end{DoxyItemize}which are relevant for the System driver. 

\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Algo@{pbist\+Algo}}
\index{pbist\+Algo@{pbist\+Algo}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Algo}{pbistAlgo}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0}{pbist\+Algo}}}



Alias names for pbist Algorithm. 

This enumeration is used to provide alias names for the pbist Algorithm \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Slow@{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Slow}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Slow@{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Slow}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0af4dbf763a322a39325c6fe8ef24512f3}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0af4dbf763a322a39325c6fe8ef24512f3}} 
P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Slow&T\+R\+I\+P\+L\+E\+\_\+\+R\+E\+A\+D\+\_\+\+S\+L\+O\+W\+\_\+\+R\+E\+AD for P\+B\+I\+ST and S\+TC R\+OM \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Fast@{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Fast}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Fast@{P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Fast}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3cb6e6cbfa091ed9eb5158e68a2bb573}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3cb6e6cbfa091ed9eb5158e68a2bb573}} 
P\+B\+I\+S\+T\+\_\+\+Triple\+Read\+Fast&T\+R\+I\+P\+L\+E\+\_\+\+R\+E\+A\+D\+\_\+\+S\+L\+O\+W\+\_\+\+R\+E\+AD for P\+B\+I\+ST and S\+TC R\+OM \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a145f5abb0d1630f7dc3919cab37af13b}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a145f5abb0d1630f7dc3919cab37af13b}} 
P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+DP&March13 N Algo for 2 Port mem \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5c6bcc919d0ee3f730d98812346148d8}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5c6bcc919d0ee3f730d98812346148d8}} 
P\+B\+I\+S\+T\+\_\+\+March13\+N\+\_\+\+SP&March13 N Algo for 1 Port mem \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a31c36c35bbfe957b4f6225cf67dd1f58}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a31c36c35bbfe957b4f6225cf67dd1f58}} 
P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+DP&Down1a Algor forces the switching fo all data bits \& most addr bits on consecutive read cycles \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8702034b17d9db4bb18e08316fcc4b73}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8702034b17d9db4bb18e08316fcc4b73}} 
P\+B\+I\+S\+T\+\_\+\+D\+O\+W\+N1a\+\_\+\+SP&Down1a Algor forces the switching fo all data bits \& most addr bits on consecutive read cycles \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad17fc4abcff110ca8d3e8fd7ce1c252b}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad17fc4abcff110ca8d3e8fd7ce1c252b}} 
P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+DP&Map Column algo (to identify bit line senstivities) for 2 Port memory \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a73e5dcee238f5f5d45e510363979bd8f}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a73e5dcee238f5f5d45e510363979bd8f}} 
P\+B\+I\+S\+T\+\_\+\+Map\+Column\+\_\+\+SP&Map Column algo (to identify bit line senstivities) for 1 Port memory \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad80f8831809b125fcf872eb2d8fa2516}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad80f8831809b125fcf872eb2d8fa2516}} 
P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+DP&Pre-\/\+Charge algo to exercise pre-\/charge capability for 2 port memory \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3b93011b85a66e4b539f3546d9d511a4}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3b93011b85a66e4b539f3546d9d511a4}} 
P\+B\+I\+S\+T\+\_\+\+Precharge\+\_\+\+SP&Pre-\/\+Charge algo to exercise pre-\/charge capability for 1 port memory \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c1c27da2103ab9b7a079539c19d51b4}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c1c27da2103ab9b7a079539c19d51b4}} 
P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+DP&Global column decode logic algo for 2 Port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad9f3d4a20607f6b6b9745a1b8461d5fd}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad9f3d4a20607f6b6b9745a1b8461d5fd}} 
P\+B\+I\+S\+T\+\_\+\+D\+T\+X\+N2a\+\_\+\+SP&Global column decode logic algo for 1 Port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d81c60e8e03c58e685ce600819be3b9}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d81c60e8e03c58e685ce600819be3b9}} 
P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+DP&pmos oper algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a89088597e412ed375f0fb37dfd075e0c}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a89088597e412ed375f0fb37dfd075e0c}} 
P\+B\+I\+S\+T\+\_\+\+P\+M\+O\+S\+Open\+\_\+\+SP&pmos oper algo for 1 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice1\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice1\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice1\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice1\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2cbd15e057f6952a6ae3e17e419aec79}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2cbd15e057f6952a6ae3e17e419aec79}} 
P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice1\+\_\+\+DP&pmos open slice1 for 2port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice2\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice2\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d2b586d443245d0b3f19719c8fa595e}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d2b586d443245d0b3f19719c8fa595e}} 
P\+B\+I\+S\+T\+\_\+\+P\+P\+M\+O\+S\+Open\+Slice2\+\_\+\+DP&pmos open slice2 for 2port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a54e7e5c71a565a37d275301cbb90492e}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a54e7e5c71a565a37d275301cbb90492e}} 
P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+DP&flip10 algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c8460e84b96f150fe537258ab5bcb8b}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c8460e84b96f150fe537258ab5bcb8b}} 
P\+B\+I\+S\+T\+\_\+\+Flip10\+\_\+\+SP&flip10 algo for 1 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5649232fff072a106f9caadada52bde3}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5649232fff072a106f9caadada52bde3}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+DP&iddq algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a312bcd90a80f7e21dbcfd86f36580d6a}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a312bcd90a80f7e21dbcfd86f36580d6a}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+\_\+\+SP&iddq algo for 1 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a528b4a83d409a6c38890d84c80b33110}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a528b4a83d409a6c38890d84c80b33110}} 
P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+DP&retention algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a6fb080b84d2de9f1b51ca4a135f5cef5}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a6fb080b84d2de9f1b51ca4a135f5cef5}} 
P\+B\+I\+S\+T\+\_\+\+Retention\+\_\+\+SP&retention algo for 1 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8ae8831ab9d156185cfe6add75747f11}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8ae8831ab9d156185cfe6add75747f11}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+DP&iddq2 algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0aaa10af6b1ef6a452d4c5697c90d768bc}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0aaa10af6b1ef6a452d4c5697c90d768bc}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q2\+\_\+\+SP&iddq2 algo for 1 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2ef8bd1190cd0470504d1fa7a08baba9}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2ef8bd1190cd0470504d1fa7a08baba9}} 
P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+DP&retention2 algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a971c53636d2d1a3d7c6548c0c821debd}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a971c53636d2d1a3d7c6548c0c821debd}} 
P\+B\+I\+S\+T\+\_\+\+Retention2\+\_\+\+SP&retention2 algo for 1 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5aadd9835f14c322dd264f4c7366353f}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5aadd9835f14c322dd264f4c7366353f}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+DP&iddqwstripe algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0abce63d0b00686b76dbf44d2a622df0fe}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0abce63d0b00686b76dbf44d2a622df0fe}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe\+\_\+\+SP&iddqwstripe algo for 1 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+DP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+DP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+DP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad5a55084ac740ad2c5e433167b4b858f}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad5a55084ac740ad2c5e433167b4b858f}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+DP&iddqwstripe2 algo for 2 port memories \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+SP}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+SP@{P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+SP}}}\mbox{\Hypertarget{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ae8b5ceba9ae5a71e3b6cf4a9b345d252}\label{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ae8b5ceba9ae5a71e3b6cf4a9b345d252}} 
P\+B\+I\+S\+T\+\_\+\+I\+D\+D\+Q\+Row\+Stripe2\+\_\+\+SP&iddqwstripe2 algo for 1 port memories \\
\hline

\end{DoxyEnumFields}


Definition at line 119 of file sys\+\_\+selftest.\+h.


\begin{DoxyCode}
120 \{
121     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0af4dbf763a322a39325c6fe8ef24512f3}{PBIST\_TripleReadSlow}}     = 0x00000001U,  
122     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3cb6e6cbfa091ed9eb5158e68a2bb573}{PBIST\_TripleReadFast}}     = 0x00000002U,  
123     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a145f5abb0d1630f7dc3919cab37af13b}{PBIST\_March13N\_DP}}        = 0x00000004U,  
124     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5c6bcc919d0ee3f730d98812346148d8}{PBIST\_March13N\_SP}}        = 0x00000008U,  
125     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a31c36c35bbfe957b4f6225cf67dd1f58}{PBIST\_DOWN1a\_DP}}          = 0x00000010U,  
126     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8702034b17d9db4bb18e08316fcc4b73}{PBIST\_DOWN1a\_SP}}          = 0x00000020U,  
127     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad17fc4abcff110ca8d3e8fd7ce1c252b}{PBIST\_MapColumn\_DP}}       = 0x00000040U,  
128     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a73e5dcee238f5f5d45e510363979bd8f}{PBIST\_MapColumn\_SP}}       = 0x00000080U,  
129     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad80f8831809b125fcf872eb2d8fa2516}{PBIST\_Precharge\_DP}}       = 0x00000100U,  
130     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a3b93011b85a66e4b539f3546d9d511a4}{PBIST\_Precharge\_SP}}       = 0x00000200U,  
131     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c1c27da2103ab9b7a079539c19d51b4}{PBIST\_DTXN2a\_DP}}          = 0x00000400U,  
132     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad9f3d4a20607f6b6b9745a1b8461d5fd}{PBIST\_DTXN2a\_SP}}          = 0x00000800U,  
133     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d81c60e8e03c58e685ce600819be3b9}{PBIST\_PMOSOpen\_DP}}        = 0x00001000U,  
134     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a89088597e412ed375f0fb37dfd075e0c}{PBIST\_PMOSOpen\_SP}}        = 0x00002000U,  
135     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2cbd15e057f6952a6ae3e17e419aec79}{PBIST\_PPMOSOpenSlice1\_DP}} = 0x00004000U,  
136     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2d2b586d443245d0b3f19719c8fa595e}{PBIST\_PPMOSOpenSlice2\_DP}} = 0x00008000U,  
137     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a54e7e5c71a565a37d275301cbb90492e}{PBIST\_Flip10\_DP}}          = 0x00010000U,  
138     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2c8460e84b96f150fe537258ab5bcb8b}{PBIST\_Flip10\_SP}}          = 0x00020000U,  
139     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5649232fff072a106f9caadada52bde3}{PBIST\_IDDQ\_DP}}            = 0x00040000U,  
140     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a312bcd90a80f7e21dbcfd86f36580d6a}{PBIST\_IDDQ\_SP}}            = 0x00080000U,  
141     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a528b4a83d409a6c38890d84c80b33110}{PBIST\_Retention\_DP}}       = 0x00100000U,  
142     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a6fb080b84d2de9f1b51ca4a135f5cef5}{PBIST\_Retention\_SP}}       = 0x00200000U,  
143     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a8ae8831ab9d156185cfe6add75747f11}{PBIST\_IDDQ2\_DP}}           = 0x00400000U,  
144     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0aaa10af6b1ef6a452d4c5697c90d768bc}{PBIST\_IDDQ2\_SP}}           = 0x00800000U,  
145     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a2ef8bd1190cd0470504d1fa7a08baba9}{PBIST\_Retention2\_DP}}      = 0x01000000U,  
146     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a971c53636d2d1a3d7c6548c0c821debd}{PBIST\_Retention2\_SP}}      = 0x02000000U,  
147     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0a5aadd9835f14c322dd264f4c7366353f}{PBIST\_IDDQRowStripe\_DP}}   = 0x04000000U,  
148     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0abce63d0b00686b76dbf44d2a622df0fe}{PBIST\_IDDQRowStripe\_SP}}   = 0x08000000U,  
149     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ad5a55084ac740ad2c5e433167b4b858f}{PBIST\_IDDQRowStripe2\_DP}}  = 0x10000000U,  
150     \mbox{\hyperlink{sys__selftest_8h_adfcacf6330b62bf56ff01b0016dc43d0ae8b5ceba9ae5a71e3b6cf4a9b345d252}{PBIST\_IDDQRowStripe2\_SP}}  = 0x20000000U   
151 \};
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3}\label{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Port@{pbist\+Port}}
\index{pbist\+Port@{pbist\+Port}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Port}{pbistPort}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3}{pbist\+Port}}}



Alias names for pbist Port number. 

This enumeration is used to provide alias names for the pbist Port number
\begin{DoxyItemize}
\item P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0
\item P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T1
\end{DoxyItemize}

\begin{DoxyNote}{Note}
Check the datasheet for the port avaiability 
\end{DoxyNote}
\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0@{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0@{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0}}}\mbox{\Hypertarget{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3a2f1ea5882d645e86e9a7e8f809c5f5ea}\label{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3a2f1ea5882d645e86e9a7e8f809c5f5ea}} 
P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0&Alias for P\+B\+I\+ST Port 0 \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T1@{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T1}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T1@{P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T1}}}\mbox{\Hypertarget{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3ac933996e0cb7472c44de4b2f2f18e340}\label{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3ac933996e0cb7472c44de4b2f2f18e340}} 
P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T1&Alias for P\+B\+I\+ST Port 1 $<$ Check datasheet for Port 1 availability $>$ \\
\hline

\end{DoxyEnumFields}


Definition at line 109 of file sys\+\_\+selftest.\+h.


\begin{DoxyCode}
110 \{
111     \mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3a2f1ea5882d645e86e9a7e8f809c5f5ea}{PBIST\_PORT0}} = 0U, 
112     \mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3ac933996e0cb7472c44de4b2f2f18e340}{PBIST\_PORT1}} = 1U  
113 \};
\end{DoxyCode}


\subsection{Function Documentation}
\mbox{\Hypertarget{sys__selftest_8h_a0267c576250cc80c1ffafae379fcd937}\label{sys__selftest_8h_a0267c576250cc80c1ffafae379fcd937}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!adc1\+Parity\+Check@{adc1\+Parity\+Check}}
\index{adc1\+Parity\+Check@{adc1\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{adc1\+Parity\+Check()}{adc1ParityCheck()}}
{\footnotesize\ttfamily void adc1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check A\+D\+C1 R\+AM parity error detection and signaling mechanism. 

Routine to check A\+D\+C1 R\+AM parity error detection and signaling mechanism 

Definition at line 1526 of file sys\+\_\+selftest.\+c.



References adc\+P\+A\+R\+R\+A\+M1, adc\+R\+A\+M1, adc\+R\+E\+G1, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1527 \{
1528     \textcolor{keyword}{volatile} uint32 adcramread = 0U;
1529     uint32 adcparcr\_bk = \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR;
1530 
1531 \textcolor{comment}{/* USER CODE BEGIN (61) */}
1532 \textcolor{comment}{/* USER CODE END */}
1533 
1534     \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1535     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x10AU;
1536 
1537     \textcolor{comment}{/* Invert the parity bits inside the ADC1 RAM's first location */}
1538     \mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}} = ~(\mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}});
1539 
1540     \textcolor{comment}{/* clear the TEST bit */}
1541     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x00AU;
1542 
1543     \textcolor{comment}{/* This read is expected to trigger a parity error */}
1544     adcramread = \mbox{\hyperlink{reg__adc_8h_a2ffc4dd9d6f4d851ae80390db9d66c12}{adcRAM1}};
1545 
1546     \textcolor{comment}{/* Check for ESM group1 channel 19 to be flagged */}
1547     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80000U) ==0U)
1548     \{
1549         \textcolor{comment}{/* no ADC1 RAM parity error was flagged to ESM */}
1550         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(ADC1PARITYCHECK\_FAIL1);
1551     \}
1552     \textcolor{keywordflow}{else}
1553     \{
1554         \textcolor{comment}{/* clear ADC1 RAM parity error flag */}
1555         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80000U;
1556 
1557         \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1558         \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x10AU;
1559 
1560         \textcolor{comment}{/* Revert back the parity bits to correct data */}
1561         \mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}} = ~(\mbox{\hyperlink{reg__adc_8h_ad8b4bb22017e0c1cef058858bbfca32d}{adcPARRAM1}});
1562     \}
1563 
1564     \textcolor{comment}{/* Restore parity control register */}
1565     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = adcparcr\_bk;
1566 
1567 \textcolor{comment}{/* USER CODE BEGIN (62) */}
1568 \textcolor{comment}{/* USER CODE END */}
1569 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_adad16c8dd5c10c57ff43cc705364bbde}\label{sys__selftest_8h_adad16c8dd5c10c57ff43cc705364bbde}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!adc2\+Parity\+Check@{adc2\+Parity\+Check}}
\index{adc2\+Parity\+Check@{adc2\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{adc2\+Parity\+Check()}{adc2ParityCheck()}}
{\footnotesize\ttfamily void adc2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check A\+D\+C2 R\+AM parity error detection and signaling mechanism. 

Routine to check A\+D\+C2 R\+AM parity error detection and signaling mechanism 

Definition at line 1580 of file sys\+\_\+selftest.\+c.



References adc\+P\+A\+R\+R\+A\+M2, adc\+R\+A\+M2, adc\+R\+E\+G2, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1581 \{
1582     \textcolor{keyword}{volatile} uint32 adcramread = 0U;
1583     uint32 adcparcr\_bk = \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR;
1584 
1585 \textcolor{comment}{/* USER CODE BEGIN (63) */}
1586 \textcolor{comment}{/* USER CODE END */}
1587 
1588     \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1589     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x10AU;
1590 
1591     \textcolor{comment}{/* Invert the parity bits inside the ADC2 RAM's first location */}
1592     \mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}} = ~(\mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}});
1593 
1594     \textcolor{comment}{/* clear the TEST bit */}
1595     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x00AU;
1596 
1597     \textcolor{comment}{/* This read is expected to trigger a parity error */}
1598     adcramread = \mbox{\hyperlink{reg__adc_8h_afc05d668ab22b6b181f74d09ef709beb}{adcRAM2}};
1599 
1600     \textcolor{comment}{/* Check for ESM group1 channel 1 to be flagged */}
1601     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x2U) == 0U)
1602     \{
1603         \textcolor{comment}{/* no ADC2 RAM parity error was flagged to ESM */}
1604         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(ADC2PARITYCHECK\_FAIL1);
1605     \}
1606     \textcolor{keywordflow}{else}
1607     \{
1608         \textcolor{comment}{/* clear ADC2 RAM parity error flag */}
1609         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x2U;
1610 
1611         \textcolor{comment}{/* Set the TEST bit in the PARCR and enable parity checking */}
1612         \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x10AU;
1613 
1614         \textcolor{comment}{/* Revert back the parity bits to correct data */}
1615         \mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}} = ~(\mbox{\hyperlink{reg__adc_8h_a6b6953f9f51de4244783137ea3343829}{adcPARRAM2}});
1616     \}
1617 
1618     \textcolor{comment}{/* Restore parity control register*/}
1619     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = adcparcr\_bk;
1620 
1621 \textcolor{comment}{/* USER CODE BEGIN (64) */}
1622 \textcolor{comment}{/* USER CODE END */}
1623 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a034e78d72a2a9231d27d78256d3d194e}\label{sys__selftest_8h_a034e78d72a2a9231d27d78256d3d194e}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!can1\+Parity\+Check@{can1\+Parity\+Check}}
\index{can1\+Parity\+Check@{can1\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{can1\+Parity\+Check()}{can1ParityCheck()}}
{\footnotesize\ttfamily void can1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check C\+A\+N1 R\+AM parity error detection and signaling mechanism. 

Routine to check C\+A\+N1 R\+AM parity error detection and signaling mechanism 

Definition at line 1633 of file sys\+\_\+selftest.\+c.



References can\+P\+A\+R\+R\+A\+M1, can\+R\+A\+M1, can\+R\+E\+G1, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1634 \{
1635     \textcolor{keyword}{volatile} uint32 canread = 0U;
1636     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
1637     uint32 canctl\_bk =  \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL;
1638 
1639 \textcolor{comment}{/* USER CODE BEGIN (65) */}
1640 \textcolor{comment}{/* USER CODE END */}
1641 
1642     \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1643     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = 0x00001481U;
1644 
1645     \textcolor{comment}{/* Enable RAM Direct Access mode */}
1646     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->TEST = 0x00000200U;
1647 
1648     \textcolor{comment}{/* flip the parity bit */}
1649     \mbox{\hyperlink{reg__can_8h_ae6b205060d2fe86acdadc40de178493c}{canPARRAM1}} ^= 0x00001000U;
1650 
1651     \textcolor{comment}{/* Enable parity, disable init, still TEST mode */}
1652     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = 0x00002880U;
1653 
1654     \textcolor{comment}{/* Read location with parity error */}
1655     canread = \mbox{\hyperlink{reg__can_8h_abafb9e8112c19ec9e8e3ac56cbeef409}{canRAM1}};
1656 
1657     \textcolor{comment}{/* check if ESM group1 channel 21 is flagged */}
1658     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x00200000U) == 0U)
1659     \{
1660         \textcolor{comment}{/* No DCAN1 RAM parity error was flagged to ESM */}
1661         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CAN1PARITYCHECK\_FAIL1);
1662     \}
1663     \textcolor{keywordflow}{else}
1664     \{
1665         \textcolor{comment}{/* clear ESM group1 channel 21 flag */}
1666         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x00200000U;
1667 
1668         \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1669         \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = 0x00001481U;
1670 
1671         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1672         \mbox{\hyperlink{reg__can_8h_ae6b205060d2fe86acdadc40de178493c}{canPARRAM1}} ^= 0x00001000U;
1673     \}
1674 
1675     \textcolor{comment}{/* Disable RAM Direct Access mode */}
1676     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->TEST = 0x00000000U;
1677 
1678     \textcolor{comment}{/* Restore CTL register */}
1679     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = canctl\_bk;
1680 
1681     \textcolor{comment}{/* Read Error and Status register to clear Parity Error bit */}
1682     canread = \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->ES;
1683 
1684 \textcolor{comment}{/* USER CODE BEGIN (66) */}
1685 \textcolor{comment}{/* USER CODE END */}
1686 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a0b4bb222e016b734e702da6a1ec5ab8a}\label{sys__selftest_8h_a0b4bb222e016b734e702da6a1ec5ab8a}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!can2\+Parity\+Check@{can2\+Parity\+Check}}
\index{can2\+Parity\+Check@{can2\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{can2\+Parity\+Check()}{can2ParityCheck()}}
{\footnotesize\ttfamily void can2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check C\+A\+N2 R\+AM parity error detection and signaling mechanism. 

Routine to check C\+A\+N2 R\+AM parity error detection and signaling mechanism 

Definition at line 1697 of file sys\+\_\+selftest.\+c.



References can\+P\+A\+R\+R\+A\+M2, can\+R\+A\+M2, can\+R\+E\+G2, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1698 \{
1699     \textcolor{keyword}{volatile} uint32 canread = 0U;
1700     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
1701     uint32 canctl\_bk = \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL;
1702 
1703 \textcolor{comment}{/* USER CODE BEGIN (67) */}
1704 \textcolor{comment}{/* USER CODE END */}
1705 
1706     \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1707     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = 0x00001481U;
1708 
1709     \textcolor{comment}{/* Enable RAM Direct Access mode */}
1710     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->TEST = 0x00000200U;
1711 
1712     \textcolor{comment}{/* flip the parity bit */}
1713     \mbox{\hyperlink{reg__can_8h_a371c9079cb797249148aeee08bdcd3f8}{canPARRAM2}} ^= 0x00001000U;
1714 
1715     \textcolor{comment}{/* Enable parity, disable init, still TEST mode */}
1716     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = 0x00002880U;
1717 
1718     \textcolor{comment}{/* Read location with parity error */}
1719     canread = \mbox{\hyperlink{reg__can_8h_a715cfdf91b3cca750214e1c9c9a5b6e2}{canRAM2}};
1720 
1721     \textcolor{comment}{/* check if ESM group1 channel 23 is flagged */}
1722     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x00800000U) == 0U)
1723     \{
1724         \textcolor{comment}{/* No DCAN2 RAM parity error was flagged to ESM */}
1725         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CAN2PARITYCHECK\_FAIL1);
1726     \}
1727     \textcolor{keywordflow}{else}
1728     \{
1729         \textcolor{comment}{/* clear ESM group1 channel 23 flag */}
1730         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x00800000U;
1731 
1732         \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1733         \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = 0x00001481U;
1734 
1735         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1736         \mbox{\hyperlink{reg__can_8h_a371c9079cb797249148aeee08bdcd3f8}{canPARRAM2}} ^= 0x00001000U;
1737     \}
1738 
1739     \textcolor{comment}{/* Disable RAM Direct Access mode */}
1740     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->TEST = 0x00000000U;
1741 
1742     \textcolor{comment}{/* disable TEST mode */}
1743     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = canctl\_bk;
1744 
1745     \textcolor{comment}{/* Read Error and Status register to clear Parity Error bit */}
1746     canread = \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->ES;
1747 
1748 \textcolor{comment}{/* USER CODE BEGIN (68) */}
1749 \textcolor{comment}{/* USER CODE END */}
1750 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_aba201eb114d129fe574af9dd61e6df05}\label{sys__selftest_8h_aba201eb114d129fe574af9dd61e6df05}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!can3\+Parity\+Check@{can3\+Parity\+Check}}
\index{can3\+Parity\+Check@{can3\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{can3\+Parity\+Check()}{can3ParityCheck()}}
{\footnotesize\ttfamily void can3\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check C\+A\+N3 R\+AM parity error detection and signaling mechanism. 

Routine to check C\+A\+N3 R\+AM parity error detection and signaling mechanism 

Definition at line 1761 of file sys\+\_\+selftest.\+c.



References can\+P\+A\+R\+R\+A\+M3, can\+R\+A\+M3, can\+R\+E\+G3, esm\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
1762 \{
1763     \textcolor{keyword}{volatile} uint32 canread = 0U;
1764     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
1765     uint32 canctl\_bk = \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL;
1766 
1767 \textcolor{comment}{/* USER CODE BEGIN (69) */}
1768 \textcolor{comment}{/* USER CODE END */}
1769 
1770     \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1771     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = 0x00001481U;
1772 
1773     \textcolor{comment}{/* Enable RAM Direct Access mode */}
1774     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->TEST = 0x00000200U;
1775 
1776     \textcolor{comment}{/* flip the parity bit */}
1777     \mbox{\hyperlink{reg__can_8h_aa74f6edb7ce3f3c37e6a23c965437c43}{canPARRAM3}} ^= 0x00001000U;
1778 
1779     \textcolor{comment}{/* Enable parity, disable init, still TEST mode */}
1780     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = 0x00002880U;
1781 
1782     \textcolor{comment}{/* Read location with parity error */}
1783     canread = \mbox{\hyperlink{reg__can_8h_a16cd5c97c1260a2305d259ed783d1bdc}{canRAM3}};
1784 
1785     \textcolor{comment}{/* check if ESM group1 channel 22 is flagged */}
1786     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x00400000U) == 0U)
1787     \{
1788         \textcolor{comment}{/* No DCAN3 RAM parity error was flagged to ESM */}
1789         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CAN3PARITYCHECK\_FAIL1);
1790     \}
1791     \textcolor{keywordflow}{else}
1792     \{
1793         \textcolor{comment}{/* clear ESM group1 channel 22 flag */}
1794         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x00400000U;
1795 
1796         \textcolor{comment}{/* Disable parity, init mode, TEST mode */}
1797         \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = 0x00001481U;
1798 
1799         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1800         \mbox{\hyperlink{reg__can_8h_aa74f6edb7ce3f3c37e6a23c965437c43}{canPARRAM3}} ^= 0x00001000U;
1801     \}
1802 
1803     \textcolor{comment}{/* Disable RAM Direct Access mode */}
1804     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->TEST = 0x00000000U;
1805 
1806     \textcolor{comment}{/* disable TEST mode */}
1807     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = canctl\_bk;
1808 
1809     \textcolor{comment}{/* Read Error and Status register to clear Parity Error bit */}
1810     canread = \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->ES;
1811 
1812 \textcolor{comment}{/* USER CODE BEGIN (70) */}
1813 \textcolor{comment}{/* USER CODE END */}
1814 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ab288da76a8169e1a92586cd06079358f}\label{sys__selftest_8h_ab288da76a8169e1a92586cd06079358f}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!ccmr4\+Get\+Config\+Value@{ccmr4\+Get\+Config\+Value}}
\index{ccmr4\+Get\+Config\+Value@{ccmr4\+Get\+Config\+Value}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{ccmr4\+Get\+Config\+Value()}{ccmr4GetConfigValue()}}
{\footnotesize\ttfamily void ccmr4\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structccmr4__config__reg}{ccmr4\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2759 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2760 \{
2761     \textcolor{keywordflow}{if} (type == InitialValue)
2762     \{
2763         config\_reg->CONFIG\_CCMKEYR = CCMR4\_CCMKEYR\_CONFIGVALUE;
2764     \}
2765     \textcolor{keywordflow}{else}
2766     \{
2767     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2768         config\_reg->CONFIG\_CCMKEYR = CCMKEYR;
2769     \}
2770 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a2f7aaa1d96319ecb5d7b6cec31c56670}\label{sys__selftest_8h_a2f7aaa1d96319ecb5d7b6cec31c56670}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!ccm\+Self\+Check@{ccm\+Self\+Check}}
\index{ccm\+Self\+Check@{ccm\+Self\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{ccm\+Self\+Check()}{ccmSelfCheck()}}
{\footnotesize\ttfamily void ccm\+Self\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



C\+CM module self check Driver. 

This function self checks the C\+CM module. 

Definition at line 77 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
78 \{
79 \textcolor{comment}{/* USER CODE BEGIN (3) */}
80 \textcolor{comment}{/* USER CODE END */}
81 
82     \textcolor{comment}{/* Run a diagnostic check on the CCM-R4F module */}
83     \textcolor{comment}{/* This step ensures that the CCM-R4F can actually indicate an error */}
84 
85     \textcolor{comment}{/* Configure CCM in self-test mode */}
86     CCMKEYR = 0x6U;
87     \textcolor{comment}{/* Wait for CCM self-test to complete */}
88     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
89     \textcolor{keywordflow}{while} ((CCMSR & 0x100U) != 0x100U)
90     \{
91     \}\textcolor{comment}{/* Wait */}
92 
93 \textcolor{comment}{/* USER CODE BEGIN (4) */}
94 \textcolor{comment}{/* USER CODE END */}
95 
96     \textcolor{comment}{/* Check if there was an error during the self-test */}
97     \textcolor{keywordflow}{if} ((CCMSR & 0x1U) == 0x1U)
98     \{
99         \textcolor{comment}{/* STE is set */}
100         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL1);
101     \}
102     \textcolor{keywordflow}{else}
103     \{
104         \textcolor{comment}{/* Check CCM-R4 self-test error flag by itself (without compare error) */}
105         \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80000000U) == 0x80000000U)
106         \{
107             \textcolor{comment}{/* ESM flag is not set */}
108             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL2);
109         \}
110         \textcolor{keywordflow}{else}
111         \{
112             \textcolor{comment}{/* Configure CCM in error-forcing mode */}
113             CCMKEYR = 0x9U;
114 
115             \textcolor{comment}{/* Wait till error-forcing is completed. */}
116             \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
117             \textcolor{keywordflow}{while} (CCMKEYR != 0U)
118             \{
119             \}\textcolor{comment}{/* Wait */}
120 
121             \textcolor{comment}{/* check if compare error flag is set */}
122             \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] & 0x4U) != 0x4U)
123             \{
124                 \textcolor{comment}{/* ESM flag is not set */}
125                 \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL3);
126             \}
127             \textcolor{keywordflow}{else}
128             \{
129                 \textcolor{comment}{/* Check FIQIVEC to ESM High Interrupt flag is set */}
130                 \textcolor{keywordflow}{if}((vimREG->FIQINDEX & 0x000000FFU) != 1U)
131                 \{
132                    \textcolor{comment}{/* ESM High Interrupt flag is not set in VIM*/}
133                    \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL4);
134                 \}
135 
136                 \textcolor{comment}{/* clear ESM group2 channel 2 flag */}
137                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] = 0x4U;
138 
139                 \textcolor{comment}{/* clear ESM group2 shadow status flag */}
140                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SSR2 = 0x4U;
141 
142                 \textcolor{comment}{/* ESM self-test error needs to also be cleared */}
143                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80000000U;
144 
145                 \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
146                 \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
147 
148                 \textcolor{comment}{/* Configure CCM in selftest error-forcing mode */}
149                 CCMKEYR = 0xFU;
150 
151                 \textcolor{comment}{/* Wait till selftest error-forcing is completed. */}
152                 \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
153                 \textcolor{keywordflow}{while} (CCMKEYR != 0U)
154                 \{
155                 \}\textcolor{comment}{/* Wait */}
156 
157                 \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80000000U) != 0x80000000U)
158                 \{
159                     \textcolor{comment}{/* ESM flag not set */}
160                     \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CCMSELFCHECK\_FAIL2);
161                 \}
162                 \textcolor{keywordflow}{else}
163                 \{
164                     \textcolor{comment}{/* clear ESM flag */}
165                     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80000000U;
166                 \}
167             \}
168         \}
169     \}
170 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ad4cbf907aa7750c1c3601ed191842dd9}\label{sys__selftest_8h_ad4cbf907aa7750c1c3601ed191842dd9}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+B0\+R\+A\+M\+E\+CC@{check\+B0\+R\+A\+M\+E\+CC}}
\index{check\+B0\+R\+A\+M\+E\+CC@{check\+B0\+R\+A\+M\+E\+CC}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+B0\+R\+A\+M\+E\+C\+C()}{checkB0RAMECC()}}
{\footnotesize\ttfamily void check\+B0\+R\+A\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+A\+M1 E\+CC error detection logic. 

This function checks T\+C\+R\+A\+M1 E\+CC error detection logic. 

Definition at line 851 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
852 \{
853     \textcolor{keyword}{volatile} uint64 ramread = 0U;
854     \textcolor{keyword}{volatile} uint32 regread = 0U;
855     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
856     
857     uint64 tcramA1\_bk = tcramA1bit;
858     uint64 tcramA2\_bk = tcramA2bit;
859     \textcolor{keyword}{volatile} uint32 i;
860 \textcolor{comment}{/* USER CODE BEGIN (36) */}
861 \textcolor{comment}{/* USER CODE END */}
862 
863     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
864     tcram1REG->RAMCTRL = 0x0005010AU;
865     tcram2REG->RAMCTRL = 0x0005010AU;
866 
867     \textcolor{comment}{/* the first 1-bit error will cause an error response */}
868     tcram1REG->RAMTHRESHOLD = 0x1U;
869     tcram2REG->RAMTHRESHOLD = 0x1U;
870 
871     \textcolor{comment}{/* allow SERR to be reported to ESM */}
872     tcram1REG->RAMINTCTRL = 0x1U;
873     tcram2REG->RAMINTCTRL = 0x1U;
874 
875     \textcolor{comment}{/* cause a 1-bit ECC error */}
876     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
877     tcramA1bitError ^= 0x1U;
878     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
879 
880     \textcolor{comment}{/* disable writes to ECC RAM */}
881     tcram1REG->RAMCTRL = 0x0005000AU;
882     tcram2REG->RAMCTRL = 0x0005000AU;
883 
884     \textcolor{comment}{/* read from location with 1-bit ECC error */}
885     ramread = tcramA1bit;
886 
887     \textcolor{comment}{/* Check for error status */}
888     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x1U;
889     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x1U;
890     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
891     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
892     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) && (tcram2ErrStat == 0U))
893     \{
894         \textcolor{comment}{/* TCRAM module does not reflect 1-bit error reported by CPU */}
895         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKB0RAMECC\_FAIL1);
896     \}
897     \textcolor{keywordflow}{else}
898     \{
899         \textcolor{comment}{/* clear SERR flag */}
900         tcram1REG->RAMERRSTATUS = 0x1U;
901         tcram2REG->RAMERRSTATUS = 0x1U;
902 
903         \textcolor{comment}{/* clear status flags for ESM group1 channels 26 and 28 */}
904         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x14000000U;
905     \}
906 
907     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
908     tcram1REG->RAMCTRL = 0x0005010AU;
909     tcram2REG->RAMCTRL = 0x0005010AU;
910 
911     \textcolor{comment}{/* cause a 2-bit ECC error */}
912     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
913     tcramA2bitError ^= 0x3U;
914     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
915 
916     \textcolor{comment}{/* read from location with 2-bit ECC error this will cause a data abort to be generated */}
917     ramread = tcramA2bit;
918 
919     \textcolor{comment}{/* delay before restoring the ram value */}
920     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
921     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
922     \textcolor{keywordflow}{for}(i=0U;i<10U;i++)
923     \{
924     \}\textcolor{comment}{/* Wait */}
925 
926     regread = tcram1REG->RAMUERRADDR;
927     regread = tcram2REG->RAMUERRADDR;
928 
929     \textcolor{comment}{/* disable writes to ECC RAM */}
930     tcram1REG->RAMCTRL = 0x0005000AU;
931     tcram2REG->RAMCTRL = 0x0005000AU;
932 
933     \textcolor{comment}{/* Compute correct ECC */}
934     tcramA1bit = tcramA1\_bk;
935     tcramA2bit = tcramA2\_bk;
936 
937 \textcolor{comment}{/* USER CODE BEGIN (37) */}
938 \textcolor{comment}{/* USER CODE END */}
939 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ab5e986484f3be2af5cd3a7595ba346c2}\label{sys__selftest_8h_ab5e986484f3be2af5cd3a7595ba346c2}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+B1\+R\+A\+M\+E\+CC@{check\+B1\+R\+A\+M\+E\+CC}}
\index{check\+B1\+R\+A\+M\+E\+CC@{check\+B1\+R\+A\+M\+E\+CC}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+B1\+R\+A\+M\+E\+C\+C()}{checkB1RAMECC()}}
{\footnotesize\ttfamily void check\+B1\+R\+A\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+A\+M2 E\+CC error detection logic. 

This function checks T\+C\+R\+A\+M2 E\+CC error detection logic. 

Definition at line 949 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
950 \{
951     \textcolor{keyword}{volatile} uint64 ramread = 0U;
952     \textcolor{keyword}{volatile} uint32 regread = 0U;
953     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
954 
955     uint64 tcramB1\_bk = tcramB1bit;
956     uint64 tcramB2\_bk = tcramB2bit;
957     \textcolor{keyword}{volatile} uint32 i;
958 \textcolor{comment}{/* USER CODE BEGIN (38) */}
959 \textcolor{comment}{/* USER CODE END */}
960 
961     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
962     tcram1REG->RAMCTRL = 0x0005010AU;
963     tcram2REG->RAMCTRL = 0x0005010AU;
964 
965     \textcolor{comment}{/* the first 1-bit error will cause an error response */}
966     tcram1REG->RAMTHRESHOLD = 0x1U;
967     tcram2REG->RAMTHRESHOLD = 0x1U;
968 
969     \textcolor{comment}{/* allow SERR to be reported to ESM */}
970     tcram1REG->RAMINTCTRL = 0x1U;
971     tcram2REG->RAMINTCTRL = 0x1U;
972 
973     \textcolor{comment}{/* cause a 1-bit ECC error */}
974     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
975     tcramB1bitError ^= 0x1U;
976     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
977 
978     \textcolor{comment}{/* disable writes to ECC RAM */}
979     tcram1REG->RAMCTRL = 0x0005000AU;
980     tcram2REG->RAMCTRL = 0x0005000AU;
981 
982     \textcolor{comment}{/* read from location with 1-bit ECC error */}
983     ramread = tcramB1bit;
984 
985     \textcolor{comment}{/* Check for error status */}
986     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x1U;
987     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x1U;
988     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
989     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
990     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) && (tcram2ErrStat == 0U))
991     \{
992         \textcolor{comment}{/* TCRAM module does not reflect 1-bit error reported by CPU */}
993         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKB1RAMECC\_FAIL1);
994     \}
995     \textcolor{keywordflow}{else}
996     \{
997         \textcolor{comment}{/* clear SERR flag */}
998         tcram1REG->RAMERRSTATUS = 0x1U;
999         tcram2REG->RAMERRSTATUS = 0x1U;
1000 
1001         \textcolor{comment}{/* clear status flags for ESM group1 channels 26 and 28 */}
1002         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x14000000U;
1003     \}
1004 
1005     \textcolor{comment}{/* enable writes to ECC RAM, enable ECC error response */}
1006     tcram1REG->RAMCTRL = 0x0005010AU;
1007     tcram2REG->RAMCTRL = 0x0005010AU;
1008 
1009     \textcolor{comment}{/* cause a 2-bit ECC error */}
1010     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
1011     tcramB2bitError ^= 0x3U;
1012     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
1013 
1014     \textcolor{comment}{/* read from location with 2-bit ECC error this will cause a data abort to be generated */}
1015     ramread = tcramB2bit;
1016 
1017     \textcolor{comment}{/* delay before restoring the ram value */}
1018     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
1019     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
1020     \textcolor{keywordflow}{for}(i=0U;i<10U;i++)
1021     \{
1022     \}\textcolor{comment}{/* Wait */}
1023 
1024     regread = tcram1REG->RAMUERRADDR;
1025     regread = tcram2REG->RAMUERRADDR;
1026 
1027     \textcolor{comment}{/* disable writes to ECC RAM */}
1028     tcram1REG->RAMCTRL = 0x0005000AU;
1029     tcram2REG->RAMCTRL = 0x0005000AU;
1030 
1031     \textcolor{comment}{/* Compute correct ECC */}
1032     tcramB1bit = tcramB1\_bk;
1033     tcramB2bit = tcramB2\_bk;
1034 
1035 \textcolor{comment}{/* USER CODE BEGIN (39) */}
1036 \textcolor{comment}{/* USER CODE END */}
1037 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a012696be6fb67f7debf6f1ff6f9e3331}\label{sys__selftest_8h_a012696be6fb67f7debf6f1ff6f9e3331}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+Clock\+Monitor@{check\+Clock\+Monitor}}
\index{check\+Clock\+Monitor@{check\+Clock\+Monitor}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+Clock\+Monitor()}{checkClockMonitor()}}
{\footnotesize\ttfamily void check\+Clock\+Monitor (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check clock monitor failure detection logic. 

This function checks clock monitor failure detection logic. 

Definition at line 2114 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, selftest\+Fail\+Notification(), and system\+R\+E\+G1.


\begin{DoxyCode}
2115 \{
2116     uint32 ghvsrc\_bk;
2117 
2118     \textcolor{comment}{/* Enable clock monitor range detection circuitry */}
2119     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CLKTEST |= 0x03000000U;
2120 
2121     \textcolor{comment}{/* Backup register GHVSRC */}
2122     ghvsrc\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC;
2123 
2124     \textcolor{comment}{/* Switch all clock domains to HF LPO */}
2125     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = 0x05050005U;
2126 
2127     \textcolor{comment}{/* Disable oscillator to cause a oscillator fail */}
2128     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISSET = 0x1U;
2129 
2130     \textcolor{comment}{/* Wait till oscillator fail flag is set */}
2131     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2132     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT & 0x1U) == 0U)
2133     \{
2134     \} \textcolor{comment}{/* Wait */}
2135 
2136     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x800U) != 0x800U)
2137     \{
2138         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKCLOCKMONITOR\_FAIL1);
2139     \}
2140     \textcolor{keywordflow}{else}
2141     \{
2142         \textcolor{comment}{/* Clear ESM flag */}
2143         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x800U;
2144 
2145         \textcolor{comment}{/* Disable clock monitor range detection circuitry */}
2146         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CLKTEST &= ~(0x03000000U);
2147 
2148         \textcolor{comment}{/* Enable oscillator */}
2149         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISCLR = 0x1U;
2150 
2151         \textcolor{comment}{/* Wait until oscillator is enabled */}
2152         \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2153         \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSVSTAT & 0x3U) == 0U)
2154         \{
2155         \} \textcolor{comment}{/* Wait */}
2156 
2157         \textcolor{comment}{/* Clear oscillator fail flag and PLL slip flag if any*/}
2158         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT = 0x301U;
2159 
2160         \textcolor{comment}{/* Switch back all clock domains */}
2161         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = ghvsrc\_bk;
2162     \}
2163 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ad44409ae54516ba10303dd5c011f4fa6}\label{sys__selftest_8h_ad44409ae54516ba10303dd5c011f4fa6}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!checkefc\+Self\+Test@{checkefc\+Self\+Test}}
\index{checkefc\+Self\+Test@{checkefc\+Self\+Test}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{checkefc\+Self\+Test()}{checkefcSelfTest()}}
{\footnotesize\ttfamily boolean checkefc\+Self\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



E\+F\+U\+SE module self check Driver. 

\begin{DoxyReturn}{Returns}
Returns T\+R\+UE if E\+FC Selftest was a P\+A\+SS, else F\+A\+L\+SE
\end{DoxyReturn}
This function returns the status of efc\+Self\+Test. Note\+: This function can be called only after calling efc\+Self\+Test 

Definition at line 721 of file sys\+\_\+selftest.\+c.



References F\+A\+L\+SE.



Referenced by system\+Init().


\begin{DoxyCode}
722 \{
723 \textcolor{comment}{/* USER CODE BEGIN (31) */}
724 \textcolor{comment}{/* USER CODE END */}
725     \textcolor{keywordtype}{boolean} result = \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
726 
727     uint32 EFC\_PINS, EFC\_ERROR;
728     uint32 esmCh40Stat, esmCh41Stat = 0U;
729 
730     \textcolor{comment}{/* wait until EFC self-test is done */}
731     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
732     \textcolor{keywordflow}{while}((efcREG->PINS & EFC\_SELF\_TEST\_DONE) == 0U)
733     \{
734     \}\textcolor{comment}{/* Wait */}
735 
736     \textcolor{comment}{/* check if EFC self-test error occurred */}
737     EFC\_PINS = efcREG->PINS;
738     EFC\_ERROR = efcREG->ERROR;
739     \textcolor{keywordflow}{if}(((EFC\_PINS & EFC\_SELF\_TEST\_ERROR) == 0U) && ((EFC\_ERROR & 0x1FU) == 0U))
740     \{
741         \textcolor{comment}{/* check if EFC self-test error is set */}
742         esmCh40Stat = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x100U;
743         esmCh41Stat = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x200U;
744         \textcolor{keywordflow}{if} ((esmCh40Stat == 0U) && (esmCh41Stat == 0U))
745         \{
746             result = \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}};
747         \}
748     \}
749     \textcolor{keywordflow}{return} result;
750 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a02bb81fd1b585ba20d4c6e7ed427a4ac}\label{sys__selftest_8h_a02bb81fd1b585ba20d4c6e7ed427a4ac}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+Flash\+E\+CC@{check\+Flash\+E\+CC}}
\index{check\+Flash\+E\+CC@{check\+Flash\+E\+CC}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+Flash\+E\+C\+C()}{checkFlashECC()}}
{\footnotesize\ttfamily void check\+Flash\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check Flash E\+CC error detection logic. 

This function checks Flash E\+CC error detection logic. 

Definition at line 1047 of file sys\+\_\+selftest.\+c.



References flash\+W\+R\+EG.


\begin{DoxyCode}
1048 \{
1049     \textcolor{comment}{/* Routine to check operation of ECC logic inside CPU for accesses to program flash */}
1050     \textcolor{keyword}{volatile} uint32 flashread = 0U;
1051 
1052 \textcolor{comment}{/* USER CODE BEGIN (40) */}
1053 \textcolor{comment}{/* USER CODE END */}
1054 
1055     \textcolor{comment}{/* Flash Module ECC Response enabled */}
1056     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACCTRL1 = 0x000A060AU;
1057 
1058     \textcolor{comment}{/* Enable diagnostic mode and select diag mode 7 */}
1059     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00050007U;
1060 
1061     \textcolor{comment}{/* Select ECC diagnostic mode, single-bit to be corrupted */}
1062     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FPAROVR = 0x00005A01U;
1063 
1064     \textcolor{comment}{/* Set the trigger for the diagnostic mode */}
1065     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
1066 
1067     \textcolor{comment}{/* read a flash location from the mirrored memory map */}
1068     flashread = flashBadECC1;
1069 
1070     \textcolor{comment}{/* disable diagnostic mode */}
1071     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x000A0007U;
1072 
1073     \textcolor{comment}{/* this will have caused a single-bit error to be generated and corrected by CPU */}
1074     \textcolor{comment}{/* single-bit error not captured in flash module */}
1075     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */}
1076     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS & 0x2U) == 0U)
1077     \{
1078         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHECC\_FAIL1);
1079     \}
1080     \textcolor{keywordflow}{else}
1081     \{
1082         \textcolor{comment}{/* clear single-bit error flag */}
1083         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS = 0x2U;
1084 
1085         \textcolor{comment}{/* clear ESM flag */}
1086         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40U;
1087 
1088         \textcolor{comment}{/* Enable diagnostic mode and select diag mode 7 */}
1089         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00050007U;
1090 
1091         \textcolor{comment}{/* Select ECC diagnostic mode, two bits of ECC to be corrupted */}
1092         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FPAROVR = 0x00005A03U;
1093 
1094         \textcolor{comment}{/* Set the trigger for the diagnostic mode */}
1095         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
1096 
1097         \textcolor{comment}{/* read from flash location from mirrored memory map this will cause a data abort */}
1098         flashread = flashBadECC2;
1099 
1100         \textcolor{comment}{/* Read FUNCERRADD register */}
1101         flashread = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FUNCERRADD;
1102 
1103         \textcolor{comment}{/* disable diagnostic mode */}
1104         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x000A0007U;
1105     \}
1106 
1107 \textcolor{comment}{/* USER CODE BEGIN (41) */}
1108 \textcolor{comment}{/* USER CODE END */}
1109 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a239d7544f8bb38fc73056467dbeb9e7c}\label{sys__selftest_8h_a239d7544f8bb38fc73056467dbeb9e7c}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC@{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC}}
\index{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC@{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+Flash\+E\+E\+P\+R\+O\+M\+E\+C\+C()}{checkFlashEEPROMECC()}}
{\footnotesize\ttfamily void check\+Flash\+E\+E\+P\+R\+O\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check Flash E\+E\+P\+R\+OM E\+CC error detection logic. 

This function checks Flash E\+E\+P\+R\+OM E\+CC error detection logic. 

Definition at line 2173 of file sys\+\_\+selftest.\+c.



References flash\+W\+R\+EG, and selftest\+Fail\+Notification().


\begin{DoxyCode}
2174 \{
2175     uint32 ecc;
2176     \textcolor{keyword}{volatile} uint32 regread;
2177 
2178     \textcolor{comment}{/* Set Single Error Correction Threshold as 1 */}
2179     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EECTRL2 |= 1U;
2180 
2181     \textcolor{comment}{/* Enable EEPROM Emulation Error Profiling */}
2182     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EECTRL1 |= 0x00000100U;
2183 
2184     \textcolor{comment}{/* Load FEMU\_XX regs in order to generate ECC */}
2185     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUADDR = 0xF0200000U;
2186     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDMSW = 0U;
2187     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDLSW = 0U;
2188 
2189     \textcolor{comment}{/* ECC for the correct data*/}
2190     ecc = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUECC;
2191 
2192     \textcolor{comment}{/* Load data with 1 bit error */}
2193     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDMSW = 0U;
2194     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDLSW = 1U;
2195 
2196     \textcolor{comment}{/* Enable Diagnostic ECC data correction mode and select FEE SECDED for diagnostic testing */}
2197     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00055001U;
2198 
2199     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUECC = ecc;
2200 
2201     \textcolor{comment}{/* Diagnostic trigger */}
2202     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
2203 
2204     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */}
2205     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS & 0x1U) != 0x1U)
2206     \{
2207         \textcolor{comment}{/* No single bit error was detected */}
2208         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL1);
2209     \}
2210     \textcolor{keywordflow}{else}
2211     \{
2212         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x8U) != 0x8U)
2213         \{
2214             \textcolor{comment}{/* EEPROM single bit error not captured in ESM */}
2215             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL2);
2216         \}
2217         \textcolor{keywordflow}{else}
2218         \{
2219             \textcolor{comment}{/* Clear single bit error flag in flash wrapper */}
2220             \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS = 0xFU;
2221 
2222             \textcolor{comment}{/* Clear ESM flag */}
2223             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x8U;
2224         \}
2225     \}
2226 
2227     \textcolor{comment}{/* Load data with 2 bit error */}
2228     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDMSW = 0U;
2229     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUDLSW = 3U;
2230 
2231     \textcolor{comment}{/* Enable Diagnostic ECC data correction mode and select FEE SECDED for diagnostic testing */}
2232     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL = 0x00055001U;
2233 
2234     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEMUECC = ecc;
2235 
2236     \textcolor{comment}{/* Diagnostic trigger */}
2237     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FDIAGCTRL |= 0x01000000U;
2238 
2239     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */}
2240     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS & 0x100U) != 0x100U)
2241     \{
2242         \textcolor{comment}{/* No double bit error was detected */}
2243         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL3);
2244     \}
2245     \textcolor{keywordflow}{else}
2246     \{
2247         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x10U) != 0x10U)
2248         \{
2249             \textcolor{comment}{/* EEPROM double bit error not captured in ESM */}
2250             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKFLASHEEPROMECC\_FAIL4);
2251         \}
2252         \textcolor{keywordflow}{else}
2253         \{
2254             \textcolor{comment}{/* Clear uncorrectable error flag in flash wrapper */}
2255             \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EESTATUS = 0x1100U;
2256 
2257             \textcolor{comment}{/* Read EEUNCERRADD register */}
2258             regread = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->EEUNCERRADD;
2259 
2260             \textcolor{comment}{/* Clear ESM flag */}
2261             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x10U;
2262 
2263 
2264         \}
2265     \}
2266 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a08d6355b5f4052d4ef5d2d995032ba22}\label{sys__selftest_8h_a08d6355b5f4052d4ef5d2d995032ba22}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+P\+L\+L1\+Slip@{check\+P\+L\+L1\+Slip}}
\index{check\+P\+L\+L1\+Slip@{check\+P\+L\+L1\+Slip}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+P\+L\+L1\+Slip()}{checkPLL1Slip()}}
{\footnotesize\ttfamily void check\+P\+L\+L1\+Slip (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check P\+L\+L1 Slip detection logic. 

This function checks P\+L\+L1 Slip detection logic. 

Definition at line 2276 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, selftest\+Fail\+Notification(), and system\+R\+E\+G1.


\begin{DoxyCode}
2277 \{
2278     uint32 ghvsrc\_bk, pllctl1\_bk;
2279 
2280     \textcolor{comment}{/* Back up the the registers GHVSRC and PLLCTRL1 */}
2281     ghvsrc\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC;
2282     pllctl1\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1;
2283 
2284     \textcolor{comment}{/* Switch all clock domains to oscillator */}
2285     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = 0x00000000U;
2286 
2287     \textcolor{comment}{/* Disable Reset on PLL Slip and enable Bypass on PLL slip */}
2288     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 &= 0x1FFFFFFFU;
2289 
2290     \textcolor{comment}{/* Force a PLL Slip */}
2291     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 ^= 0x8000U;
2292 
2293     \textcolor{comment}{/* Wait till PLL slip flag is set */}
2294     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2295     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT & 0x300U) == 0U)
2296     \{
2297     \} \textcolor{comment}{/* Wait */}
2298 
2299     \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x400U) != 0x400U)
2300     \{
2301         \textcolor{comment}{/* ESM flag not set */}
2302         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKPLL1SLIP\_FAIL1);
2303     \}
2304     \textcolor{keywordflow}{else}
2305     \{
2306         \textcolor{comment}{/* Disable PLL1 */}
2307         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISSET = 0x2U;
2308 
2309         \textcolor{comment}{/* Wait till PLL1 is disabled */}
2310         \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2311         \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x2U) == 0U)
2312         \{
2313         \} \textcolor{comment}{/* Wait */}
2314 
2315         \textcolor{comment}{/* Restore the PLL multiplier value */}
2316         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 ^= 0x8000U;
2317 
2318         \textcolor{comment}{/* Enable PLL1 */}
2319         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISCLR = 0x2U;
2320 
2321         \textcolor{comment}{/* Wait till PLL1 is disabled */}
2322         \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2323         \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x2U) != 0U)
2324         \{
2325         \} \textcolor{comment}{/* Wait */}
2326 
2327         \textcolor{comment}{/* Switch back to the initial clock source */}
2328         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = ghvsrc\_bk;
2329 
2330         \textcolor{comment}{/* Clear PLL slip flag */}
2331         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT = 0x300U;
2332 
2333         \textcolor{comment}{/* Clear ESM flag */}
2334         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x400U;
2335 
2336         \textcolor{comment}{/* Restore the PLLCTL1 register */}
2337         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->PLLCTL1 = pllctl1\_bk;
2338     \}
2339 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_af5cf3a39340edcc591f7a1bd6a3ad021}\label{sys__selftest_8h_af5cf3a39340edcc591f7a1bd6a3ad021}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+P\+L\+L2\+Slip@{check\+P\+L\+L2\+Slip}}
\index{check\+P\+L\+L2\+Slip@{check\+P\+L\+L2\+Slip}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+P\+L\+L2\+Slip()}{checkPLL2Slip()}}
{\footnotesize\ttfamily void check\+P\+L\+L2\+Slip (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check P\+L\+L2 Slip detection logic. 

This function checks P\+L\+L2 Slip detection logic. 

Definition at line 2349 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, system\+R\+E\+G1, and system\+R\+E\+G2.


\begin{DoxyCode}
2350 \{
2351     uint32 ghvsrc\_bk;
2352 
2353     \textcolor{comment}{/* Back up the the register GHVSRC */}
2354     ghvsrc\_bk = \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC;
2355 
2356     \textcolor{comment}{/* Switch all clock domains to oscillator */}
2357     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = 0x00000000U;
2358     
2359     \textcolor{comment}{/* Force a PLL2 Slip */}
2360     \mbox{\hyperlink{reg__system_8h_aa7b03254a6e13afea4c05b2fe8b2186b}{systemREG2}}->PLLCTL3 ^= 0x8000U;
2361 
2362     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2363     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x400U) != 0x400U)
2364     \{
2365         \textcolor{comment}{/* Wait till ESM flag is set */}
2366     \}
2367 
2368     \textcolor{comment}{/* Disable PLL2 */}
2369     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISSET = 0x40U;
2370 
2371     \textcolor{comment}{/* Wait till PLL2 is disabled */}
2372     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2373     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x40U) == 0U)
2374     \{
2375     \} \textcolor{comment}{/* Wait */}
2376 
2377     \textcolor{comment}{/* Restore the PLL 2 multiplier value */}
2378     \mbox{\hyperlink{reg__system_8h_aa7b03254a6e13afea4c05b2fe8b2186b}{systemREG2}}->PLLCTL3 ^= 0x8000U;
2379 
2380     \textcolor{comment}{/* Enable PLL2 */}
2381     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDISCLR = 0x40U;
2382 
2383     \textcolor{comment}{/* Wait till PLL2 is disabled */}
2384     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2385     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->CSDIS & 0x40U) != 0U)
2386     \{
2387     \} \textcolor{comment}{/* Wait */}
2388 
2389     \textcolor{comment}{/* Switch back to the initial clock source */}
2390     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GHVSRC = ghvsrc\_bk;
2391 
2392     \textcolor{comment}{/* Clear PLL slip flag */}
2393     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->GBLSTAT = 0x300U;
2394 
2395     \textcolor{comment}{/* Clear ESM flag */}
2396     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x400U;
2397 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a85eb55d96d4a491e84a930dbea0e89a5}\label{sys__selftest_8h_a85eb55d96d4a491e84a930dbea0e89a5}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+R\+A\+M\+Addr\+Parity@{check\+R\+A\+M\+Addr\+Parity}}
\index{check\+R\+A\+M\+Addr\+Parity@{check\+R\+A\+M\+Addr\+Parity}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+R\+A\+M\+Addr\+Parity()}{checkRAMAddrParity()}}
{\footnotesize\ttfamily void check\+R\+A\+M\+Addr\+Parity (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+AM Address parity error detection and signaling mechanism. 

This function T\+C\+R\+AM Address parity error detection and signaling mechanism. 

Definition at line 2408 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2409 \{
2410     \textcolor{keyword}{register} uint64 ramread;
2411     \textcolor{keyword}{volatile} uint32 regread;
2412     uint32 tcram1ErrStat, tcram2ErrStat;
2413     
2414     \textcolor{comment}{/* Invert Address parity scheme */}
2415     tcram1REG->RAMCTRL = 0x0D05000AU;
2416     tcram2REG->RAMCTRL = 0x0D05000AU;
2417 
2418     \textcolor{comment}{/* Read from both RAM banks */}
2419     ramread = tcramA1bit;
2420     ramread = ramread | tcramB1bit; \textcolor{comment}{/* XOR-ing with ramread to avoid warnings */}
2421 
2422     \textcolor{comment}{/* Switch back to Address parity scheme */}
2423     tcram1REG->RAMCTRL = 0x0005000AU;
2424     tcram2REG->RAMCTRL = 0x0005000AU;
2425 
2426     \textcolor{comment}{/* Check for error status */}
2427     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x100U;
2428     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x100U;
2429     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2430     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2431     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) || (tcram2ErrStat == 0U))
2432     \{
2433         \textcolor{comment}{/* No Address parity error detected */}
2434         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMADDRPARITY\_FAIL1);
2435     \}
2436     \textcolor{keywordflow}{else}
2437     \{
2438         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] & 0x1400U) != 0x1400U)
2439         \{
2440             \textcolor{comment}{/* Address parity error not reported to ESM */}
2441             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMADDRPARITY\_FAIL2);
2442         \}
2443         \textcolor{keywordflow}{else}
2444         \{
2445             \textcolor{comment}{/* Clear Address parity error flag */}
2446             tcram1REG->RAMERRSTATUS = 0x300U;
2447             tcram2REG->RAMERRSTATUS = 0x300U;
2448 
2449             \textcolor{comment}{/* Clear ESM flag */}
2450             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] = 0x1400U;
2451 
2452             \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
2453             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
2454 
2455             regread = tcram1REG->RAMPERADDR;
2456             regread = tcram2REG->RAMPERADDR;
2457         \}
2458     \}
2459 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a421594cf13d3b5ca42435c5a5604721c}\label{sys__selftest_8h_a421594cf13d3b5ca42435c5a5604721c}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+R\+A\+M\+E\+CC@{check\+R\+A\+M\+E\+CC}}
\index{check\+R\+A\+M\+E\+CC@{check\+R\+A\+M\+E\+CC}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+R\+A\+M\+E\+C\+C()}{checkRAMECC()}}
{\footnotesize\ttfamily void check\+R\+A\+M\+E\+CC (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check T\+C\+R\+AM E\+CC error detection logic. 

This function checks T\+C\+R\+AM E\+CC error detection logic. 

Definition at line 2017 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2018 \{
2019     \textcolor{keyword}{volatile} uint64 ramread = 0U;
2020     \textcolor{keyword}{volatile} uint32 regread = 0U;
2021     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
2022     
2023     uint64 tcramA1\_bk = tcramA1bit;
2024     uint64 tcramB1\_bk = tcramB1bit;
2025     uint64 tcramA2\_bk = tcramA2bit;
2026     uint64 tcramB2\_bk = tcramB2bit;
2027 
2028     \textcolor{comment}{/* Clear RAMOCUUR before setting RAMTHRESHOLD register */}
2029     tcram1REG->RAMOCCUR = 0U;
2030     tcram2REG->RAMOCCUR = 0U;
2031 
2032     \textcolor{comment}{/* Set Single-bit Error Threshold Count as 1 */}
2033     tcram1REG->RAMTHRESHOLD = 1U;
2034     tcram2REG->RAMTHRESHOLD = 1U;
2035 
2036     \textcolor{comment}{/* Enable single bit error generation */}
2037     tcram1REG->RAMINTCTRL = 1U;
2038     tcram2REG->RAMINTCTRL = 1U;
2039 
2040     \textcolor{comment}{/* Enable writes to ECC RAM, enable ECC error response */}
2041     tcram1REG->RAMCTRL = 0x0005010AU;
2042     tcram2REG->RAMCTRL = 0x0005010AU;
2043 
2044     \textcolor{comment}{/* Force a single bit error in both the banks */}
2045     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
2046     tcramA1bitError ^= 1U;
2047     tcramB1bitError ^= 1U;
2048     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
2049 
2050     \textcolor{comment}{/* Read the corrupted data to generate single bit error */}
2051     ramread = tcramA1bit;
2052     ramread = tcramB1bit;
2053 
2054     \textcolor{comment}{/* Check for error status */}
2055     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x1U;
2056     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x1U;
2057     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2058     \textcolor{comment}{/*SAFETYMCUSW 139 S MR:13.7  <APPROVED> "LDRA Tool issue" */}
2059     \textcolor{keywordflow}{if}((tcram1ErrStat == 0U) || (tcram2ErrStat == 0U))
2060     \{
2061         \textcolor{comment}{/* TCRAM module does not reflect 1-bit error reported by CPU */}
2062         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMECC\_FAIL1);
2063     \}
2064     \textcolor{keywordflow}{else}
2065     \{
2066         \textcolor{keywordflow}{if}((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x14000000U) != 0x14000000U)
2067         \{
2068             \textcolor{comment}{/* TCRAM 1-bit error not flagged in ESM */}
2069             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMECC\_FAIL2);
2070         \}
2071         \textcolor{keywordflow}{else}
2072         \{
2073             \textcolor{comment}{/* Clear single bit error flag in TCRAM module */}
2074             tcram1REG->RAMERRSTATUS = 0x1U;
2075             tcram2REG->RAMERRSTATUS = 0x1U;
2076 
2077             \textcolor{comment}{/* Clear ESM status */}
2078             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x14000000U;
2079         \}
2080     \}
2081 
2082     \textcolor{comment}{/* Force a double bit error in both the banks */}
2083     \mbox{\hyperlink{sys__core_8h_a099bf5e5169755b08ae68126dec3172e}{\_coreDisableRamEcc\_}}();
2084     tcramA2bitError ^= 3U;
2085     tcramB2bitError ^= 3U;
2086     \mbox{\hyperlink{sys__core_8h_a058f0ace94e7ff9afbd9590568a3da99}{\_coreEnableRamEcc\_}}();
2087 
2088     \textcolor{comment}{/* Read the corrupted data to generate double bit error */}
2089     ramread = tcramA2bit;
2090     ramread = tcramB2bit;
2091 
2092     regread = tcram1REG->RAMUERRADDR;
2093     regread = tcram2REG->RAMUERRADDR;
2094 
2095     \textcolor{comment}{/* disable writes to ECC RAM */}
2096     tcram1REG->RAMCTRL = 0x0005000AU;
2097     tcram2REG->RAMCTRL = 0x0005000AU;
2098 
2099     \textcolor{comment}{/* Compute correct ECC */}
2100     tcramA1bit = tcramA1\_bk;
2101     tcramB1bit = tcramB1\_bk;
2102     tcramA2bit = tcramA2\_bk;
2103     tcramB2bit = tcramB2\_bk;
2104 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a7e5bbec947e5db02df2bda4ba2230677}\label{sys__selftest_8h_a7e5bbec947e5db02df2bda4ba2230677}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!check\+R\+A\+M\+U\+E\+R\+R\+Test@{check\+R\+A\+M\+U\+E\+R\+R\+Test}}
\index{check\+R\+A\+M\+U\+E\+R\+R\+Test@{check\+R\+A\+M\+U\+E\+R\+R\+Test}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{check\+R\+A\+M\+U\+E\+R\+R\+Test()}{checkRAMUERRTest()}}
{\footnotesize\ttfamily void check\+R\+A\+M\+U\+E\+R\+R\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Run R\+AM test. 

This function runs R\+AM test to test the redundant address decode and compare logic. 

Definition at line 2469 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2470 \{
2471     uint32 tcram1ErrStat, tcram2ErrStat = 0U;
2472 
2473     \textcolor{comment}{/* Trigger equality check */}
2474     tcram1REG->RAMTEST = 0x018AU;
2475     tcram2REG->RAMTEST = 0x018AU;
2476 
2477     \textcolor{comment}{/* Wait till test is completed */}
2478     \textcolor{keywordflow}{while}(tcram1REG->RAMTEST != 0x008AU)
2479     \{
2480     \} \textcolor{comment}{/* Wait */}
2481     \textcolor{keywordflow}{while}(tcram2REG->RAMTEST != 0x008AU)
2482     \{
2483     \} \textcolor{comment}{/* Wait */}
2484 
2485     \textcolor{comment}{/* Check for error status */}
2486     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x10U;
2487     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x10U;
2488     \textcolor{keywordflow}{if}((tcram1ErrStat == 0x10U) || (tcram2ErrStat == 0x10U))
2489     \{
2490         \textcolor{comment}{/* test failed */}
2491         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMUERRTEST\_FAIL1);
2492     \}
2493 
2494     \textcolor{comment}{/* Trigger inequality check */}
2495     tcram1REG->RAMTEST = 0x014AU;
2496     tcram2REG->RAMTEST = 0x014AU;
2497 
2498     \textcolor{comment}{/* Wait till test is completed */}
2499     \textcolor{keywordflow}{while}(tcram1REG->RAMTEST != 0x004AU)
2500     \{
2501     \}\textcolor{comment}{/* Wait */}
2502     \textcolor{keywordflow}{while}(tcram2REG->RAMTEST != 0x004AU)
2503     \{
2504     \}\textcolor{comment}{/* Wait */}
2505 
2506     tcram1ErrStat = tcram1REG->RAMERRSTATUS & 0x10U;
2507     tcram2ErrStat = tcram2REG->RAMERRSTATUS & 0x10U;
2508     \textcolor{keywordflow}{if}((tcram1ErrStat == 0x10U) || (tcram2ErrStat == 0x10U))
2509     \{
2510         \textcolor{comment}{/* test failed */}
2511         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(CHECKRAMUERRTEST\_FAIL2);
2512     \}
2513     \textcolor{keywordflow}{else}
2514     \{
2515         tcram1REG->RAMERRSTATUS = 0x4U;
2516         tcram2REG->RAMERRSTATUS = 0x4U;
2517 
2518         \textcolor{comment}{/* Clear ESM flag */}
2519         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[1U] = 0x140U;
2520         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SSR2 = 0x140U;
2521         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
2522     \}
2523 
2524     \textcolor{comment}{/* Disable RAM test mode */}
2525     tcram1REG->RAMTEST = 0x5U;
2526     tcram2REG->RAMTEST = 0x5U;
2527 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a27cee1191b0027e90cbb9c66983596b9}\label{sys__selftest_8h_a27cee1191b0027e90cbb9c66983596b9}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!cpu\+Self\+Test@{cpu\+Self\+Test}}
\index{cpu\+Self\+Test@{cpu\+Self\+Test}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{cpu\+Self\+Test()}{cpuSelfTest()}}
{\footnotesize\ttfamily void cpu\+Self\+Test (\begin{DoxyParamCaption}\item[{uint32}]{no\+\_\+of\+\_\+intervals,  }\item[{uint32}]{max\+\_\+timeout,  }\item[{boolean}]{restart\+\_\+test }\end{DoxyParamCaption})}



C\+PU self test Driver. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em no\+\_\+of\+\_\+intervals} & -\/ Number of Test Intervals to be \\
\hline
\mbox{\tt in}  & {\em max\+\_\+timeout} & -\/ Maximum Timeout to complete selected test Intervals \\
\hline
\mbox{\tt in}  & {\em restart\+\_\+test} & -\/ Restart the test from Interval 0 or Continue from where it stopped.\\
\hline
\end{DoxyParams}
This function is called to perform C\+PU self test using S\+TC module. 

Definition at line 266 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
267 \{
268     \textcolor{keyword}{volatile} uint32 i = 0U;
269 
270 \textcolor{comment}{/* USER CODE BEGIN (11) */}
271 \textcolor{comment}{/* USER CODE END */}
272 
273     \textcolor{comment}{/* Run specified no of test intervals starting from interval 0 */}
274     \textcolor{comment}{/* Start test from interval 0 or continue the test. */}
275     stcREG->STCGCR0 = no\_of\_intervals << 16U;
276     \textcolor{keywordflow}{if}(restart\_test)
277     \{
278         stcREG->STCGCR0 |= 0x00000001U;
279     \}
280 
281     \textcolor{comment}{/* Configure Maximum time-out period */}
282     stcREG->STCTPR = max\_timeout;
283 
284     \textcolor{comment}{/* wait for 16 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
285     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
286     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
287     \textcolor{keywordflow}{for} (i=0U; i<(16U + (16U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
288 
289     \textcolor{comment}{/* Enable self-test */}
290     stcREG->STCGCR1 = 0xAU;
291 
292 \textcolor{comment}{/* USER CODE BEGIN (12) */}
293 \textcolor{comment}{/* USER CODE END */}
294     \textcolor{comment}{/* Idle the CPU so that the self-test can start */}
295 
296     \mbox{\hyperlink{sys__core_8h_a9ac3ba78e1c8af4d0b6a5381b11858b2}{\_gotoCPUIdle\_}}();
297 
298 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a932e8fff5749ae8038f0fbbe9029ec44}\label{sys__selftest_8h_a932e8fff5749ae8038f0fbbe9029ec44}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!cpu\+Self\+Test\+Fail@{cpu\+Self\+Test\+Fail}}
\index{cpu\+Self\+Test\+Fail@{cpu\+Self\+Test\+Fail}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{cpu\+Self\+Test\+Fail()}{cpuSelfTestFail()}}
{\footnotesize\ttfamily void cpu\+Self\+Test\+Fail (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



C\+PU Self test check fail service routine. 

This function is called if C\+PU Self test check fail. 

Definition at line 1159 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1160 \{
1161 \textcolor{comment}{/* USER CODE BEGIN (46) */}
1162 \textcolor{comment}{/* USER CODE END */}
1163     \textcolor{comment}{/* CPU self-test has failed.}
1164 \textcolor{comment}{     * CPU operation is not reliable.}
1165 \textcolor{comment}{     */}
1166 \textcolor{comment}{/* USER CODE BEGIN (47) */}
1167 \textcolor{comment}{/* USER CODE END */}
1168     \textcolor{comment}{/*SAFETYMCUSW 5 C MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the user
       codes above and below" */}
1169     \textcolor{comment}{/*SAFETYMCUSW 26 S MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1170     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1171     \textcolor{keywordflow}{for}(;;)
1172     \{
1173     \}\textcolor{comment}{/* Wait */}
1174 \textcolor{comment}{/* USER CODE BEGIN (48) */}
1175 \textcolor{comment}{/* USER CODE END */}
1176 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a58597c65615a9a0f05d48135ad48c0d6}\label{sys__selftest_8h_a58597c65615a9a0f05d48135ad48c0d6}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!custom\+\_\+dabort@{custom\+\_\+dabort}}
\index{custom\+\_\+dabort@{custom\+\_\+dabort}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{custom\+\_\+dabort()}{custom\_dabort()}}
{\footnotesize\ttfamily void custom\+\_\+dabort (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Custom Data abort routine for the application. 

Custom Data abort routine for the application. 

Definition at line 1116 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1117 \{
1118     \textcolor{comment}{/* Need custom data abort handler here.}
1119 \textcolor{comment}{     * This data abort is not caused due to diagnostic checks of flash and TCRAM ECC logic.}
1120 \textcolor{comment}{     */}
1121 \textcolor{comment}{/* USER CODE BEGIN (42) */}
1122 \textcolor{comment}{/* USER CODE END */}
1123 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a15b66d583493adf7dc0ce8e3a89f00f5}\label{sys__selftest_8h_a15b66d583493adf7dc0ce8e3a89f00f5}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!disable\+Parity@{disable\+Parity}}
\index{disable\+Parity@{disable\+Parity}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{disable\+Parity()}{disableParity()}}
{\footnotesize\ttfamily void disable\+Parity (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Disable peripheral R\+AM parity. 

This function disables R\+AM parity for all peripherals for which R\+AM parity check is enabled. This function is called after memory\+Init in the startup 

Definition at line 2972 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2973 \{
2974     DMA\_PARCR = 0x5U;                      \textcolor{comment}{/* Disable DMA RAM parity */}
2975     VIM\_PARCTL = 0x5U;                     \textcolor{comment}{/* Disable VIM RAM parity */}
2976     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = ((uint32)0x5U << 10U) | 1U;    \textcolor{comment}{/* Disable CAN1 RAM parity */}
2977     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = ((uint32)0x5U << 10U) | 1U;    \textcolor{comment}{/* Disable CAN2 RAM parity */}
2978     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = ((uint32)0x5U << 10U) | 1U;    \textcolor{comment}{/* Disable CAN3 RAM parity */}
2979     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0x5U;                 \textcolor{comment}{/* Disable ADC1 RAM parity */}
2980     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0x5U;                 \textcolor{comment}{/* Disable ADC2 RAM parity */}
2981     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x5U;                   \textcolor{comment}{/* Disable HET1 RAM parity */}
2982     htuREG1->PCR = 0x5U;                   \textcolor{comment}{/* Disable HTU1 RAM parity */}
2983     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x5U;                   \textcolor{comment}{/* Disable HET2 RAM parity */}
2984     htuREG2->PCR = 0x5U;                   \textcolor{comment}{/* Disable HTU2 RAM parity */}
2985 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_add4aed7c0b3711f72c9228a92effa518}\label{sys__selftest_8h_add4aed7c0b3711f72c9228a92effa518}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!dma\+Parity\+Check@{dma\+Parity\+Check}}
\index{dma\+Parity\+Check@{dma\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{dma\+Parity\+Check()}{dmaParityCheck()}}
{\footnotesize\ttfamily void dma\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check D\+MA control packet R\+AM parity error detection and signaling mechanism. 

Routine to check D\+MA control packet R\+AM parity error detection and signaling mechanism 

Definition at line 1244 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1245 \{
1246     \textcolor{keyword}{volatile} uint32 dmaread = 0U;
1247     uint32 dmaparcr\_bk = DMA\_PARCR;
1248 
1249 \textcolor{comment}{/* USER CODE BEGIN (51) */}
1250 \textcolor{comment}{/* USER CODE END */}
1251 
1252     \textcolor{comment}{/* Enable parity checking and parity test mode */}
1253     DMA\_PARCR = 0x0000010AU;
1254 
1255     \textcolor{comment}{/* Flip a bit in DMA RAM parity location */}
1256     DMARAMPARLOC ^= 0x1U;
1257 
1258     \textcolor{comment}{/* Disable parity test mode */}
1259     DMA\_PARCR = 0x0000000AU;
1260 
1261     \textcolor{comment}{/* Cause parity error */}
1262     dmaread = DMARAMLOC;
1263 
1264     \textcolor{comment}{/* Check if ESM group1 channel 3 is flagged */}
1265     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x8U) == 0U)
1266     \{
1267         \textcolor{comment}{/* DMA RAM parity error was not flagged to ESM. */}
1268         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(DMAPARITYCHECK\_FAIL1);
1269     \}
1270     \textcolor{keywordflow}{else}
1271     \{
1272         \textcolor{comment}{/* clear DMA parity error flag in DMA */}
1273         DMA\_PARADDR = 0x01000000U;
1274 
1275         \textcolor{comment}{/* clear ESM group1 channel 3 flag */}
1276         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x8U;
1277 
1278         \textcolor{comment}{/* Enable parity checking and parity test mode */}
1279         DMA\_PARCR = 0x0000010AU;
1280 
1281         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1282         DMARAMPARLOC ^= 0x1U;
1283     \}
1284 
1285     \textcolor{comment}{/* Restrore Parity Control register */}
1286     DMA\_PARCR = dmaparcr\_bk;
1287 
1288 \textcolor{comment}{/* USER CODE BEGIN (52) */}
1289 \textcolor{comment}{/* USER CODE END */}
1290 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a646eb27315f3ce47edde97c563389f76}\label{sys__selftest_8h_a646eb27315f3ce47edde97c563389f76}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!efc\+Check@{efc\+Check}}
\index{efc\+Check@{efc\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{efc\+Check()}{efcCheck()}}
{\footnotesize\ttfamily uint32 efc\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



E\+F\+U\+SE module self check Driver. 

\begin{DoxyReturn}{Returns}
Returns 0 if no error was detected during autoload and Stuck At Zero Test passed 1 if no error was detected during autoload but Stuck At Zero Test failed 2 if there was a single-\/bit error detected during autoload 3 if some other error occurred during autoload
\end{DoxyReturn}
This function self checks the E\+F\+U\+SE module. 

Definition at line 582 of file sys\+\_\+selftest.\+c.



Referenced by system\+Init().


\begin{DoxyCode}
583 \{
584     uint32 efcStatus = 0U;
585     uint32 status;
586     
587 \textcolor{comment}{/* USER CODE BEGIN (27) */}
588 \textcolor{comment}{/* USER CODE END */}
589 
590     \textcolor{comment}{/* read the EFC Error Status Register */}
591     efcStatus = efcREG->ERROR;
592 
593 \textcolor{comment}{/* USER CODE BEGIN (28) */}
594 \textcolor{comment}{/* USER CODE END */}
595 
596     \textcolor{keywordflow}{if} (efcStatus == 0x0U)
597     \{
598         \textcolor{comment}{/* run stuck-at-zero test and check if it passed */}
599         \textcolor{keywordflow}{if} (\mbox{\hyperlink{sys__selftest_8c_a9973f032c29389602b684d30ea390fad}{efcStuckZeroTest}}()== \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}})
600         \{
601             \textcolor{comment}{/* start EFC ECC logic self-test */}
602             \mbox{\hyperlink{sys__selftest_8c_afd6cec31a44e7c8e325a744e9bcbf601}{efcSelfTest}}();
603             status = 0U;
604         \}
605         \textcolor{keywordflow}{else}
606         \{
607             \textcolor{comment}{/* EFC output is stuck-at-zero, device operation unreliable */}
608             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(EFCCHECK\_FAIL1);
609             status = 1U;
610         \}
611     \}
612     \textcolor{comment}{/* EFC Error Register is not zero */}
613     \textcolor{keywordflow}{else}
614     \{
615         \textcolor{comment}{/* one-bit error detected during autoload */}
616         \textcolor{keywordflow}{if} (efcStatus == 0x15U)
617         \{
618             \textcolor{comment}{/* start EFC ECC logic self-test */}
619             \mbox{\hyperlink{sys__selftest_8c_afd6cec31a44e7c8e325a744e9bcbf601}{efcSelfTest}}();
620             status = 2U;
621         \}
622         \textcolor{keywordflow}{else}
623         \{
624             \textcolor{comment}{/* Some other EFC error was detected */}
625             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(EFCCHECK\_FAIL1);
626             status = 3U;
627         \}
628     \}
629     \textcolor{keywordflow}{return} status;
630 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ac76ed167d7b4b27eedea0eb37de6acc2}\label{sys__selftest_8h_ac76ed167d7b4b27eedea0eb37de6acc2}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!efc\+Get\+Config\+Value@{efc\+Get\+Config\+Value}}
\index{efc\+Get\+Config\+Value@{efc\+Get\+Config\+Value}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{efc\+Get\+Config\+Value()}{efcGetConfigValue()}}
{\footnotesize\ttfamily void efc\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structefc__config__reg}{efc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2725 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2726 \{
2727     \textcolor{keywordflow}{if} (type == InitialValue)
2728     \{
2729         config\_reg->CONFIG\_BOUNDARY = EFC\_BOUNDARY\_CONFIGVALUE;
2730         config\_reg->CONFIG\_PINS = EFC\_PINS\_CONFIGVALUE;
2731         config\_reg->CONFIG\_SELFTESTCYCLES = EFC\_SELFTESTCYCLES\_CONFIGVALUE;
2732         config\_reg->CONFIG\_SELFTESTSIGN = EFC\_SELFTESTSIGN\_CONFIGVALUE;
2733     \}
2734     \textcolor{keywordflow}{else}
2735     \{
2736     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2737         config\_reg->CONFIG\_BOUNDARY = efcREG->BOUNDARY;
2738         config\_reg->CONFIG\_PINS = efcREG->PINS;
2739         config\_reg->CONFIG\_SELFTESTCYCLES = efcREG->SELF\_TEST\_CYCLES;
2740         config\_reg->CONFIG\_SELFTESTSIGN = efcREG->SELF\_TEST\_SIGN;
2741     \}
2742 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_afd6cec31a44e7c8e325a744e9bcbf601}\label{sys__selftest_8h_afd6cec31a44e7c8e325a744e9bcbf601}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!efc\+Self\+Test@{efc\+Self\+Test}}
\index{efc\+Self\+Test@{efc\+Self\+Test}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{efc\+Self\+Test()}{efcSelfTest()}}
{\footnotesize\ttfamily void efc\+Self\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



E\+F\+U\+SE module self check Driver. 

This function self checks the E\+F\+S\+UE module. 

Definition at line 697 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
698 \{
699 \textcolor{comment}{/* USER CODE BEGIN (30) */}
700 \textcolor{comment}{/* USER CODE END */}
701     \textcolor{comment}{/* configure self-test cycles */}
702     efcREG->SELF\_TEST\_CYCLES = 0x258U;
703 
704     \textcolor{comment}{/* configure self-test signature */}
705     efcREG->SELF\_TEST\_SIGN = 0x5362F97FU;
706 
707     \textcolor{comment}{/* configure boundary register to start ECC self-test */}
708     efcREG->BOUNDARY = 0x0000200FU;
709 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a9973f032c29389602b684d30ea390fad}\label{sys__selftest_8h_a9973f032c29389602b684d30ea390fad}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!efc\+Stuck\+Zero\+Test@{efc\+Stuck\+Zero\+Test}}
\index{efc\+Stuck\+Zero\+Test@{efc\+Stuck\+Zero\+Test}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{efc\+Stuck\+Zero\+Test()}{efcStuckZeroTest()}}
{\footnotesize\ttfamily boolean efc\+Stuck\+Zero\+Test (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Checks to see if the E\+F\+U\+SE Stuck at zero test is completed successfully. 

\begin{DoxyReturn}{Returns}
1 if E\+F\+U\+SE Stuck at zero test completed, otherwise 0.
\end{DoxyReturn}
Checks to see if the E\+F\+U\+SE Stuck at zero test is completed successfully. 

Definition at line 641 of file sys\+\_\+selftest.\+c.



References F\+A\+L\+SE.


\begin{DoxyCode}
642 \{
643 \textcolor{comment}{/* USER CODE BEGIN (29) */}
644 \textcolor{comment}{/* USER CODE END */}
645 
646     uint32 ESM\_ESTATUS4, ESM\_ESTATUS1;
647 
648     \textcolor{keywordtype}{boolean} result = \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
649     uint32 error\_checks = EFC\_INSTRUCTION\_INFO\_EN  |
650                                   EFC\_INSTRUCTION\_ERROR\_EN |
651                                   EFC\_AUTOLOAD\_ERROR\_EN      |
652                                   EFC\_SELF\_TEST\_ERROR\_EN   ;
653 
654     \textcolor{comment}{/* configure the output enable for auto load error , instruction info,}
655 \textcolor{comment}{         instruction error, and self test error using boundary register}
656 \textcolor{comment}{         and drive values one across all the errors */}
657     efcREG->BOUNDARY = ((uint32)OUTPUT\_ENABLE | error\_checks);
658 
659     \textcolor{comment}{/* Read from the pin register. This register holds the current values}
660 \textcolor{comment}{         of above errors. This value should be 0x5c00.If not at least one of}
661 \textcolor{comment}{         the above errors is stuck at 0. */}
662     \textcolor{keywordflow}{if} ((efcREG->PINS & 0x5C00U) == 0x5C00U)
663     \{
664         ESM\_ESTATUS4 = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U];
665         ESM\_ESTATUS1 = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U];
666         \textcolor{comment}{/* check if the ESM group1 channel 41 is set and group3 channel 1 is set */}
667         \textcolor{keywordflow}{if} (((ESM\_ESTATUS4 & 0x200U) == 0x200U) && ((ESM\_ESTATUS1 & 0x2U) == 0x2U))
668         \{
669            \textcolor{comment}{/* stuck-at-zero test passed */}
670            result = \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}};
671         \}
672     \}
673 
674     \textcolor{comment}{/* put the pins back low */}
675     efcREG->BOUNDARY = OUTPUT\_ENABLE;
676 
677     \textcolor{comment}{/* clear group1 flag */}
678     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x200U;
679 
680     \textcolor{comment}{/* clear group3 flag */}
681     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U] = 0x2U;
682 
683     \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
684     \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
685 
686     \textcolor{keywordflow}{return} result;
687 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_af9ecd48548d7a3d98d5dcc44d1e7ca51}\label{sys__selftest_8h_af9ecd48548d7a3d98d5dcc44d1e7ca51}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!enable\+Parity@{enable\+Parity}}
\index{enable\+Parity@{enable\+Parity}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{enable\+Parity()}{enableParity()}}
{\footnotesize\ttfamily void enable\+Parity (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Enable peripheral R\+AM parity. 

This function enables R\+AM parity for all peripherals for which R\+AM parity check is enabled. This function is called before memory\+Init in the startup 

Definition at line 2949 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2950 \{
2951     DMA\_PARCR = 0xAU;                      \textcolor{comment}{/* Enable DMA RAM parity */}
2952     VIM\_PARCTL = 0xAU;                     \textcolor{comment}{/* Enable VIM RAM parity */}
2953     \mbox{\hyperlink{reg__can_8h_a7a0d043070590fc91cfa3c0e39379b19}{canREG1}}->CTL = ((uint32)0xAU << 10U) | 1U;    \textcolor{comment}{/* Enable CAN1 RAM parity */}
2954     \mbox{\hyperlink{reg__can_8h_a6c499bb0c4a06d96ec7d4264e8e943f8}{canREG2}}->CTL = ((uint32)0xAU << 10U) | 1U;    \textcolor{comment}{/* Enable CAN2 RAM parity */}
2955     \mbox{\hyperlink{reg__can_8h_abf99eb1b78d010fcafc7570446168e94}{canREG3}}->CTL = ((uint32)0xAU << 10U) | 1U;    \textcolor{comment}{/* Enable CAN3 RAM parity */}
2956     \mbox{\hyperlink{reg__adc_8h_a3b9540af9f841ba3127f14b1c9208c57}{adcREG1}}->PARCR = 0xAU;                 \textcolor{comment}{/* Enable ADC1 RAM parity */}
2957     \mbox{\hyperlink{reg__adc_8h_a0e365b42d026f7ee8160336379101e86}{adcREG2}}->PARCR = 0xAU;                 \textcolor{comment}{/* Enable ADC2 RAM parity */}
2958     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0xAU;                   \textcolor{comment}{/* Enable HET1 RAM parity */}
2959     htuREG1->PCR = 0xAU;                   \textcolor{comment}{/* Enable HTU1 RAM parity */}
2960     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0xAU;                   \textcolor{comment}{/* Enable HET2 RAM parity */}
2961     htuREG2->PCR = 0xAU;                   \textcolor{comment}{/* Enable HTU2 RAM parity */}
2962 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a1f3b71a00b6347cb5f7f6eb922c36c9e}\label{sys__selftest_8h_a1f3b71a00b6347cb5f7f6eb922c36c9e}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4@{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4}}
\index{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4@{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4()}{errata\_PBIST\_4()}}
{\footnotesize\ttfamily void errata\+\_\+\+P\+B\+I\+S\+T\+\_\+4 (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Workaround for the Errata P\+B\+I\+ST\#4. 

This function is workaround for Errata P\+B\+I\+ST\#4. This function is designed to initialize the R\+O\+Ms using the P\+B\+I\+ST controller. The C\+PU will configure the P\+B\+I\+ST controller to test the P\+B\+I\+ST R\+OM and S\+TC R\+OM. This function should be called at startup after system init before using the R\+O\+Ms.

\begin{DoxyNote}{Note}
\+: This Function uses register\textquotesingle{}s which are not exposed to users through T\+RM , to run custom algorithm. User can use this function as Black box. 
\end{DoxyNote}


Definition at line 2785 of file sys\+\_\+selftest.\+c.



References \+\_\+pmu\+Enable\+Counters\+Global\+\_\+(), \+\_\+pmu\+Get\+Cycle\+Count\+\_\+(), \+\_\+pmu\+Reset\+Counters\+\_\+(), \+\_\+pmu\+Start\+Counters\+\_\+(), \+\_\+pmu\+Stop\+Counters\+\_\+(), and pmu\+C\+Y\+C\+L\+E\+\_\+\+C\+O\+U\+N\+T\+ER.


\begin{DoxyCode}
2786 \{
2787     \textcolor{keyword}{volatile} uint32 i = 0U;
2788     uint8 ROM\_count;
2789     sint32 PBIST\_wait\_done\_loop;
2790     uint32 pmuCalibration, pmuCount;
2791 
2792     \textcolor{comment}{/* PMU calibration */}
2793     \mbox{\hyperlink{sys__pmu_8h_a6bcb569866117b8d50c05b8d992cb3e0}{\_pmuEnableCountersGlobal\_}}();
2794     \mbox{\hyperlink{sys__pmu_8h_a21f3fc4ef80d58b22d0545a5c08f230e}{\_pmuResetCounters\_}}();
2795     \mbox{\hyperlink{sys__pmu_8h_a05119721bf5533e9271717127c18c22c}{\_pmuStartCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2796     \mbox{\hyperlink{sys__pmu_8h_abab4f00952caa5d6596db0e6de0f445c}{\_pmuStopCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2797     pmuCalibration=\mbox{\hyperlink{sys__pmu_8h_afd1c5a6e4a8806b15d4e8f72bd33fa16}{\_pmuGetCycleCount\_}}();
2798 
2799     \textcolor{comment}{/* ROM\_init Setup using special reserved registers as part of errata fix */}
2800     \textcolor{comment}{/* (Only to be used in this function) */}
2801     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF0400U = 0x0000000AU;
2802     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF040CU = 0x0000EE0AU;
2803 
2804     \textcolor{comment}{/* Loop for Executing PBIST ROM and STC ROM */}
2805     \textcolor{keywordflow}{for} (ROM\_count = 0U; ROM\_count < 2U; ROM\_count++)
2806     \{
2807         PBIST\_wait\_done\_loop = 0;
2808     
2809         \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
2810         pbistREG->PACT = 0x0U;
2811         
2812         \textcolor{comment}{/* PBIST Clocks did not disable */}
2813         \textcolor{keywordflow}{if}(pbistREG->PACT != 0x0U ) 
2814         \{
2815             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL3);
2816         \}
2817         \textcolor{keywordflow}{else}
2818         \{
2819             \textcolor{comment}{/* PBIST ROM clock frequency = HCLK frequency /2 */}
2820             \textcolor{comment}{/* Disable memory self controller */}
2821             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x00000105U;
2822             
2823             \textcolor{comment}{/* Disable Memory Initialization controller */}
2824             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
2825 
2826             \textcolor{comment}{/* Enable memory self controller */}
2827             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x0000010AU;                               
2828 
2829             \textcolor{comment}{/* Clear PBIST Done */}
2830             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT = 0x1U;
2831             
2832             \textcolor{comment}{/* Enable PBIST controller */}
2833             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA = 0x1U;
2834 
2835             \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
2836             \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */} 
2837             \textcolor{comment}{/* wait for 32 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
2838             \textcolor{keywordflow}{for} (i=0U; i<(32U + (32U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
2839 
2840             \textcolor{comment}{/* Enable PBIST clocks and ROM clock */}
2841             pbistREG->PACT = 0x3U;
2842 
2843             \textcolor{comment}{/* CPU control of PBIST */}
2844             pbistREG->DLR = 0x10U;
2845 
2846             \textcolor{comment}{/* Load PBIST ALGO to initialize the ROMs */}
2847             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE400U = 0x00000001U;
2848             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE440U = 0x00000025U;
2849             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE404U = 0x62400001U;
2850             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE444U = 0x00000004U;
2851             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE408U = 0x00068003U;
2852             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE448U = 0x00000000U;
2853             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE40CU = 0x00000004U;
2854             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE44CU = 0x00006860U;
2855             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE410U = 0x00000000U;
2856             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE450U = 0x00000001U;
2857             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE540U = 0x000003E8U;
2858             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE550U = 0x00000001U;
2859             *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE530U = 0x00000000U;
2860             
2861             \textcolor{comment}{/* SELECT ROM */}
2862             \textcolor{keywordflow}{if} (ROM\_count == 1U)
2863             \{   
2864                 \textcolor{comment}{/* SELECT PBIST ROM */}          
2865                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE520U = 0x00000002U;
2866                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE524U = 0x00000000U;
2867                 pbistREG->RAMT                  = 0x01002008U;
2868             \} 
2869             \textcolor{keywordflow}{else}
2870             \{               
2871                 \textcolor{comment}{/* SELECT STC ROM */}    
2872                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE520U = 0xFFF0007CU;
2873                 *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE524U = 0x0A63FFFFU;
2874                 pbistREG->RAMT                  = 0x02002008U;
2875             \}
2876 
2877             \textcolor{comment}{/*  Setup using special reserved registers as part of errata fix */}
2878             \textcolor{comment}{/*      (Only to be used in this function) */}
2879             pbistREG->rsvd1[4U]    = 1U;
2880             pbistREG->rsvd1[0U]    = 3U;
2881 
2882             \textcolor{comment}{/* Start PMU counter */}
2883             \mbox{\hyperlink{sys__pmu_8h_a21f3fc4ef80d58b22d0545a5c08f230e}{\_pmuResetCounters\_}}();
2884             \mbox{\hyperlink{sys__pmu_8h_a05119721bf5533e9271717127c18c22c}{\_pmuStartCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2885 
2886             \textcolor{comment}{/* PBIST\_RUN */}
2887             pbistREG->rsvd1[1U]    = 1U;
2888 
2889             \textcolor{comment}{/* wait until memory self-test done is indicated */}
2890             \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
2891             \textcolor{keywordflow}{while} ((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x1U) != 0x1U) 
2892             \{
2893             \}\textcolor{comment}{/* Wait */}
2894 
2895             \textcolor{comment}{/* Stop PMU counter */}
2896             \mbox{\hyperlink{sys__pmu_8h_abab4f00952caa5d6596db0e6de0f445c}{\_pmuStopCounters\_}}(\mbox{\hyperlink{sys__pmu_8h_a6ee477e201310d4686e202a584c00f9e}{pmuCYCLE\_COUNTER}});
2897             
2898             \textcolor{comment}{/* Get CPU cycle count */}
2899             pmuCount =\mbox{\hyperlink{sys__pmu_8h_afd1c5a6e4a8806b15d4e8f72bd33fa16}{\_pmuGetCycleCount\_}}();
2900             
2901             \textcolor{comment}{/* Calculate PBIST test complete time in ROM Clock */}
2902             \textcolor{comment}{/* 2 - Divide value ( Default is 2 in HALCoGen) */}
2903             \textcolor{comment}{/* 1000 = 0x3E8 - Test Loop count in ROM Algorithm */}
2904             pmuCount = pmuCount - pmuCalibration;
2905             PBIST\_wait\_done\_loop = ((sint32)pmuCount/2) - 1000;
2906 
2907             \textcolor{comment}{/* Check PBIST status results (Address, Status, Count, etc...) */}
2908             \textcolor{keywordflow}{if} ((pbistREG->FSRA0 | pbistREG->FSRA1 | pbistREG->FSRDL0 | pbistREG->rsvd3 |
2909                  pbistREG->FSRDL1 | pbistREG->rsvd4[0U] | pbistREG->rsvd4[1U]) != 0U)
2910             \{
2911                 \textcolor{comment}{/* PBIST Failure for the Algorithm chosen above */}
2912                 \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL1);
2913             \}
2914 
2915             \textcolor{comment}{/* Check that the algorithm executed in the expected amount of time. */}
2916             \textcolor{comment}{/* This time is dependent on the ROMCLKDIV selected */}
2917             \textcolor{keywordflow}{if} ((PBIST\_wait\_done\_loop <= 20) || (PBIST\_wait\_done\_loop >= 200) )
2918             \{
2919                 \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL2);
2920             \}
2921 
2922             \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
2923             pbistREG->PACT = 0x0U;
2924 
2925             \textcolor{comment}{/* Disable PBIST */}
2926             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR &= 0xFFFFFFF0U;
2927             \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR |= 0x5U;
2928         \}
2929     \} \textcolor{comment}{/* ROM Loop */}
2930 
2931     \textcolor{comment}{/* ROM restore default setup */}
2932     \textcolor{comment}{/* (must be completed before continuing) */}
2933     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF040CU = 0x0000AA0AU;
2934     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF040CU = 0x0000AA05U;
2935     *(\textcolor{keyword}{volatile} uint32 *)0xFFFF0400U = 0x00000005U;
2936 
2937     \mbox{\hyperlink{sys__pmu_8h_a1bdff81dac3f3361f65b97a4197793a2}{\_pmuDisableCountersGlobal\_}}();
2938 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a3248a50d5c0516f336b46aa0114ba9be}\label{sys__selftest_8h_a3248a50d5c0516f336b46aa0114ba9be}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!fmc\+Bus2\+Check@{fmc\+Bus2\+Check}}
\index{fmc\+Bus2\+Check@{fmc\+Bus2\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{fmc\+Bus2\+Check()}{fmcBus2Check()}}
{\footnotesize\ttfamily void fmc\+Bus2\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Self Check Flash Bus2 Interface. 

This function self checks Flash Bus2 Interface 

Definition at line 760 of file sys\+\_\+selftest.\+c.



References esm\+R\+EG, flash\+W\+R\+EG, and fmc\+E\+C\+Ccheck().


\begin{DoxyCode}
761 \{
762 \textcolor{comment}{/* USER CODE BEGIN (32) */}
763 \textcolor{comment}{/* USER CODE END */}
764     \textcolor{comment}{/* enable ECC logic inside FMC */}
765     \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACCTRL1 = 0x000A060AU;
766 
767     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x40U) == 0x40U)
768     \{
769         \textcolor{comment}{/* a 1-bit error was detected during flash OTP read by flash module}
770 \textcolor{comment}{           run a self-check on ECC logic inside FMC */}
771 
772         \textcolor{comment}{/* clear ESM group1 channel 6 flag */}
773         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40U;
774 
775         \mbox{\hyperlink{sys__selftest_8c_a183a0d9f1300394cff2f8fe0aa034d4b}{fmcECCcheck}}();
776     \}
777 
778     \textcolor{comment}{/* no 2-bit or 1-bit error detected during power-up */}
779     \textcolor{keywordflow}{else}
780     \{
781         \mbox{\hyperlink{sys__selftest_8c_a183a0d9f1300394cff2f8fe0aa034d4b}{fmcECCcheck}}();
782     \}
783 \textcolor{comment}{/* USER CODE BEGIN (33) */}
784 \textcolor{comment}{/* USER CODE END */}
785 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a183a0d9f1300394cff2f8fe0aa034d4b}\label{sys__selftest_8h_a183a0d9f1300394cff2f8fe0aa034d4b}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!fmc\+E\+C\+Ccheck@{fmc\+E\+C\+Ccheck}}
\index{fmc\+E\+C\+Ccheck@{fmc\+E\+C\+Ccheck}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{fmc\+E\+C\+Ccheck()}{fmcECCcheck()}}
{\footnotesize\ttfamily void fmc\+E\+C\+Ccheck (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Check Flash E\+CC Single Bit and multi Bit errors detection logic. 

This function Checks Flash E\+CC Single Bit and multi Bit errors detection logic. 

Definition at line 795 of file sys\+\_\+selftest.\+c.



Referenced by fmc\+Bus2\+Check().


\begin{DoxyCode}
796 \{
797     \textcolor{keyword}{volatile} uint32 otpread;
798     \textcolor{keyword}{volatile} uint32 temp;
799 
800 \textcolor{comment}{/* USER CODE BEGIN (34) */}
801 \textcolor{comment}{/* USER CODE END */}
802 
803     \textcolor{comment}{/* read location with deliberate 1-bit error */}
804     otpread = flash1bitError;
805     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x40U) == 0x40U)
806     \{
807         \textcolor{comment}{/* 1-bit failure was indicated and corrected */}
808         \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS = 0x00010006U;
809 
810         \textcolor{comment}{/* clear ESM group1 channel 6 flag */}
811         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40U;
812 
813         \textcolor{comment}{/* read location with deliberate 2-bit error */}
814         otpread = flash2bitError;
815         \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U] & 0x80U) == 0x80U)
816         \{
817             \textcolor{comment}{/* 2-bit failure was detected correctly */}
818             temp = \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FUNCERRADD;
819             \mbox{\hyperlink{reg__flash_8h_ab65d4f98d84397753c538ff9053582a8}{flashWREG}}->FEDACSTATUS = 0x00020100U;
820 
821             \textcolor{comment}{/* clear ESM group3 channel 7 */}
822             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[2U] = 0x80U;
823 
824             \textcolor{comment}{/* The nERROR pin will become inactive once the LTC counter expires */}
825             \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->EKR = 0x5U;
826 
827         \}
828         \textcolor{keywordflow}{else}
829         \{
830             \textcolor{comment}{/* ECC logic inside FMC cannot detect 2-bit error */}
831             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(FMCECCCHECK\_FAIL1);
832         \}
833     \}
834     \textcolor{keywordflow}{else}
835     \{
836         \textcolor{comment}{/* ECC logic inside FMC cannot detect 1-bit error */}
837         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(FMCECCCHECK\_FAIL1);
838     \}
839 \textcolor{comment}{/* USER CODE BEGIN (35) */}
840 \textcolor{comment}{/* USER CODE END */}
841 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a66f658578435dc4d3984c76a3d2ed959}\label{sys__selftest_8h_a66f658578435dc4d3984c76a3d2ed959}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!het1\+Parity\+Check@{het1\+Parity\+Check}}
\index{het1\+Parity\+Check@{het1\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{het1\+Parity\+Check()}{het1ParityCheck()}}
{\footnotesize\ttfamily void het1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+E\+T1 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+E\+T1 R\+AM parity error detection and signaling mechanism 

Definition at line 1301 of file sys\+\_\+selftest.\+c.



References het\+R\+E\+G1.


\begin{DoxyCode}
1302 \{
1303     \textcolor{keyword}{volatile} uint32 nhetread = 0U;
1304     uint32 hetpcr\_bk = \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR;
1305 
1306 \textcolor{comment}{/* USER CODE BEGIN (53) */}
1307 \textcolor{comment}{/* USER CODE END */}
1308 
1309     \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1310     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x0000010AU;
1311 
1312     \textcolor{comment}{/* flip parity bit */}
1313     NHET1RAMPARLOC ^= 0x1U;
1314 
1315     \textcolor{comment}{/* Disable TEST mode */}
1316     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x0000000AU;
1317 
1318     \textcolor{comment}{/* read to cause parity error */}
1319     nhetread = NHET1RAMLOC;
1320 
1321     \textcolor{comment}{/* check if ESM group1 channel 7 is flagged */}
1322     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80U) ==0U)
1323     \{
1324         \textcolor{comment}{/* NHET1 RAM parity error was not flagged to ESM. */}
1325         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HET1PARITYCHECK\_FAIL1);
1326     \}
1327     \textcolor{keywordflow}{else}
1328     \{
1329         \textcolor{comment}{/* clear ESM group1 channel 7 flag */}
1330         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80U;
1331 
1332         \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1333         \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = 0x0000010AU;
1334 
1335         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1336         NHET1RAMPARLOC ^= 0x1U;
1337     \}
1338 
1339     \textcolor{comment}{/* Restore Parity comtrol register */}
1340     \mbox{\hyperlink{reg__het_8h_a1fb756f91c591fa0957b44eb250396bf}{hetREG1}}->PCR = hetpcr\_bk;
1341 
1342 \textcolor{comment}{/* USER CODE BEGIN (54) */}
1343 \textcolor{comment}{/* USER CODE END */}
1344 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a08473bcd7b0a42d859fe99011c4707b7}\label{sys__selftest_8h_a08473bcd7b0a42d859fe99011c4707b7}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!het2\+Parity\+Check@{het2\+Parity\+Check}}
\index{het2\+Parity\+Check@{het2\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{het2\+Parity\+Check()}{het2ParityCheck()}}
{\footnotesize\ttfamily void het2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+E\+T2 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+E\+T2 R\+AM parity error detection and signaling mechanism 

Definition at line 1411 of file sys\+\_\+selftest.\+c.



References het\+R\+E\+G2.


\begin{DoxyCode}
1412 \{
1413     \textcolor{keyword}{volatile} uint32 nhetread = 0U;
1414     uint32 hetpcr\_bk = \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR;
1415     uint32 esmCh7Stat, esmCh34Stat = 0U;
1416     
1417 \textcolor{comment}{/* USER CODE BEGIN (57) */}
1418 \textcolor{comment}{/* USER CODE END */}
1419 
1420     \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1421     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x0000010AU;
1422 
1423     \textcolor{comment}{/* flip parity bit */}
1424     NHET2RAMPARLOC ^= 0x1U;
1425 
1426     \textcolor{comment}{/* Disable TEST mode */}
1427     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x0000000AU;
1428 
1429     \textcolor{comment}{/* read to cause parity error */}
1430     nhetread = NHET2RAMLOC;
1431 
1432     \textcolor{comment}{/* check if ESM group1 channel 7 or 34 (If not reserved) is flagged */}
1433     esmCh7Stat  = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x80U;
1434     esmCh34Stat = \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] & 0x4U;
1435     \textcolor{keywordflow}{if} ((esmCh7Stat == 0U) && (esmCh34Stat ==0U))
1436     \{
1437         \textcolor{comment}{/* NHET2 RAM parity error was not flagged to ESM. */}
1438         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HET2PARITYCHECK\_FAIL1);
1439     \}
1440     \textcolor{keywordflow}{else}
1441     \{
1442         \textcolor{comment}{/* clear ESM group1 channel 7 flag */}
1443         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x80U;
1444 
1445         \textcolor{comment}{/* clear ESM group1 channel 34 flag */}
1446         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR4[0U] = 0x4U;
1447 
1448         \textcolor{comment}{/* Set TEST mode and enable parity checking */}
1449         \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = 0x0000010AU;
1450 
1451         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1452         NHET2RAMPARLOC ^= 0x1U;
1453     \}
1454 
1455     \textcolor{comment}{/* Restore parity control register */}
1456     \mbox{\hyperlink{reg__het_8h_aafb44d44d36dc6bc8bbec6acb4f252ca}{hetREG2}}->PCR = hetpcr\_bk;
1457 
1458 \textcolor{comment}{/* USER CODE BEGIN (58) */}
1459 \textcolor{comment}{/* USER CODE END */}
1460 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a5f69665c7b7abb003cfb4a314ce1e943}\label{sys__selftest_8h_a5f69665c7b7abb003cfb4a314ce1e943}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!htu1\+Parity\+Check@{htu1\+Parity\+Check}}
\index{htu1\+Parity\+Check@{htu1\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{htu1\+Parity\+Check()}{htu1ParityCheck()}}
{\footnotesize\ttfamily void htu1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+T\+U1 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+T\+U1 R\+AM parity error detection and signaling mechanism 

Definition at line 1355 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1356 \{
1357     \textcolor{keyword}{volatile} uint32 hturead = 0U;
1358     uint32 htupcr\_bk = htuREG1->PCR;
1359 
1360 \textcolor{comment}{/* USER CODE BEGIN (55) */}
1361 \textcolor{comment}{/* USER CODE END */}
1362 
1363     \textcolor{comment}{/* Enable parity and TEST mode */}
1364     htuREG1->PCR = 0x0000010AU;
1365 
1366     \textcolor{comment}{/* flip parity bit */}
1367     HTU1PARLOC ^= 0x1U;
1368 
1369     \textcolor{comment}{/* Disable parity RAM test mode */}
1370     htuREG1->PCR = 0x0000000AU;
1371 
1372     \textcolor{comment}{/* read to cause parity error */}
1373     hturead = HTU1RAMLOC;
1374 
1375     \textcolor{comment}{/* check if ESM group1 channel 8 is flagged */}
1376     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x100U) == 0U)
1377     \{
1378         \textcolor{comment}{/* HTU1 RAM parity error was not flagged to ESM. */}
1379         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HTU1PARITYCHECK\_FAIL1);
1380     \}
1381     \textcolor{keywordflow}{else}
1382     \{
1383         \textcolor{comment}{/* Clear HTU parity error flag */}
1384         htuREG1->PAR = 0x00010000U;
1385         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x100U;
1386 
1387         \textcolor{comment}{/* Enable parity and TEST mode */}
1388         htuREG1->PCR = 0x0000010AU;
1389 
1390         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1391         HTU1PARLOC ^= 0x1U;
1392     \}
1393 
1394     \textcolor{comment}{/* Restore Parity control register */}
1395     htuREG1->PCR = htupcr\_bk;
1396 
1397 \textcolor{comment}{/* USER CODE BEGIN (56) */}
1398 \textcolor{comment}{/* USER CODE END */}
1399 
1400 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_aaf183a3ffe2ce7257d5fbceb4cca69f0}\label{sys__selftest_8h_aaf183a3ffe2ce7257d5fbceb4cca69f0}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!htu2\+Parity\+Check@{htu2\+Parity\+Check}}
\index{htu2\+Parity\+Check@{htu2\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{htu2\+Parity\+Check()}{htu2ParityCheck()}}
{\footnotesize\ttfamily void htu2\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check H\+T\+U2 R\+AM parity error detection and signaling mechanism. 

Routine to check H\+T\+U2 R\+AM parity error detection and signaling mechanism 

Definition at line 1471 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1472 \{
1473     \textcolor{keyword}{volatile} uint32 hturead = 0U;
1474     uint32 htupcr\_bk = htuREG2->PCR;
1475 
1476 \textcolor{comment}{/* USER CODE BEGIN (59) */}
1477 \textcolor{comment}{/* USER CODE END */}
1478 
1479     \textcolor{comment}{/* Enable parity and TEST mode */}
1480     htuREG2->PCR = 0x0000010AU;
1481 
1482     \textcolor{comment}{/* flip parity bit */}
1483     HTU2PARLOC ^= 0x1U;
1484 
1485     \textcolor{comment}{/* Disable parity RAM test mode */}
1486     htuREG2->PCR = 0x0000000AU;
1487 
1488     \textcolor{comment}{/* read to cause parity error */}
1489     hturead = HTU2RAMLOC;
1490 
1491     \textcolor{comment}{/* check if ESM group1 channel 8 is flagged */}
1492     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x100U) == 0U)
1493     \{
1494         \textcolor{comment}{/* HTU2 RAM parity error was not flagged to ESM. */}
1495         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(HTU2PARITYCHECK\_FAIL1);
1496     \}
1497     \textcolor{keywordflow}{else}
1498     \{
1499         \textcolor{comment}{/* Clear HTU parity error flag */}
1500         htuREG2->PAR = 0x00010000U;
1501         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x100U;
1502 
1503         \textcolor{comment}{/* Enable parity and TEST mode */}
1504         htuREG2->PCR = 0x0000010AU;
1505 
1506         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1507         HTU2PARLOC ^= 0x1U;
1508     \}
1509 
1510     \textcolor{comment}{/* Restore parity control register*/}
1511     htuREG2->PCR = htupcr\_bk;
1512 
1513 \textcolor{comment}{/* USER CODE BEGIN (60) */}
1514 \textcolor{comment}{/* USER CODE END */}
1515 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a3184dfe0846903e1111348942160dfe7}\label{sys__selftest_8h_a3184dfe0846903e1111348942160dfe7}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!memory\+Init@{memory\+Init}}
\index{memory\+Init@{memory\+Init}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{memory\+Init()}{memoryInit()}}
{\footnotesize\ttfamily void memory\+Init (\begin{DoxyParamCaption}\item[{uint32}]{ram }\end{DoxyParamCaption})}



Memory Initialization Driver. 

This function is called to perform Memory initialization of selected R\+AM\textquotesingle{}s. 

Definition at line 184 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G1.


\begin{DoxyCode}
185 \{
186 \textcolor{comment}{/* USER CODE BEGIN (6) */}
187 \textcolor{comment}{/* USER CODE END */}
188 
189     \textcolor{comment}{/* Enable Memory Hardware Initialization */}
190     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0xAU;
191 
192     \textcolor{comment}{/* Enable Memory Hardware Initialization for selected RAM's */}
193     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA  = ram;
194 
195     \textcolor{comment}{/* Wait until Memory Hardware Initialization complete */}
196     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
197     \textcolor{keywordflow}{while}((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x00000100U) != 0x00000100U)
198     \{
199     \}\textcolor{comment}{/* Wait */}
200 
201     \textcolor{comment}{/* Disable Memory Hardware Initialization */}
202     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
203 
204 \textcolor{comment}{/* USER CODE BEGIN (7) */}
205 \textcolor{comment}{/* USER CODE END */}
206 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a01f1d76b843e64acb8bb464d79b9cd45}\label{sys__selftest_8h_a01f1d76b843e64acb8bb464d79b9cd45}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!memory\+Port0\+Test\+Fail\+Notification@{memory\+Port0\+Test\+Fail\+Notification}}
\index{memory\+Port0\+Test\+Fail\+Notification@{memory\+Port0\+Test\+Fail\+Notification}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{memory\+Port0\+Test\+Fail\+Notification()}{memoryPort0TestFailNotification()}}
{\footnotesize\ttfamily void memory\+Port0\+Test\+Fail\+Notification (\begin{DoxyParamCaption}\item[{uint32}]{group\+Select,  }\item[{uint32}]{data\+Select,  }\item[{uint32}]{address,  }\item[{uint32}]{data }\end{DoxyParamCaption})}



Memory Port 0 test fail notification. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+Select} & Failing Ram group select\+: \\
\hline
\mbox{\tt in}  & {\em data\+Select} & Failing Ram data select\+: \\
\hline
\mbox{\tt in}  & {\em address} & Failing Ram offset\+: \\
\hline
\mbox{\tt in}  & {\em data} & Failing data at address\+:\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function has to be provide by the user. 
\end{DoxyNote}


Definition at line 83 of file notification.\+c.


\begin{DoxyCode}
84 \{
85 \textcolor{comment}{/*  enter user code between the USER CODE BEGIN and USER CODE END. */}
86 \textcolor{comment}{/* USER CODE BEGIN (5) */}
87 \textcolor{comment}{/* USER CODE END */}
88 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a27770bcd3ed64bdd085157a5c99a3502}\label{sys__selftest_8h_a27770bcd3ed64bdd085157a5c99a3502}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!memory\+Port1\+Test\+Fail\+Notification@{memory\+Port1\+Test\+Fail\+Notification}}
\index{memory\+Port1\+Test\+Fail\+Notification@{memory\+Port1\+Test\+Fail\+Notification}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{memory\+Port1\+Test\+Fail\+Notification()}{memoryPort1TestFailNotification()}}
{\footnotesize\ttfamily void memory\+Port1\+Test\+Fail\+Notification (\begin{DoxyParamCaption}\item[{uint32}]{group\+Select,  }\item[{uint32}]{data\+Select,  }\item[{uint32}]{address,  }\item[{uint32}]{data }\end{DoxyParamCaption})}



Memory Port 1 test fail notification. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em group\+Select} & Failing Ram group select\+: \\
\hline
\mbox{\tt in}  & {\em data\+Select} & Failing Ram data select\+: \\
\hline
\mbox{\tt in}  & {\em address} & Failing Ram offset\+: \\
\hline
\mbox{\tt in}  & {\em data} & Failing data at address\+:\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function has to be provide by the user. 
\end{DoxyNote}


Definition at line 93 of file notification.\+c.


\begin{DoxyCode}
94 \{
95 \textcolor{comment}{/*  enter user code between the USER CODE BEGIN and USER CODE END. */}
96 \textcolor{comment}{/* USER CODE BEGIN (7) */}
97 \textcolor{comment}{/* USER CODE END */}
98 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a050e0c2257b541e651eb35d32f10c98d}\label{sys__selftest_8h_a050e0c2257b541e651eb35d32f10c98d}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!mibspi1\+Parity\+Check@{mibspi1\+Parity\+Check}}
\index{mibspi1\+Parity\+Check@{mibspi1\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{mibspi1\+Parity\+Check()}{mibspi1ParityCheck()}}
{\footnotesize\ttfamily void mibspi1\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check M\+I\+B\+S\+P\+I1 R\+AM parity error detection and signaling mechanism. 

Routine to check M\+I\+B\+S\+P\+I1 R\+AM parity error detection and signaling mechanism 

Definition at line 1825 of file sys\+\_\+selftest.\+c.



References mibspi\+P\+A\+R\+R\+A\+M1, and mibspi\+R\+E\+G1.


\begin{DoxyCode}
1826 \{
1827     \textcolor{keyword}{volatile} uint32 spiread = 0U;
1828     uint32 mibspie\_bk = \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->MIBSPIE;
1829     uint32 mibspictl\_bk = \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL;
1830 
1831 \textcolor{comment}{/* USER CODE BEGIN (71) */}
1832 \textcolor{comment}{/* USER CODE END */}
1833 
1834     \textcolor{comment}{/* enable multi-buffered mode */}
1835     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->MIBSPIE = 0x1U;
1836 
1837     \textcolor{comment}{/* enable parity error detection */}
1838     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL = (\mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL & 0xFFFFFFF0U) | (0xAU);
1839 
1840     \textcolor{comment}{/* enable parity test mode */}
1841     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL |= 0x00000100U;
1842 
1843     \textcolor{comment}{/* flip bit 0 of the parity location */}
1844     \mbox{\hyperlink{reg__mibspi_8h_a3e70cf83cef67d59bf3c7236dd1e0a19}{mibspiPARRAM1}} ^= 0x1U;
1845 
1846     \textcolor{comment}{/* disable parity test mode */}
1847     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL &= 0xFFFFFEFFU;
1848 
1849     \textcolor{comment}{/* read from MibSPI1 RAM to cause parity error */}
1850     spiread = MIBSPI1RAMLOC;
1851 
1852     \textcolor{comment}{/* check if ESM group1 channel 17 is flagged */}
1853     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x20000U) == 0U)
1854     \{
1855         \textcolor{comment}{/* No MibSPI1 RAM parity error was flagged to ESM. */}
1856         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(MIBSPI1PARITYCHECK\_FAIL1);
1857     \}
1858     \textcolor{keywordflow}{else}
1859     \{
1860         \textcolor{comment}{/* clear parity error flags */}
1861         \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRSTAT = 0x3U;
1862 
1863         \textcolor{comment}{/* clear ESM group1 channel 17 flag */}
1864         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x20000U;
1865 
1866         \textcolor{comment}{/* enable parity test mode */}
1867         \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL |= 0x00000100U;
1868 
1869         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1870         \mbox{\hyperlink{reg__mibspi_8h_a3e70cf83cef67d59bf3c7236dd1e0a19}{mibspiPARRAM1}} ^= 0x1U;
1871     \}
1872 
1873     \textcolor{comment}{/* Restore MIBSPI control registers */}
1874     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->UERRCTRL = mibspictl\_bk;
1875     \mbox{\hyperlink{reg__mibspi_8h_a59785fe30b9ecba3095b820f844910df}{mibspiREG1}}->MIBSPIE = mibspie\_bk;
1876 
1877 \textcolor{comment}{/* USER CODE BEGIN (72) */}
1878 \textcolor{comment}{/* USER CODE END */}
1879 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ae4c80f3599811e410da64821448b860b}\label{sys__selftest_8h_ae4c80f3599811e410da64821448b860b}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!mibspi3\+Parity\+Check@{mibspi3\+Parity\+Check}}
\index{mibspi3\+Parity\+Check@{mibspi3\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{mibspi3\+Parity\+Check()}{mibspi3ParityCheck()}}
{\footnotesize\ttfamily void mibspi3\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check M\+I\+B\+S\+P\+I3 R\+AM parity error detection and signaling mechanism. 

Routine to check M\+I\+B\+S\+P\+I3 R\+AM parity error detection and signaling mechanism 

Definition at line 1889 of file sys\+\_\+selftest.\+c.



References mibspi\+P\+A\+R\+R\+A\+M3, and mibspi\+R\+E\+G3.


\begin{DoxyCode}
1890 \{
1891     \textcolor{keyword}{volatile} uint32 spiread = 0U;
1892     uint32 mibspie\_bk = \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->MIBSPIE;
1893     uint32 mibspictl\_bk = \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL;
1894 
1895 \textcolor{comment}{/* USER CODE BEGIN (73) */}
1896 \textcolor{comment}{/* USER CODE END */}
1897 
1898     \textcolor{comment}{/* enable multi-buffered mode */}
1899     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->MIBSPIE = 0x1U;
1900 
1901     \textcolor{comment}{/* enable parity test mode */}
1902     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL |= 0x00000100U;
1903 
1904     \textcolor{comment}{/* flip bit 0 of the parity location */}
1905     \mbox{\hyperlink{reg__mibspi_8h_af440f4d730ee907f7998683662d38a99}{mibspiPARRAM3}} ^= 0x1U;
1906 
1907     \textcolor{comment}{/* enable parity error detection */}
1908     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL = (\mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL & 0xFFFFFFF0U) | (0xAU);
1909 
1910     \textcolor{comment}{/* disable parity test mode */}
1911     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL &= 0xFFFFFEFFU;
1912 
1913     \textcolor{comment}{/* read from MibSPI3 RAM to cause parity error */}
1914     spiread = MIBSPI3RAMLOC;
1915 
1916     \textcolor{comment}{/* check if ESM group1 channel 18 is flagged */}
1917     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x40000U) == 0U)
1918     \{
1919         \textcolor{comment}{/* No MibSPI3 RAM parity error was flagged to ESM. */}
1920         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(MIBSPI3PARITYCHECK\_FAIL1);
1921     \}
1922     \textcolor{keywordflow}{else}
1923     \{
1924         \textcolor{comment}{/* clear parity error flags */}
1925         \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRSTAT = 0x3U;
1926 
1927         \textcolor{comment}{/* clear ESM group1 channel 18 flag */}
1928         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x40000U;
1929 
1930         \textcolor{comment}{/* enable parity test mode */}
1931         \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL |= 0x00000100U;
1932 
1933         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1934         \mbox{\hyperlink{reg__mibspi_8h_af440f4d730ee907f7998683662d38a99}{mibspiPARRAM3}} ^= 0x1U;
1935     \}
1936 
1937     \textcolor{comment}{/* Restore MIBSPI control registers */}
1938     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->UERRCTRL = mibspictl\_bk;
1939     \mbox{\hyperlink{reg__mibspi_8h_ac68545bfe7877266ef53a0dd49fd8322}{mibspiREG3}}->MIBSPIE = mibspie\_bk;
1940 
1941 \textcolor{comment}{/* USER CODE BEGIN (74) */}
1942 \textcolor{comment}{/* USER CODE END */}
1943 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a8ce4f5d8f1e282ddab7f65f5c5840e0a}\label{sys__selftest_8h_a8ce4f5d8f1e282ddab7f65f5c5840e0a}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!mibspi5\+Parity\+Check@{mibspi5\+Parity\+Check}}
\index{mibspi5\+Parity\+Check@{mibspi5\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{mibspi5\+Parity\+Check()}{mibspi5ParityCheck()}}
{\footnotesize\ttfamily void mibspi5\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check M\+I\+B\+S\+P\+I5 R\+AM parity error detection and signaling mechanism. 

Routine to check M\+I\+B\+S\+P\+I5 R\+AM parity error detection and signaling mechanism 

Definition at line 1953 of file sys\+\_\+selftest.\+c.



References mibspi\+P\+A\+R\+R\+A\+M5, and mibspi\+R\+E\+G5.


\begin{DoxyCode}
1954 \{
1955     \textcolor{keyword}{volatile} uint32 spiread = 0U;
1956     uint32 mibspie\_bk = \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->MIBSPIE;
1957     uint32 mibspictl\_bk = \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL;
1958 
1959 \textcolor{comment}{/* USER CODE BEGIN (75) */}
1960 \textcolor{comment}{/* USER CODE END */}
1961 
1962     \textcolor{comment}{/* enable multi-buffered mode */}
1963     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->MIBSPIE = 0x1U;
1964 
1965     \textcolor{comment}{/* enable parity test mode */}
1966     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL |= 0x00000100U;
1967 
1968     \textcolor{comment}{/* flip bit 0 of the parity location */}
1969     \mbox{\hyperlink{reg__mibspi_8h_a1443f050f83a68a49c7eed4c0084a511}{mibspiPARRAM5}} ^= 0x1U;
1970 
1971     \textcolor{comment}{/* enable parity error detection */}
1972     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL = (\mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL & 0xFFFFFFF0U) | (0xAU);
1973 
1974     \textcolor{comment}{/* disable parity test mode */}
1975     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL &= 0xFFFFFEFFU;
1976 
1977     \textcolor{comment}{/* read from MibSPI5 RAM to cause parity error */}
1978     spiread = MIBSPI5RAMLOC;
1979 
1980     \textcolor{comment}{/* check if ESM group1 channel 24 is flagged */}
1981     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x01000000U) == 0U)
1982     \{
1983         \textcolor{comment}{/* No MibSPI5 RAM parity error was flagged to ESM. */}
1984         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(MIBSPI5PARITYCHECK\_FAIL1);
1985     \}
1986     \textcolor{keywordflow}{else}
1987     \{
1988         \textcolor{comment}{/* clear parity error flags */}
1989         \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRSTAT = 0x3U;
1990 
1991         \textcolor{comment}{/* clear ESM group1 channel 24 flag */}
1992         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x01000000U;
1993 
1994         \textcolor{comment}{/* enable parity test mode */}
1995         \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL |= 0x00000100U;
1996 
1997         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1998         \mbox{\hyperlink{reg__mibspi_8h_a1443f050f83a68a49c7eed4c0084a511}{mibspiPARRAM5}} ^= 0x1U;
1999     \}
2000 
2001     \textcolor{comment}{/* Restore MIBSPI control registers */}
2002     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->UERRCTRL = mibspictl\_bk;
2003     \mbox{\hyperlink{reg__mibspi_8h_af010584e2232f2dfbf59da41599d0e41}{mibspiREG5}}->MIBSPIE = mibspie\_bk;
2004 
2005 \textcolor{comment}{/* USER CODE BEGIN (76) */}
2006 \textcolor{comment}{/* USER CODE END */}
2007 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a1edb8a500b4ad0f3e87b93245856a937}\label{sys__selftest_8h_a1edb8a500b4ad0f3e87b93245856a937}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Get\+Config\+Value@{pbist\+Get\+Config\+Value}}
\index{pbist\+Get\+Config\+Value@{pbist\+Get\+Config\+Value}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Get\+Config\+Value()}{pbistGetConfigValue()}}
{\footnotesize\ttfamily void pbist\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structpbist__config__reg}{pbist\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2646 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2647 \{
2648     \textcolor{keywordflow}{if} (type == InitialValue)
2649     \{
2650         config\_reg->CONFIG\_RAMT = PBIST\_RAMT\_CONFIGVALUE;
2651         config\_reg->CONFIG\_DLR = PBIST\_DLR\_CONFIGVALUE;
2652         config\_reg->CONFIG\_PACT = PBIST\_PACT\_CONFIGVALUE;
2653         config\_reg->CONFIG\_PBISTID = PBIST\_PBISTID\_CONFIGVALUE;
2654         config\_reg->CONFIG\_OVER = PBIST\_OVER\_CONFIGVALUE;
2655         config\_reg->CONFIG\_FSRDL1 = PBIST\_FSRDL1\_CONFIGVALUE;
2656         config\_reg->CONFIG\_ROM = PBIST\_ROM\_CONFIGVALUE;
2657         config\_reg->CONFIG\_ALGO = PBIST\_ALGO\_CONFIGVALUE;
2658         config\_reg->CONFIG\_RINFOL = PBIST\_RINFOL\_CONFIGVALUE;
2659         config\_reg->CONFIG\_RINFOU = PBIST\_RINFOU\_CONFIGVALUE;
2660     \}
2661     \textcolor{keywordflow}{else}
2662     \{
2663     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2664         config\_reg->CONFIG\_RAMT = pbistREG->RAMT;
2665         config\_reg->CONFIG\_DLR = pbistREG->DLR;
2666         config\_reg->CONFIG\_PACT = pbistREG->PACT;
2667         config\_reg->CONFIG\_PBISTID = pbistREG->PBISTID;
2668         config\_reg->CONFIG\_OVER = pbistREG->OVER;
2669         config\_reg->CONFIG\_FSRDL1 = pbistREG->FSRDL1;
2670         config\_reg->CONFIG\_ROM = pbistREG->ROM;
2671         config\_reg->CONFIG\_ALGO = pbistREG->ALGO;
2672         config\_reg->CONFIG\_RINFOL = pbistREG->RINFOL;
2673         config\_reg->CONFIG\_RINFOU = pbistREG->RINFOU;
2674     \}
2675 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a2675f441b1c7bbadd9877cfd586bf959}\label{sys__selftest_8h_a2675f441b1c7bbadd9877cfd586bf959}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Is\+Test\+Completed@{pbist\+Is\+Test\+Completed}}
\index{pbist\+Is\+Test\+Completed@{pbist\+Is\+Test\+Completed}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Is\+Test\+Completed()}{pbistIsTestCompleted()}}
{\footnotesize\ttfamily boolean pbist\+Is\+Test\+Completed (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Checks to see if the P\+B\+I\+ST test is completed. 

\begin{DoxyReturn}{Returns}
1 if P\+B\+I\+ST test completed, otherwise 0.
\end{DoxyReturn}
Checks to see if the P\+B\+I\+ST test is completed. 

Definition at line 503 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G1.


\begin{DoxyCode}
504 \{
505 \textcolor{comment}{/* USER CODE BEGIN (22) */}
506 \textcolor{comment}{/* USER CODE END */}
507 
508     \textcolor{keywordflow}{return} ((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x1U) != 0U);
509 \textcolor{comment}{/* USER CODE BEGIN (23) */}
510 \textcolor{comment}{/* USER CODE END */}
511 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a975a794505ddcaf5d1c68e7a229fc8ae}\label{sys__selftest_8h_a975a794505ddcaf5d1c68e7a229fc8ae}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Is\+Test\+Passed@{pbist\+Is\+Test\+Passed}}
\index{pbist\+Is\+Test\+Passed@{pbist\+Is\+Test\+Passed}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Is\+Test\+Passed()}{pbistIsTestPassed()}}
{\footnotesize\ttfamily boolean pbist\+Is\+Test\+Passed (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Checks to see if the P\+B\+I\+ST test is completed successfully. 

\begin{DoxyReturn}{Returns}
1 if P\+B\+I\+ST test passed, otherwise 0.
\end{DoxyReturn}
Checks to see if the P\+B\+I\+ST test is completed successfully. 

Definition at line 522 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
523 \{
524 \textcolor{comment}{/* USER CODE BEGIN (24) */}
525 \textcolor{comment}{/* USER CODE END */}
526     \textcolor{keywordtype}{boolean} status;
527 
528     \textcolor{keywordflow}{if} (pbistREG->FSRF0 == 0U)
529     \{
530         status = \mbox{\hyperlink{hal__stdtypes_8h_aa8cecfc5c5c054d2875c03e77b7be15d}{TRUE}};
531     \}
532     \textcolor{keywordflow}{else}
533     \{
534         status = \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
535     \}
536 \textcolor{comment}{/* USER CODE BEGIN (25) */}
537 \textcolor{comment}{/* USER CODE END */}
538     \textcolor{keywordflow}{return} status;
539 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a3edbda42e27655bb5e9a3d067ab09caf}\label{sys__selftest_8h_a3edbda42e27655bb5e9a3d067ab09caf}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Port\+Test\+Status@{pbist\+Port\+Test\+Status}}
\index{pbist\+Port\+Test\+Status@{pbist\+Port\+Test\+Status}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Port\+Test\+Status()}{pbistPortTestStatus()}}
{\footnotesize\ttfamily boolean pbist\+Port\+Test\+Status (\begin{DoxyParamCaption}\item[{uint32}]{port }\end{DoxyParamCaption})}



Checks to see if the P\+B\+I\+ST Port test is completed successfully. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em port} & -\/ Select the port to get the status. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if P\+B\+I\+ST Port test completed successfully, otherwise 0.
\end{DoxyReturn}
Checks to see if the selected P\+B\+I\+ST Port test is completed successfully. 

Definition at line 551 of file sys\+\_\+selftest.\+c.



References P\+B\+I\+S\+T\+\_\+\+P\+O\+R\+T0.


\begin{DoxyCode}
552 \{
553     \textcolor{keywordtype}{boolean} status;
554 \textcolor{comment}{/* USER CODE BEGIN (26) */}
555 \textcolor{comment}{/* USER CODE END */}
556 
557     \textcolor{keywordflow}{if}(port == (uint32)\mbox{\hyperlink{sys__selftest_8h_aedcde68ef8c4640e211695cebd10afa3a2f1ea5882d645e86e9a7e8f809c5f5ea}{PBIST\_PORT0}})
558     \{
559       status =  (pbistREG->FSRF0 == 0U);
560     \}
561     \textcolor{keywordflow}{else}
562     \{
563       \textcolor{comment}{/* Invalid Input */}
564       status =  \mbox{\hyperlink{hal__stdtypes_8h_aa93f0eb578d23995850d61f7d61c55c1}{FALSE}};
565     \}
566 
567     \textcolor{keywordflow}{return}  status;
568 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ad5fcc064d8d51dda635d83235cf37e3e}\label{sys__selftest_8h_ad5fcc064d8d51dda635d83235cf37e3e}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Run@{pbist\+Run}}
\index{pbist\+Run@{pbist\+Run}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Run()}{pbistRun()}}
{\footnotesize\ttfamily void pbist\+Run (\begin{DoxyParamCaption}\item[{uint32}]{raminfoL,  }\item[{uint32}]{algomask }\end{DoxyParamCaption})}



C\+PU self test Driver. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em raminfoL} & -\/ Select the list of R\+AM to be tested. \\
\hline
\mbox{\tt in}  & {\em algomask} & -\/ Select the list of Algorithm to be run.\\
\hline
\end{DoxyParams}
This function performs Memory Built-\/in Self test using P\+B\+I\+ST module. 

Definition at line 421 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G1.


\begin{DoxyCode}
422 \{
423     \textcolor{keyword}{volatile} uint32 i = 0U;
424 
425 \textcolor{comment}{/* USER CODE BEGIN (17) */}
426 \textcolor{comment}{/* USER CODE END */}
427 
428     \textcolor{comment}{/* PBIST ROM clock frequency = HCLK frequency /2 */}
429     \textcolor{comment}{/* Disable memory self controller */}
430     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x00000105U;
431 
432     \textcolor{comment}{/* Disable Memory Initialization controller */}
433     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
434 
435     \textcolor{comment}{/* Enable PBIST controller */}
436     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA = 0x1U;
437 
438     \textcolor{comment}{/* Enable memory self controller */}
439     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x0000010AU;
440 
441     \textcolor{comment}{/* wait for 32 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
442     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
443     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
444     \textcolor{keywordflow}{for} (i=0U; i<(32U + (32U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
445 
446 \textcolor{comment}{/* USER CODE BEGIN (18) */}
447 \textcolor{comment}{/* USER CODE END */}
448 
449     \textcolor{comment}{/* Enable PBIST clocks and ROM clock */}
450     pbistREG->PACT = 0x3U;
451 
452     \textcolor{comment}{/* Select all algorithms to be tested */}
453     pbistREG->ALGO = algomask;
454 
455     \textcolor{comment}{/* Select RAM groups */}
456     pbistREG->RINFOL = raminfoL;
457 
458     \textcolor{comment}{/* Select all RAM groups */}
459     pbistREG->RINFOU = 0x00000000U;
460 
461     \textcolor{comment}{/* ROM contents will not override RINFOx settings */}
462     pbistREG->OVER = 0x0U;
463 
464     \textcolor{comment}{/* Algorithm code is loaded from ROM */}
465     pbistREG->ROM = 0x3U;
466 
467     \textcolor{comment}{/* Start PBIST */}
468     pbistREG->DLR = 0x14U;
469 
470 \textcolor{comment}{/* USER CODE BEGIN (19) */}
471 \textcolor{comment}{/* USER CODE END */}
472 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ac9b7e2d9da2b5166a9ea002d431e54ef}\label{sys__selftest_8h_ac9b7e2d9da2b5166a9ea002d431e54ef}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Self\+Check@{pbist\+Self\+Check}}
\index{pbist\+Self\+Check@{pbist\+Self\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Self\+Check()}{pbistSelfCheck()}}
{\footnotesize\ttfamily void pbist\+Self\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



P\+B\+I\+ST self test Driver. 

This function is called to perform P\+B\+I\+ST self test.

\begin{DoxyNote}{Note}
This Function uses register\textquotesingle{}s which are not exposed to users through T\+RM , to run custom algorithm to make P\+B\+I\+ST Fail. Users can use this function as Black box. 
\end{DoxyNote}


Definition at line 312 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
313 \{
314     \textcolor{keyword}{volatile} uint32 i = 0U;
315     uint32 PBIST\_wait\_done\_loop = 0U;
316 \textcolor{comment}{/* USER CODE BEGIN (13) */}
317 \textcolor{comment}{/* USER CODE END */}
318     \textcolor{comment}{/* Run a diagnostic check on the memory self-test controller */}
319     \textcolor{comment}{/* First set up the PBIST ROM clock as this clock frequency is limited to 90MHz */}
320 
321     \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
322     pbistREG->PACT = 0x0U;
323     
324     \textcolor{comment}{/* PBIST ROM clock frequency = HCLK frequency /2 */}
325     \textcolor{comment}{/* Disable memory self controller */}
326     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x00000105U;                
327     
328     \textcolor{comment}{/* Disable Memory Initialization controller */}
329     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MINITGCR = 0x5U;
330 
331     \textcolor{comment}{/* Enable memory self controller */}
332     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR = 0x0000010AU;                               
333 
334     \textcolor{comment}{/* Clear PBIST Done */}
335     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT = 0x1U;
336     
337     \textcolor{comment}{/* Enable PBIST controller */}
338     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSINENA = 0x1U;
339 
340     \textcolor{comment}{/* wait for 32 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
341     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
342     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
343     \textcolor{keywordflow}{for} (i=0U; i<(32U + (32U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
344 
345 \textcolor{comment}{/* USER CODE BEGIN (14) */}
346 \textcolor{comment}{/* USER CODE END */}
347 
348     \textcolor{comment}{/* Enable PBIST clocks and ROM clock */}
349     pbistREG->PACT = 0x3U;
350 
351     \textcolor{comment}{/* CPU control of PBIST */}
352     pbistREG->DLR = 0x10U;
353 
354     \textcolor{comment}{/* Custom always fail algo, this will not use the ROM and just set a fail */}
355     pbistREG->RAMT         = 0x00002000U;
356     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE400U = 0x4C000001U;
357     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE440U = 0x00000075U;
358     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE404U = 0x4C000002U;
359     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE444U = 0x00000075U;
360     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE408U = 0x4C000003U;
361     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE448U = 0x00000075U;
362     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE40CU = 0x4C000004U;
363     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE44CU = 0x00000075U;
364     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE410U = 0x4C000005U;
365     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE450U = 0x00000075U;
366     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE414U = 0x4C000006U;
367     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE454U = 0x00000075U;
368     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE418U = 0x00000000U;
369     *(\textcolor{keyword}{volatile} uint32 *)0xFFFFE458U = 0x00000001U;
370 
371     \textcolor{comment}{/* PBIST\_RUN */}
372     pbistREG->rsvd1[1U]    = 1U;
373 
374     \textcolor{comment}{/* wait until memory self-test done is indicated */}
375     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "Hardware status bit read check" */}
376     \textcolor{keywordflow}{while} ((\mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTCGSTAT & 0x1U) != 0x1U) 
377     \{
378         PBIST\_wait\_done\_loop++;
379     \}\textcolor{comment}{/* Wait */}
380 
381     \textcolor{comment}{/* Check for the failure */}
382     \textcolor{keywordflow}{if} ((pbistREG->FSRF0 & 0x1U) != 0x1U)
383     \{
384         \textcolor{comment}{/* No failure was indicated even if the always fail algorithm was run*/}
385         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL1);
386 
387 \textcolor{comment}{/* USER CODE BEGIN (15) */}
388 \textcolor{comment}{/* USER CODE END */}
389     \}
390     \textcolor{keywordflow}{else}
391     \{
392         \textcolor{comment}{/* Check that the algorithm executed in the expected amount of time. */}
393         \textcolor{comment}{/* This time is dependent on the ROMCLKDIV selected above            */}
394         \textcolor{keywordflow}{if} (PBIST\_wait\_done\_loop >= 2U)
395         \{
396             \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(PBISTSELFCHECK\_FAIL2);
397         \}
398         
399         \textcolor{comment}{/* Disable PBIST clocks and ROM clock */}
400         pbistREG->PACT = 0x0U;
401 
402         \textcolor{comment}{/* Disable PBIST */}
403         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR &= 0xFFFFFFF0U;
404         \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR |= 0x5U;
405 
406 \textcolor{comment}{/* USER CODE BEGIN (16) */}
407 \textcolor{comment}{/* USER CODE END */}
408     \}
409 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a1ea172c81d7549cd8181de098a91b752}\label{sys__selftest_8h_a1ea172c81d7549cd8181de098a91b752}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!pbist\+Stop@{pbist\+Stop}}
\index{pbist\+Stop@{pbist\+Stop}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{pbist\+Stop()}{pbistStop()}}
{\footnotesize\ttfamily void pbist\+Stop (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to stop P\+B\+I\+ST test enabled. 

This function is called to stop P\+B\+I\+ST after test is performed. 

Definition at line 482 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
483 \{
484 \textcolor{comment}{/* USER CODE BEGIN (20) */}
485 \textcolor{comment}{/* USER CODE END */}
486     \textcolor{comment}{/* disable pbist clocks and ROM clock */}
487     pbistREG->PACT = 0x0U;
488     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR &= 0xFFFFFFF0U;
489     \mbox{\hyperlink{reg__system_8h_a8c52b62df956810205e4da7a2fd74efa}{systemREG1}}->MSTGCR |= 0x5U;
490 \textcolor{comment}{/* USER CODE BEGIN (21) */}
491 \textcolor{comment}{/* USER CODE END */}
492 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_ae96e990763ae7d45bd55ea5a27299a47}\label{sys__selftest_8h_ae96e990763ae7d45bd55ea5a27299a47}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!selftest\+Fail\+Notification@{selftest\+Fail\+Notification}}
\index{selftest\+Fail\+Notification@{selftest\+Fail\+Notification}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{selftest\+Fail\+Notification()}{selftestFailNotification()}}
{\footnotesize\ttfamily void selftest\+Fail\+Notification (\begin{DoxyParamCaption}\item[{uint32}]{flag }\end{DoxyParamCaption})}



Self test fail service routine. 

This function is called if there is a self test fail with appropriate flag 

Definition at line 58 of file sys\+\_\+selftest.\+c.



Referenced by adc1\+Parity\+Check(), adc2\+Parity\+Check(), can1\+Parity\+Check(), can2\+Parity\+Check(), can3\+Parity\+Check(), check\+Clock\+Monitor(), check\+Flash\+E\+E\+P\+R\+O\+M\+E\+C\+C(), check\+P\+L\+L1\+Slip(), and system\+Init().


\begin{DoxyCode}
59 \{
60 
61 \textcolor{comment}{/* USER CODE BEGIN (1) */}
62 \textcolor{comment}{/* USER CODE END */}
63 
64 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_afb360fa06ebe94d06978d25371ed2140}\label{sys__selftest_8h_afb360fa06ebe94d06978d25371ed2140}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!stc\+Get\+Config\+Value@{stc\+Get\+Config\+Value}}
\index{stc\+Get\+Config\+Value@{stc\+Get\+Config\+Value}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{stc\+Get\+Config\+Value()}{stcGetConfigValue()}}
{\footnotesize\ttfamily void stc\+Get\+Config\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structstc__config__reg}{stc\+\_\+config\+\_\+reg\+\_\+t}} $\ast$}]{config\+\_\+reg,  }\item[{\mbox{\hyperlink{sys__common_8h_a9daf9a5992391b058477d28d107ee5e2}{config\+\_\+value\+\_\+type\+\_\+t}}}]{type }\end{DoxyParamCaption})}



Get the initial or current values of the configuration registers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em $\ast$config\+\_\+reg} & pointer to the struct to which the initial or current value of the configuration registers need to be stored \\
\hline
\mbox{\tt in}  & {\em type} & whether initial or current value of the configuration registers need to be stored
\begin{DoxyItemize}
\item Initial\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\item Current\+Value\+: initial value of the configuration registers will be stored in the struct pointed by config\+\_\+reg
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
This function will copy the initial or current value (depending on the parameter \textquotesingle{}type\textquotesingle{}) of the configuration registers to the struct pointed by config\+\_\+reg 

Definition at line 2691 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
2692 \{
2693     \textcolor{keywordflow}{if} (type == InitialValue)
2694     \{
2695         config\_reg->CONFIG\_STCGCR0 = STC\_STCGCR0\_CONFIGVALUE;
2696         config\_reg->CONFIG\_STCGCR1 = STC\_STCGCR1\_CONFIGVALUE;
2697         config\_reg->CONFIG\_STCTPR = STC\_STCTPR\_CONFIGVALUE;
2698         config\_reg->CONFIG\_STCSCSCR = STC\_STCSCSCR\_CONFIGVALUE;
2699     \}
2700     \textcolor{keywordflow}{else}
2701     \{
2702     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "LDRA Tool issue" */}
2703         config\_reg->CONFIG\_STCGCR0 = stcREG->STCGCR0;
2704         config\_reg->CONFIG\_STCGCR1 = stcREG->STCGCR1;
2705         config\_reg->CONFIG\_STCTPR = stcREG->STCTPR;
2706         config\_reg->CONFIG\_STCSCSCR = stcREG->STCSCSCR;
2707     \}
2708 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a54f7309e862bab7a63c2c176c4b7cee9}\label{sys__selftest_8h_a54f7309e862bab7a63c2c176c4b7cee9}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!stc\+Self\+Check@{stc\+Self\+Check}}
\index{stc\+Self\+Check@{stc\+Self\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{stc\+Self\+Check()}{stcSelfCheck()}}
{\footnotesize\ttfamily void stc\+Self\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



S\+TC module self check Driver. 

This function is called to perform S\+TC module self check. 

Definition at line 216 of file sys\+\_\+selftest.\+c.



References system\+R\+E\+G2.


\begin{DoxyCode}
217 \{
218 \textcolor{comment}{/* USER CODE BEGIN (8) */}
219 \textcolor{comment}{/* USER CODE END */}
220     \textcolor{keyword}{volatile} uint32 i = 0U;
221 
222     \textcolor{comment}{/* Run a diagnostic check on the CPU self-test controller */}
223     \textcolor{comment}{/* First set up the STC clock divider as STC is only supported up to 90MHz */}
224 
225     \textcolor{comment}{/* STC clock is now normal mode CPU clock frequency/2 = 180MHz/2 */}
226     \mbox{\hyperlink{reg__system_8h_aa7b03254a6e13afea4c05b2fe8b2186b}{systemREG2}}->STCCLKDIV = 0x01000000U;
227 
228     \textcolor{comment}{/* Select one test interval, restart self-test next time, 0x00010001 */}
229     stcREG->STCGCR0 = 0x00010001U;
230 
231     \textcolor{comment}{/* Enable comparator self-check and stuck-at-0 fault insertion in CPU, 0x1A */}
232     stcREG->STCSCSCR = 0x1AU;
233 
234     \textcolor{comment}{/* Maximum time-out period */}
235     stcREG->STCTPR = 0xFFFFFFFFU;
236 
237     \textcolor{comment}{/* wait for 16 VBUS clock cycles at least, based on HCLK to VCLK ratio */}
238     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
239     \textcolor{comment}{/*SAFETYMCUSW 134 S MR:12.2 <APPROVED> "Wait for few clock cycles (Value of i not used)" */}
240     \textcolor{keywordflow}{for} (i=0U; i<(16U + (16U * 1U)); i++)\{ \textcolor{comment}{/* Wait */} \}
241 
242     \textcolor{comment}{/* Enable self-test */}
243     stcREG->STCGCR1 = 0xAU;
244 
245 \textcolor{comment}{/* USER CODE BEGIN (9) */}
246 \textcolor{comment}{/* USER CODE END */}
247 
248     \textcolor{comment}{/* Idle the CPU so that the self-test can start */}
249     \mbox{\hyperlink{sys__core_8h_a9ac3ba78e1c8af4d0b6a5381b11858b2}{\_gotoCPUIdle\_}}();
250 
251 \textcolor{comment}{/* USER CODE BEGIN (10) */}
252 \textcolor{comment}{/* USER CODE END */}
253 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_a2c1518db428c8ab63a56048cadfb4e6e}\label{sys__selftest_8h_a2c1518db428c8ab63a56048cadfb4e6e}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!stc\+Self\+Check\+Fail@{stc\+Self\+Check\+Fail}}
\index{stc\+Self\+Check\+Fail@{stc\+Self\+Check\+Fail}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{stc\+Self\+Check\+Fail()}{stcSelfCheckFail()}}
{\footnotesize\ttfamily void stc\+Self\+Check\+Fail (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



S\+TC Self test check fail service routine. 

This function is called if S\+TC Self test check fail. 

Definition at line 1130 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1131 \{
1132 \textcolor{comment}{/* USER CODE BEGIN (43) */}
1133 \textcolor{comment}{/* USER CODE END */}
1134     \textcolor{comment}{/* CPU self-test controller's own self-test failed.}
1135 \textcolor{comment}{     * It is not possible to verify that STC is capable of indicating a CPU self-test error.}
1136 \textcolor{comment}{     * It is not recommended to continue operation.}
1137 \textcolor{comment}{     */}
1138 
1139     \textcolor{comment}{/* User can add small piece of code to take system to Safe state using user code section.}
1140 \textcolor{comment}{     * Note: Just removing the for(;;) will take the system to unknown state under ST failure,}
1141 \textcolor{comment}{     * since it is not handled by HALCoGen driver */}
1142 \textcolor{comment}{/* USER CODE BEGIN (44) */}
1143 \textcolor{comment}{/* USER CODE END */}
1144     \textcolor{comment}{/*SAFETYMCUSW 5 C MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the user
       codes above and below" */}
1145     \textcolor{comment}{/*SAFETYMCUSW 26 S MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1146     \textcolor{comment}{/*SAFETYMCUSW 28 D MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif" in the
       user codes above and below" */}
1147     \textcolor{keywordflow}{for}(;;)
1148     \{
1149     \}\textcolor{comment}{/* Wait */}
1150 \textcolor{comment}{/* USER CODE BEGIN (45) */}
1151 \textcolor{comment}{/* USER CODE END */}
1152 \}
\end{DoxyCode}
\mbox{\Hypertarget{sys__selftest_8h_af7297818ebd5ffd62488091aa9633bf9}\label{sys__selftest_8h_af7297818ebd5ffd62488091aa9633bf9}} 
\index{sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}!vim\+Parity\+Check@{vim\+Parity\+Check}}
\index{vim\+Parity\+Check@{vim\+Parity\+Check}!sys\+\_\+selftest.\+h@{sys\+\_\+selftest.\+h}}
\subsubsection{\texorpdfstring{vim\+Parity\+Check()}{vimParityCheck()}}
{\footnotesize\ttfamily void vim\+Parity\+Check (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Routine to check V\+IM R\+AM parity error detection and signaling mechanism. 

Routine to check V\+IM R\+AM parity error detection and signaling mechanism 

Definition at line 1187 of file sys\+\_\+selftest.\+c.


\begin{DoxyCode}
1188 \{
1189     \textcolor{keyword}{volatile} uint32 vimramread = 0U;
1190     uint32 vimparctl\_bk = VIM\_PARCTL;
1191 
1192 \textcolor{comment}{/* USER CODE BEGIN (49) */}
1193 \textcolor{comment}{/* USER CODE END */}
1194 
1195     \textcolor{comment}{/* Enable parity checking and parity test mode */}
1196     VIM\_PARCTL = 0x0000010AU;
1197 
1198     \textcolor{comment}{/* flip a bit in the VIM RAM parity location */}
1199     VIMRAMPARLOC ^= 0x1U;
1200 
1201     \textcolor{comment}{/* disable parity test mode */}
1202     VIM\_PARCTL = 0x0000000AU;
1203 
1204     \textcolor{comment}{/* cause parity error */}
1205     vimramread = VIMRAMLOC;
1206 
1207     \textcolor{comment}{/* check if ESM group1 channel 15 is flagged */}
1208     \textcolor{keywordflow}{if} ((\mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] & 0x8000U) ==0U)
1209     \{
1210         \textcolor{comment}{/* VIM RAM parity error was not flagged to ESM. */}
1211         \mbox{\hyperlink{sys__selftest_8c_ae96e990763ae7d45bd55ea5a27299a47}{selftestFailNotification}}(VIMPARITYCHECK\_FAIL1);
1212     \}
1213     \textcolor{keywordflow}{else}
1214     \{
1215         \textcolor{comment}{/* clear VIM RAM parity error flag in VIM */}
1216         VIM\_PARFLG = 0x1U;
1217 
1218         \textcolor{comment}{/* clear ESM group1 channel 15 flag */}
1219         \mbox{\hyperlink{reg__esm_8h_a7c2e779f2973e0c2c9496a4796df10f1}{esmREG}}->SR1[0U] = 0x8000U;
1220 
1221         \textcolor{comment}{/* Enable parity checking and parity test mode */}
1222         VIM\_PARCTL = 0x0000010AU;
1223 
1224         \textcolor{comment}{/* Revert back to correct data, flip bit 0 of the parity location */}
1225         VIMRAMPARLOC ^= 0x1U;
1226     \}
1227 
1228     \textcolor{comment}{/* Restore Parity Control register */}
1229     VIM\_PARCTL = vimparctl\_bk;
1230 
1231 \textcolor{comment}{/* USER CODE BEGIN (50) */}
1232 \textcolor{comment}{/* USER CODE END */}
1233 \}
\end{DoxyCode}
